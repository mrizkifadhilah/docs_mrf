---
title: Review Paper - Pencarian Kode Berbasis Analisis Ketercapaian Petri Net
description: Rangkuman paper tentang metode pencarian kode semantik berbasis Petri Net Reachability Analysis (Journal of Computer Research and Development, 2022).
head:
  - - meta
    - name: keywords
      content: code search, petri net, reachability analysis, semantic matching, code reuse
---

# 068 - 基于Petri网可达分析的代码搜索方法 (Code Search Method Based on the Reachability Analysis of Petri Nets)
Tautan (DOI) [https://doi.org/10.7544/issn1000-1239.20200586]

**Penulis:** **丁雪儿** $^{1}$, **钮俊** $^{1*}$, **张开乐** $^{1}$, **毛昕怡** $^{1}$

**Afiliasi:**
* $^{1}$ Faculty of Electrical Engineering and Computer Science, Ningbo University, Ningbo, Zhejiang 315211
* $^{2}$ Key Laboratory of Embedded System and Service Computing (Tongji University), Ministry of Education, Shanghai 201804

**Kronologi:** Received: 31 Juli 2020 • Revised: 22 Februari 2021 • Published: 2022

<a href="https://www.scimagojr.com/journalsearch.php?q=26714&tip=sid" target="_blank"><img src="https://www.scimagojr.com/journal_img.php?id=26714" alt="SCImago Journal & Country Rank" /></a>

| Resume Eksekutif |
| :--- |
| **Publikasi:**<br>• **Jurnal:** Journal of Computer Research and Development 59, 1 (2022)<br>• **Topik:** Peningkatan akurasi dan efisiensi *code search* semantik, khususnya untuk kueri dengan **berbagai bentuk tipe input/output** dan mengatasi keterbatasan model *Input/Output-Value* dan *I/O-Type* tradisional.<br><br>**Masalah & Solusi:**<br>• **Masalah 1:** Metode *code search* berbasis *Input/Output Value* (I/O-Value) sulit untuk menangani kode tanpa nilai I/O eksplisit (seperti koneksi DB) dan terbatas pada input tunggal.<br>• **Masalah 2:** Metode berbasis *Input/Output Type* (I/O-Type) tradisional hanya dapat menangani **tipe input tunggal** dan mengabaikan jumlah parameter dengan tipe yang sama, yang menghasilkan perilaku kode yang tidak lengkap.<br>• **Solusi:** Mengusulkan metode *code search* semantik berbasis **Analisis Ketercapaian Petri Net (Petri Net Reachability Analysis)**. Model *Petri Net* (*PN*) digunakan untuk memodelkan proses pengolahan data dan tipe di dalam kode. Kueri diubah menjadi *Initial Marking* ($M_0$) dan *Target Marking* ($M^*$) pada PN. Kecocokan ditemukan dengan mencari jalur yang dapat dicapai ($M_0 \rightarrow M^*$) di dalam *Reachability Graph* yang telah dipotong (*pruned*).<br><br>**Contoh Penerapan:**<br>• Metode ini diuji menggunakan 20 kueri populer berlabel Java dari Stack Overflow terhadap korpus $\mathbf{189.442}$ fungsi Java dari GitHub.<br>• Metode ini mencapai akurasi **MAP 0.56** dan **MRR 0.60**, secara signifikan lebih tinggi daripada metode *Type Matching* tradisional (MAP 0.41, MRR 0.47) dan *Text Matching* (MAP 0.35, MRR 0.31).<br><br>**Metodologi:**<br>• **Pemodelan Perilaku Kode:** Perilaku kode (jumlah dan tipe objek data) dikonversi menjadi model **Petri Net** yang ditingkatkan:<br>    - *Place* (庫所, $P$): Merepresentasikan tipe objek data.<br>    - *Transition* (变迁, $T$): Merepresentasikan pernyataan program/operasi.<br>    - *Weighted Arc* (有向弧权重, $W$): Merepresentasikan jumlah tipe data input/output yang dikonsumsi/dihasilkan.<br>• **Penanganan Objek Berulang:** Memperkenalkan **Transisi Replika (复制变迁, $C$)** untuk objek data yang digunakan berulang kali. Ini mencegah token sumber daya dikonsumsi secara prematur dalam *PN*, sehingga meningkatkan akurasi analisis.<br>• **Kueri ke Marking:** Kueri *I/O Type* diubah menjadi $M_0$ (token untuk tipe input) dan $M^*$ (token untuk tipe output).<br>• **Analisis Ketercapaian:** Digunakan algoritma **Reachability Graph Generation** yang dimodifikasi. Dilakukan **pemotongan (*pruning*)** graf menggunakan **Induce Net ($\alpha(PN)$)** untuk menghilangkan jalur yang tidak mungkin mencapai $M^*$ (berdasarkan Prop. 1), sehingga meningkatkan efisiensi.<br>• **Ranking:** Hasil akhir diurutkan berdasarkan **Panjang Urutan Fungsional** dan **Tingkat Reusabilitas Kode**.<br><br>**Temuan Kunci:**<br>1. **Akurasi Superior:** Metode ini secara signifikan melampaui metode *Text Matching* dan *Existing Type Matching* dalam hal MAP dan MRR.<br>2. **Solusi Multitype:** Berhasil menyelesaikan masalah pencarian dengan **beberapa tipe input** yang tidak dapat ditangani oleh metode *Type Matching* tradisional.<br>3. **Efisiensi:** Teknik pemotongan *Reachability Graph* mengurangi waktu pencarian secara signifikan (hingga ~30% pada kueri tertentu).<br>4. **Kontribusi Replika:** *Transition* Replika terbukti penting, secara drastis meningkatkan *P@10* (misalnya, dari 0 menjadi 0.5 pada kueri 11) dengan memastikan sumber daya yang berulang tidak dikonsumsi.<br><br>**Kontribusi Utama:**<br>• Mengusulkan metode pemodelan perilaku kode berbasis **Petri Net** yang baru, mengintegrasikan tipe dan jumlah objek data secara eksplisit.<br>• Mengembangkan metode pencarian kode semantik berbasis **Analisis Ketercapaian Petri Net** dengan *pruning* untuk mendukung pencocokan berbagai bentuk tipe I/O secara efisien.<br><br>**Dampak:**<br>• Menyediakan metode yang lebih **akurat dan efisien** untuk mencari kode semantik, terutama untuk tugas-tugas pemrograman kompleks atau kode tanpa nilai I/O eksplisit (seperti koneksi database), sehingga mendorong *code reuse* berkualitas tinggi. |

## 1. Pendahuluan & Masalah

Meningkatkan efisiensi dan kualitas pengembangan perangkat lunak dapat dicapai melalui *code reuse* (penggunaan kembali kode). *Code search* semantik, yang berfokus pada fungsionalitas atau perilaku yang diinginkan pengguna, adalah metode kunci untuk memfasilitasi *reuse* yang cepat dan akurat.

Metode *code search* yang ada memiliki dua kategori utama:
1.  **Berbasis Nilai I/O (I/O-Value Matching):** Metode ini menggunakan pasangan nilai input/output konkret. Namun, ini dibatasi oleh kesulitan dalam menyediakan nilai batas (terutama pada kode kompleks), dan ketidakmampuannya menangani kode tanpa I/O eksplisit (seperti koneksi basis data).
2.  **Berbasis Tipe I/O (I/O-Type Matching):** Metode ini menggunakan tipe data daripada nilai konkret dan sering memodelkan fungsionalitas kode sebagai *Type Conversion Graph*. Namun, pekerjaan yang ada memiliki batasan:
    *   Hanya dapat menangani **tipe input tunggal** (kurangnya dukungan untuk *multiple input types*).
    *   Mengabaikan analisis untuk beberapa parameter dengan **tipe yang sama**.

Keterbatasan ini mengakibatkan deskripsi perilaku kode yang tidak lengkap, membatasi akurasi dan penerapan pencarian kode.

::: tip Solusi yang Diusulkan
Paper ini mengusulkan metode *code search* semantik baru berbasis **Analisis Ketercapaian Petri Net (Petri Net Reachability Analysis)**. Metode ini memodelkan proses pengolahan data dan tipe dalam kode menjadi **Petri Net** yang ditingkatkan. Dengan mendefinisikan kueri sebagai *Initial Marking* ($M_0$) dan *Target Marking* ($M^*$), metode ini mencari jalur yang dapat dicapai ($M_0 \rightarrow M^*$) di dalam PN, yang secara efektif mendukung kueri dengan berbagai bentuk tipe I/O dan meningkatkan akurasi secara signifikan.
:::

## 2. Metodologi

Metode ini dibagi menjadi tiga fase utama: Pemodelan Perilaku Kode, Analisis Ketercapaian, dan Pengurutan Hasil.

### A. Pemodelan Perilaku Kode Berbasis Petri Net

Petri Net (PN) secara formal digunakan untuk memodelkan proses pengolahan data, di mana objek data dipandang sebagai **sumber daya** dan operasi kode dipandang sebagai **peristiwa** yang menyebabkan aliran sumber daya.

1.  **Pemetaan Elemen Kode ke Petri Net (PN):**
    *   **Tipe Objek Data:** Direpresentasikan sebagai **Tempat (*Place*, $P$)**.
    *   **Pernyataan Program/Operasi:** Direpresentasikan sebagai **Transisi (*Transition*, $T$)**.
    *   **Jumlah Input/Output:** Direpresentasikan sebagai **Bobot Busur (*Weighted Arc*, $W$)**. Misalnya, jika suatu pernyataan memerlukan tiga string input, busur input ke *Transition* tersebut dari *Place* "String" akan memiliki bobot 3.
2.  **Penanganan Objek Berulang (*Reused Objects*):** Untuk objek data yang digunakan berulang kali (misalnya, objek *Connection* yang dipanggil beberapa kali), diperkenalkan **Transisi Replika (复制变迁, $C$)** khusus. Transisi ini memiliki bobot busur output sama dengan jumlah kali objek tersebut digunakan kembali, memastikan sumber daya tidak habis setelah penggunaan pertama dan memungkinkan analisis semantik yang lebih lengkap.

Model PN yang dihasilkan (bersama dengan Transisi Replika) untuk semua kode kandidat disimpan dalam basis data grafik Neo4j.

### B. Analisis Ketercapaian (Reachability Analysis)

1.  **Konstruksi Marking:** Kueri *Input/Output Type* pengguna dikonversi menjadi *Marking* PN:
    *   **Initial Marking ($M_0$):** Jumlah token di setiap *Place* sama dengan jumlah tipe input yang sesuai yang disediakan pengguna. $M_0[\text{Place}] = n$ jika tipe tersebut ada, dan $M_0[\text{void}] = 1$ (untuk menangani pernyataan tanpa input eksplisit).
    *   **Target Marking ($M^*$):** Jumlah token di *Place* tipe output yang diinginkan adalah 1. $M^*[\text{Place}] = 1$, dan $M^*[\text{void}] \geq 0$.
2.  **Reachability Graph Generation and Pruning:**
    *   **Reachability Graph ($GR$):** *GR* dihasilkan dari $M_0$, yang memodelkan semua status *Marking* yang dapat dicapai.
    *   **Pruning (Pemotongan):** Untuk mengatasi ledakan status (*state explosion*) dan meningkatkan efisiensi, dilakukan pemotongan *GR* berdasarkan **Induce Net ($\alpha(PN)$)**. *Induce Net* adalah grafik berarah yang hanya menunjukkan hubungan ketercapaian antara *Place* (tipe data).
    *   **Logika Pemotongan:** Berdasarkan Prop. 1, jika dalam $\alpha(PN)$ tidak ada jalur dari *Place* $p$ ke *Target Place* $p^*$, maka tidak perlu menganalisis *Marking* di mana $p$ memiliki token. Langkah ini menghilangkan simpul *Marking* yang berlebihan dan tidak mungkin mencapai $M^*$, seperti yang diverifikasi oleh Teorema 1.
3.  **Code Matching:** Kecocokan ditemukan jika *Target Marking* $M^*$ ada dalam *Reachability Graph* yang dihasilkan ($GR^*$).

## 3. Detail Pengujian

### Dataset
*   **Korpus Kode:** $\mathbf{189.442}$ fragmen kode tingkat fungsi Java dikumpulkan dari 200 proyek *open source* GitHub dengan peringkat bintang tinggi.
*   **Kueri:** **20** kueri populer berlabel Java dari Stack Overflow (ditunjukkan pada Tabel 3), termasuk kueri dengan *multiple input types* (misalnya, Q7, Q8, Q14, Q19).

### Metrik Evaluasi
Tiga metrik digunakan untuk mengukur akurasi dan efisiensi:

1.  **P@n (Precision at n):** Akurasi hasil $n$ teratas.
    $$P@n=\frac{1}{n}\sum_{k=1}^{n}rel_{k}$$
2.  **MAP (Mean Average Precision):** Rata-rata dari *Average Precision* di seluruh kueri.
    $$MAP=\frac{1}{|Q|}\sum_{i=1}^{|Q|}AveP(i)$$
3.  **MRR (Mean Reciprocal Rank):** Kebalikan dari peringkat hasil relevan pertama.
    $$MRR=\frac{1}{|Q|}\sum_{i=1}^{|Q|}\frac{1}{rank_{i}}$$

### Metode Perbandingan (Baseline)
1.  **Metode Berbasis Pencocokan Teks (*Text Matching*):** Menggunakan model perhitungan kesamaan tekstual (seperti yang umum pada mesin pencari kode).
2.  **Metode Pencocokan Tipe yang Ada (*Existing Type Matching*):** Hanya mempertimbangkan keberadaan jalur tipe I/O dalam grafik berarah, mengabaikan masalah ketercapaian (jumlah input/output tipe).

## 4. Hasil Eksperimen

### A. Perbandingan Akurasi (Tabel 4)

Perbandingan performa untuk kueri *single input type*:

| Metode Pencarian Kode | MAP | MRR |
| :--- | :--- | :--- |
| **Metode Ini** | **0.56** | **0.60** |
| Metode Pencocokan Teks | 0.35 | 0.31 |
| Metode Pencocokan Tipe yang Ada | 0.41 | 0.47 |

*   **Peningkatan Akurasi:** Metode berbasis Petri Net ini secara signifikan melampaui kedua *baseline*. Perbaikan ini disebabkan oleh integrasi analisis perilaku kode yang lebih komprehensif (mempertimbangkan jumlah dan ketercapaian) yang tidak ada pada metode *Text* maupun *Type Matching* tradisional.

### B. Analisis Kontribusi Teknis

1.  **Transisi Replika ($C$):** Eksperimen (Gambar 13) menunjukkan bahwa **pengaturan Transisi Replika secara kritis meningkatkan P@10**. Tanpa $C$, *P@10* turun drastis (seringkali menjadi 0.0), karena model *PN* secara tidak benar mengkonsumsi token sumber daya pada penggunaan pertama objek yang dimaksudkan untuk digunakan kembali, menyebabkan operasi selanjutnya tidak dapat diaktifkan.

2.  **Pemotongan Reachability Graph:** Eksperimen (Gambar 14) menunjukkan bahwa **pemotongan (*pruning*) secara signifikan mengurangi waktu pencarian** dibandingkan dengan algoritma *Reachability Graph* standar, memitigasi masalah ledakan status.

3.  **Dukungan Multiple Input Type:** Metode ini berhasil menangani kueri yang melibatkan beberapa input (seperti Q7: String, String, String, String/Connection), yang tidak dapat ditangani oleh metode *Type Matching* tradisional.

## 5. Kesimpulan

Paper ini mengusulkan metode *code search* semantik baru yang memanfaatkan **Analisis Ketercapaian Petri Net** untuk memodelkan proses pengolahan tipe data dan kuantitasnya. Dengan memperkenalkan **Transisi Replika** dan menggunakan *pruning* berbasis **Induce Net**, metode ini secara efektif mengatasi batasan metode *I/O-Type* tradisional, khususnya mendukung kueri dengan berbagai bentuk tipe I/O. Hasil eksperimen menunjukkan peningkatan akurasi dan efisiensi yang nyata.

::: info Dampak Praktis
Metode ini menyediakan alat *code search* yang **lebih andal** bagi pengembang, terutama ketika berhadapan dengan tugas-tugas pemrograman yang kompleks atau yang sulit diwakili oleh nilai I/O eksplisit (misalnya, simulasi HTTP, koneksi basis data). Hal ini secara langsung meningkatkan efisiensi dan kualitas *code reuse*. Pekerjaan di masa depan akan mencakup penyempurnaan metode untuk hasil yang berlebihan atau terlalu sedikit (misalnya, dengan melonggarkan kueri atau menggunakan kasus uji spesifik).
:::