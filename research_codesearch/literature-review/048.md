---
title: Review Paper - HEBCS Metode Pencarian Kode Biner Efisiensi Tinggi
description: Rangkuman paper tentang HEBCS, metode pencarian kode biner berbasis Locality-Sensitive Hashing (LSH) untuk efisiensi tinggi dalam data skala besar (Electronics, 2023).
head:
  - - meta
    - name: keywords
      content: binary code search, binary code similarity, locality-sensitive hash, LSH, high efficiency, software analysis
---

# 048 - HEBCS: A High-Efficiency Binary Code Search Method
Tautan (DOI) [https://doi.org/10.3390/electronics12163464]

**Penulis:** **Xiangjie Sun** ᵃ, **Qiang Wei** ᵇ, **Jiang Du** ᵇ, **Yisen Wang** ᵇ*

**Afiliasi:**
* ᵃ School of Cyber Science and Engineering, Zhengzhou University, Zhengzhou 450002, China
* ᵇ School of Cyber Science and Engineering, PLA Information Engineering University, Zhengzhou 450001, China

**Kronologi:** Received: 3 July 2023 • Revised: 5 August 2023 • Accepted: 9 August 2023 • Available Online: 16 August 2023

<a href="https://www.scimagojr.com/journalsearch.php?q=21100829272&tip=sid" target="_blank"><img src="https://www.scimagojr.com/journal_img.php?id=21100829272" alt="SCImago Journal & Country Rank" /></a>

| Resume Eksekutif |
| :--- |
| **Publikasi:**<br>• **Jurnal:** Electronics, Vol. 12, No. 16, Article 3464 (2023)<br>• **Topik:** Metode pencarian kode biner efisiensi tinggi untuk menemukan kode yang serupa dalam basis data skala besar.<br><br>**Masalah & Solusi:**<br>• **Masalah:** Metode pencarian kode biner yang ada, meskipun menggunakan model ML canggih (misalnya GNN, Transformer) untuk analisis kesamaan, seringkali **kurang interpretatif** dan memiliki **efisiensi rendah** saat menangani fungsi skala besar, membatasi aplikasi praktisnya.<br>• **Solusi:** Mengusulkan **HEBCS** (*High-Efficiency Binary Code Search*). Metode ini menggunakan pendekatan interpretatif dengan **ekstraksi fitur *function-level* multidimensi**, mengubah setiap fitur menjadi representasi *Locality-Sensitive Hash* (LSH), dan menggabungkannya menjadi *hash* fungsi. Pemanfaatan **Prinsip Lubang Merpati (*Pigeonhole Principle*)** memungkinkan penyimpanan dan pengambilan yang sangat efisien, menjamin efisiensi tinggi bahkan pada data skala besar.<br><br>**Contoh Penerapan:**<br>• Pencarian kerentanan (*vulnerability queries*) dan analisis cacat kode (*code defect analysis*) dalam *firmware* dunia nyata (misalnya, *firmware* NETGEAR dan Tenda) dengan akurasi yang baik dan kecepatan pencarian yang jauh lebih tinggi daripada *baseline*.<br><br>**Metodologi:**<br>• **Ekstraksi Fitur:** Menggunakan 10 fitur dari 3 dimensi (Instruksi, Sintaks, Struktur) yang independen dari arsitektur (*cross-architecture*).<br>• **Representasi Hash:** Mengubah fitur numerik menggunakan algoritma pergeseran (*shift operation*), fitur *string* menggunakan **SimHash** (LSH), dan fitur struktural (CFG) menggunakan **Weisfeiler-Lehman (WL) test of isomorphism** menjadi representasi *hash* yang sensitif terhadap lokalitas.<br>• **Penimbangan Fitur:** Menggunakan algoritma **XGBoost** untuk secara otomatis menghitung dan menetapkan bobot $(w_i)$ pada *Hamming Distance* fitur, meningkatkan akurasi.<br>• **Pencarian Efisien:** Memanfaatkan **Prinsip Lubang Merpati** untuk segmentasi dan penyimpanan *hash* fungsi, yang secara drastis mengurangi waktu kompleksitas kueri dari $O(2^M \cdot M)$ menjadi $O((N+1) \cdot 2^{M-M/(N+1)})$, di mana $N$ adalah ambang batas *Hamming Distance*.<br><br>**Temuan Kunci:**<br>1. **Efisiensi Superior:** HEBCS mencapai kecepatan pencarian **3186 Functions/Seconds**, sekitar **5 kali** lebih cepat dari Trex (734 F/S) dan **50 kali** lebih cepat dari Gemini (69 F/S).<br>2. **Akurasi Setara:** Mempertahankan *Precision, Recall,* dan **F1-score** yang sebanding dengan metode *state-of-the-art* (misalnya, F1-score 0.938 vs 0.950 Trex pada X86 vs ARM).<br>3. **Hamming Distance Optimal:** Ambang batas *Hamming Distance* terbaik yang ditemukan adalah **58** (F1-score 0.964 pada data berbobot).<br>4. **Pelatihan Bobot Efektif:** Pelatihan bobot menggunakan XGBoost secara signifikan meningkatkan *Recall* dan *F1-score* dibandingkan tanpa pelatihan bobot.<br><br>**Kontribusi Utama:**<br>• Mengusulkan HEBCS, metode pencarian kode biner berbasis *hash* efisiensi tinggi yang **dapat diinterpretasi** dan **independen arsitektur**.<br>• Mengembangkan pendekatan *hashing* fitur multidimensi yang inovatif (Numerik, *String*, CFG) dengan penimbangan bobot menggunakan XGBoost.<br>• Mengintegrasikan **Prinsip Lubang Merpati** untuk mengoptimalkan penyimpanan dan pengambilan *hash* fungsi skala besar.<br><br>**Dampak:**<br>• Menyediakan solusi praktis dan skalabel untuk analisis perangkat lunak besar-besaran, terutama dalam deteksi kerentanan lintas-arsitektur, mengatasi keterbatasan efisiensi dari metode berbasis *deep learning* yang ada. |

## 1. Pendahuluan & Masalah

Seiring dengan pesatnya pertumbuhan teknologi Internet, *code reuse* (penggunaan kembali kode) menjadi praktik umum. Untuk melindungi kekayaan intelektual, sebagian besar kode didistribusikan dalam bentuk biner (*executable files*), bukan kode sumber. Teknik kesamaan kode biner (*binary code similarity*) sangat berharga dalam keamanan, membantu mengidentifikasi kesamaan dan perbedaan antar versi atau sumber kode yang berbeda. **Pencarian kode biner** adalah proses menggunakan teknik kesamaan untuk menemukan kode yang serupa dengan *snippet* yang diberikan dalam repositori. Aplikasi utamanya mencakup identifikasi kerentanan (*vulnerability detection*) dan analisis *patch* keamanan.

Tantangannya adalah proses kompilasi menghilangkan informasi program (nama fungsi, variabel, komentar) dan menghasilkan biner yang sangat bervariasi tergantung pada *compiler*, optimasi, dan arsitektur target. Meskipun banyak metode yang ada telah mengadopsi model *deep learning* (seperti GNN) untuk meningkatkan akurasi kesamaan, metode ini sering **kurang interpretatif** dan memiliki **efisiensi yang tidak memuaskan** ketika menghadapi data kode skala besar, menjadikannya kurang praktis untuk *codebase* Internet.

::: tip Solusi yang Diusulkan
Kami mengusulkan **HEBCS** (*High-Efficiency Binary Code Search*), sebuah metode pencarian kode biner efisiensi tinggi berbasis *Locality-Sensitive Hashing* (LSH). HEBCS mengekstrak fitur *function-level* multidimensi yang *interpretable* dan mengubahnya menjadi representasi *hash* yang unik. Dengan menggunakan **Prinsip Lubang Merpati** untuk penyimpanan dan kueri, HEBCS mencapai efisiensi tinggi sambil mempertahankan akurasi dan *recall* yang sebanding.
:::

## 2. Metodologi

Implementasi HEBCS terdiri dari tiga langkah utama: Ekstraksi Fitur, *Hashing* Fitur Fungsi, dan Pencarian Kesamaan.

### A. Seleksi Fitur (Feature Selection)

Untuk mengatasi tantangan *cross-architecture* dan menghindari analisis semantik yang kompleks, HEBCS mengekstrak fitur fungsi dari tiga dimensi independen arsitektur. Total **10 fitur** digunakan, diringkas dalam **Tabel 1** (sebenarnya 9 fitur unik, dengan WL test of isomorphism dihitung sebagai satu):

1.  **Atribut Instruksi (4):** Jumlah total instruksi, jumlah instruksi aritmatika, jumlah instruksi transfer, dan jumlah instruksi logika.
2.  **Atribut Sintaks (2):** Jumlah instruksi *call* dan *String constant*.
3.  **Atribut Struktur (4):** Jumlah panggilan masuk (*incoming calls*), jumlah *edges* dalam CFG, jumlah *basic blocks*, dan **Weisfeiler-Lehman (WL) test of isomorphism** (untuk kesamaan struktur CFG).

### B. Hashing Fitur Fungsi

Fitur yang diekstrak (numerik, *string*, *graph*) diubah menjadi representasi *hash* yang sensitif terhadap lokalitas agar nilai *hash* dari fitur yang serupa juga serupa.

1.  **Hashing Numerik:** Mengubah nilai numerik $X$ menjadi *hash* $H$ dengan $N$ *bit* menggunakan operasi pergeseran (*shift operation*). Nilai *hash* $H$ yang dihasilkan memungkinkan pengukuran kesamaan melalui *Hamming distance*, di mana:
    $$diff(H_{1},H_{2})=m$$
    di mana $m = |t_1 - t_2|$ adalah perbedaan jumlah *bit* pergeseran.
2.  **Hashing String (*String Hashing*):** Menggunakan algoritma **SimHash** (sejenis LSH) untuk mengubah konstanta *string* menjadi *hash* biner panjang tetap. Prosesnya melibatkan segmentasi kata, *hashing*, **penimbangan** (berdasarkan posisi *string* dalam kode, misal *printf* diberi bobot lebih besar), penggabungan, dan reduksi dimensi. *Weighted Hash* dihitung sebagai:
    $$Weighted Hash = \begin{cases}1 \times weight, \quad hashbit=1\\ -1 \times weight, \quad hashbit=0\end{cases}$$
3.  **Hashing CFG:** Menggunakan algoritma **Weisfeiler-Lehman (WL) test of isomorphism** untuk mengubah struktur CFG menjadi nilai *hash* 64-*bit*.

### C. Feature Weight Assignment dan Pengambilan Kesamaan

**1. Penimbangan Fitur:** Algoritma **XGBoost** digunakan selama proses pelatihan untuk secara otomatis menghitung dan memberikan bobot $(W_i)$ pada setiap fitur. Bobot ini didasarkan pada skor kepentingan fitur (*feature importance score*), yang merupakan akumulasi jumlah fitur tersebut dipilih sebagai *segmentation node* dalam semua pohon keputusan. *Hamming distance* terbobot antara dua fungsi $F_1$ dan $F_2$ dihitung sebagai:

$$Distance(F_1, F_2) = d_1 \times W_1 + d_2 \times W_2 + d_3 \times W_3 + \dots + d_n \times W_n$$

di mana $d_i$ adalah *Hamming distance* fitur $i$.

**2. Pencarian Kesamaan (Similarity Search):** Untuk pencarian skala besar, **Prinsip Lubang Merpati** digunakan untuk menyimpan dan mengkueri *hash* fungsi secara efisien. Jika ambang batas *Hamming Distance* diatur sebagai $N$, *hash* $M$-*bit* dibagi menjadi $N+1$ segmen.

*   Setiap fungsi diindeks $N+1$ kali, dengan setiap segmen berfungsi sebagai kunci (*Key*) dan segmen sisanya sebagai nilai (*Value*).
*   Kompleksitas kueri dikurangi secara drastis dari $O(2^M \cdot M)$ menjadi $O((N+1) \cdot 2^{M-M/(N+1)})$, memungkinkan operasi yang cepat pada *dataset* miliaran data.

## 3. Detail Pengujian

### Dataset
*   **Dataset Pelatihan & Evaluasi:** Fungsi dari paket GNU (a2sp, binutils, coreutils) dan 4 versi OpenSSL (1.01f, 1.01u, 1.11a, 1.11b). Total $\mathbf{213.364}$ fungsi digunakan untuk evaluasi efektivitas, dan $\mathbf{576.379}$ fungsi digunakan untuk menguji efisiensi.
*   **Arsitektur:** X86, ARM, dan MIPS (untuk pengujian *cross-architecture*).
*   **Lingkungan:** Linux Server (Ubuntu 18.04) dengan CPU Intel(R) Xeon(R) Gold 5120 @ 2.20GHz, 128G RAM. IDA Pro digunakan sebagai alat *disassembly*.

### Baseline
1.  **Gemini** [Xu et al. 2017] (Metode Klasik GNN): Menggunakan GNN dan *Siamese network* untuk mempelajari representasi CFG.
2.  **Trex** [Pei et al. 2020] (*State-of-the-Art*): Metode deteksi biner *cross-architecture* yang mempelajari semantik dari *micro-traces* program menggunakan Transformer.

### Metrik Evaluasi
1.  **Precision (P):**
    $$Precision = \frac{TP}{TP + FP}$$
2.  **Recall (R):**
    $$Recall=\frac{TP}{TP+FN}$$
3.  **F1-score (F1):**
    $$F1=\frac{2 \times Precision \times Recall}{Precision + Recall}$$
4.  **Efisiensi Pencarian:** Waktu (Fungsi/Detik).

## 4. Hasil Eksperimen

### RQ4: Efektivitas HEBCS (Akurasi vs. Efisiensi)

**Tabel 2. Search efficiency of different methods.**

| Method | Time (Functions/Seconds) |
| :--- | :--- |
| Gemini | 69 |
| Trex | 734 |
| **HEBCS** | **3186** |

**Tabel 3. Evaluation metrics for different methods.**

| | X86 vs. ARM | | | ARM vs. MIPS | | | MIPS vs. X86 | |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| | P | R | F1 | P | R | F1 | P | R | F1 |
| Gemini | 0.912 | 0.972 | 0.941 | 0.910 | 0.958 | 0.933 | 0.912 | 0.950 | 0.931 |
| Trex | 0.943 | 0.957 | 0.950 | 0.950 | 0.967 | 0.958 | 0.943 | 0.947 | 0.952 |
| **HEBCS** | **0.928** | **0.949** | **0.938** | **0.939** | **0.936** | **0.958** | **0.947** | **0.945** | **0.945** |

*   **Efisiensi:** HEBCS jauh mengungguli *baseline* dengan kecepatan **3186 fungsi per detik**, sekitar **5 kali** Trex dan **50 kali** Gemini.
*   **Akurasi Lintas-Arsitektur:** HEBCS mencapai skor F1 yang sangat kompetitif (misalnya, 0.938 pada X86 vs. ARM), lebih baik daripada Gemini, dan sedikit di bawah Trex. Hal ini menunjukkan trade-off yang kuat antara efisiensi dan akurasi, di mana HEBCS memberikan efisiensi yang jauh lebih besar dengan sedikit pengorbanan akurasi.

### RQ2 & RQ3: Efektivitas Pelatihan Bobot dan Jarak Hamming

*   **Pelatihan Bobot (XGBoost):** Kurva F1-*score* setelah pelatihan bobot berada di atas kurva tanpa pelatihan, menunjukkan kemampuan diskriminatif yang lebih baik. Pelatihan bobot menghasilkan kurva *recall* yang lebih cepat stabil dan kurva *precision* yang lebih lambat menurun.
*   **Jarak Hamming Optimal:** Melalui eksperimen pada data berbobot, **Hamming Distance 58** memberikan F1-*score* tertinggi yaitu **0.964** (P = 0.943, R = 0.938).

### RQ5: Kinerja Dunia Nyata (Deteksi Kerentanan)

HEBCS berhasil mengidentifikasi adanya kerentanan yang diketahui (misalnya, CVE-2020-27867, CVE-2018-16333, CVE-2021-33514) dalam berbagai *firmware* (NETGEAR, Tenda) dengan akurasi yang menjanjikan, menunjukkan potensi signifikan untuk aplikasi praktis dalam analisis *firmware* skala besar.

## 5. Kesimpulan

HEBCS adalah metode pencarian kode biner berbasis *hash* yang sangat efisien. Dengan mengganti proses ekstraksi semantik yang kompleks dengan ekstraksi fitur *function-level* multidimensi yang *interpretable* dan mengadopsi representasi *Locality-Sensitive Hash* (LSH), HEBCS berhasil meminimalkan *overhead* komputasi. Integrasi **Prinsip Lubang Merpati** lebih lanjut mengoptimalkan penyimpanan dan kueri *hash* skala besar.

Meskipun terdapat sedikit celah dalam akurasi dan *recall* dibandingkan metode *state-of-the-art* berbasis *deep learning* yang kompleks, keunggulan signifikan HEBCS dalam efisiensi kueri (3186 F/S) menjadikannya solusi yang **sangat praktis dan *scalable*** untuk pencarian kode biner *cross-architecture* skala besar di dunia nyata.

::: info Dampak Praktis
HEBCS adalah solusi *go-to* untuk deteksi kerentanan cepat dan analisis perangkat lunak di korpus kode biner yang sangat besar. Mengingat efisiensinya yang luar biasa, HEBCS mengatasi hambatan utama yang dihadapi oleh metode berbasis ML yang lambat, memungkinkan analisis keamanan yang lebih cepat dan lebih luas. Peningkatan akurasi ke depan untuk kasus perubahan biner yang drastis akan semakin memperkuat posisinya.
:::