---
title: Review Paper - Survei Pencarian Kode Sumber- Perspektif 3-Dimensi
description: Rangkuman paper tentang survei teknik pencarian kode sumber dari perspektif 3-dimensi (ACM Transactions on Software Engineering and Methodology, 2024).
head:
  - - meta
    - name: keywords
      content: Source code search, deep learning, query-end optimization, code-end optimization, match-end optimization, survey
---

# 026 - A Survey of Source Code Search: A 3-dimensional Perspective
Tautan (DOI) [10.1145/3656341](https://doi.org/10.1145/3656341)

**Penulis:** **Weisong Sun** ¹², **Chunrong Fang** ¹*, **Yifei Ge** ¹, **Yuling Hu** ¹, **Yuchen Chen** ¹, **Quanjun Zhang** ¹, **Xiuting Ge** ¹, **Yang Liu** ², **Zhenyu Chen** ¹

**Afiliasi:**
* ¹ Software Institute, Nanjing University, Nanjing, China
* ² School of Computer Science and Engineering, Nanyang Technological University, Singapore, Singapore

**Kronologi:** Received: 12 November 2023 • Revised: 16 February 2024 • Accepted: 21 March 2024 • Publication Date: June 2024

<a href="https://www.scimagojr.com/journalsearch.php?q=18121&tip=sid" target="_blank"><img src="https://www.scimagojr.com/journal_img.php?id=18121" alt="SCImago Journal & Country Rank" /></a>

| Resume Eksekutif |
| :--- |
| **Publikasi:**<br>• **Jurnal:** ACM Transactions on Software Engineering and Methodology 33, 6 (2024), Article 166 (51 pages)<br>• **Topik:** Menyediakan survei sistematis mengenai teknik pencarian kode sumber (*source code search*) melalui perspektif 3-dimensi, berfokus pada optimasi komponen inti yang meningkatkan kinerja pencarian.<br><br>**Masalah & Solusi:**<br>• **Masalah:** Meskipun banyak teknik *code search* telah diusulkan, kurangnya tinjauan sistematis yang mengklasifikasikan dan menganalisis evolusi teknik berdasarkan komponen inti (*core components*) menghambat peneliti dalam mengidentifikasi tren teknologi dan tantangan spesifik untuk setiap komponen.<br>• **Solusi:** Mengusulkan **perspektif 3-dimensi** untuk mensurvei *code search*, mengkategorikan studi yang ada berdasarkan komponen spesifik yang mereka optimalkan: **1) Optimasi *Query-end***, **2) Optimasi *Code-end***, dan **3) Optimasi *Match-end***. Setiap 'end' diperlakukan sebagai dimensi independen.<br><br>**Contoh Penerapan:**<br>• **Analisis Evolusi Teknik:** Menganalisis bagaimana teknik *feature mining* (seperti *Query Expansion* dengan API atau Q&A) dan *feature representation* (dari IR ke DL/Transformer) telah berevolusi dalam setiap dimensi dari tahun 1960-an hingga 2023.<br><br>**Metodologi:**<br>• **Kerangka Kerja:** Semua teknik *code search* terdiri dari tiga komponen inti: *Query Understanding*, *Code Understanding*, dan *Query-Code Matching*.<br>• **Tinjauan Sistematis:** Melakukan *Systematic Literature Review* (SLR) terhadap $\mathbf{2,191}$ kandidat paper hingga September 2023, yang kemudian disaring menjadi $\mathbf{68}$ paper representatif untuk dianalisis secara mendalam.<br>• **3 Dimensi Optimasi:**<br>    1. **Query-end Optimization (Query Understanding):** Meliputi *feature mining* (Reduksi, Ekspansi, Transformasi) dan *feature representation* (IR-based, DL-based).<br>    2. **Code-end Optimization (Code Understanding):** Meliputi *feature mining* (Fitur Tekstual: *Method Name*, API Sequence, Tokens; Fitur Struktural: AST, DFG, CFG, PDG) dan *feature representation* (IR-based, DL-based).<br>    3. **Match-end Optimization (Query-Code Matching):** Meliputi *Text-based Matching*, *Vector Distance-based Matching* (Vector/Embedding Distance), dan *Classification-based Matching*.<br><br>**Temuan Kunci:**<br>• **Query-end:** *Query Expansion* adalah metode *feature mining* yang paling populer. *Feature representation* telah bergeser dari IR tradisional (TF-IDF, BOW) ke metode DL (*RNN, LSTM, Bi-LSTM, BERT, Transformer, Attention*) yang dominan saat ini.<br>• **Code-end:** Fitur **Tokens** dan **Method Name** adalah fitur tekstual yang paling umum, dan **AST** adalah fitur struktural yang paling sering digunakan. Representasi fitur telah bergeser ke model DL untuk menangani fitur struktural yang kompleks (*e.g.*, Tree-LSTM, GNNs/GGNN untuk CFG/DFG).<br>• **Match-end:** *Vector Distance-based Matching*, khususnya *Embedding Distance-based* (menggunakan *cosine similarity* pada *embedding* DL), adalah metode *matching* yang paling umum dan menjadi *mainstream*.<br><br>**Kontribusi Utama:**<br>• Mengusulkan perspektif 3-dimensi yang baru dan sistematis untuk mengklasifikasikan teknik *code search*.<br>• Melakukan tinjauan sistematis mendalam terhadap $\mathbf{68}$ paper representatif, menganalisis inovasi teknis dan evolusi pada setiap dimensi.<br>• Mengidentifikasi tantangan yang berkelanjutan (*e.g.*, *Query Ambiguity*, *Feature Redundancy*, *Efficiency*) dan peluang di masa depan (*e.g.*, aplikasi LLM) di ketiga dimensi.<br><br>**Dampak:**<br>• Membantu peneliti selanjutnya dalam mengidentifikasi tren teknologi, membandingkan *baseline* yang relevan, dan merancang optimasi yang ditargetkan untuk komponen spesifik dalam sistem *code search*, sehingga mempercepat riset di bidang *Software Engineering*. |

## 1. Pendahuluan & Masalah

Pencarian kode sumber (*source code search*) telah menjadi perhatian luas dalam *software engineering* karena potensinya untuk meningkatkan produktivitas dan kualitas pengembangan perangkat lunak melalui penggunaan kembali (*code reuse*). Tugas ini melibatkan pengambilan *snippet* kode yang relevan dari korpus kode skala besar (misalnya, GitHub) berdasarkan persyaratan fungsional, yang biasanya dijelaskan dalam kueri bahasa alami.

Seiring waktu, banyak teknik telah diusulkan untuk membuat pencarian kode menjadi efektif dan efisien. Secara fundamental, teknik-teknik ini berputar di sekitar optimasi tiga komponen inti:
1.  **Komponen Pemahaman Kueri (*Query Understanding Component*).**
2.  **Komponen Pemahaman Kode (*Code Understanding Component*).**
3.  **Komponen Pencocokan Kueri-Kode (*Query-Code Matching Component*).**

Meskipun terdapat banyak inovasi, kurangnya tinjauan sistematis yang menganalisis evolusi teknik berdasarkan tiga komponen inti ini menghambat peneliti dalam memahami tren teknologi dan tantangan spesifik pada setiap bagian.

::: tip Solusi yang Diusulkan
Paper ini mengusulkan **perspektif survei 3-dimensi** untuk menganalisis evolusi teknik *code search*. Studi dikategorikan berdasarkan komponen yang mereka optimalkan: **Optimasi *Query-end*** (Dimensi 1), **Optimasi *Code-end*** (Dimensi 2), dan **Optimasi *Match-end*** (Dimensi 3). Tinjauan sistematis terhadap 68 literatur relevan dilakukan untuk memberikan ringkasan komprehensif dari inovasi teknis di setiap dimensi.
:::

## 2. Metodologi

Kerangka kerja umum (*overall framework*) dari teknik pencarian kode terdiri dari tiga komponen utama yang masing-masing bertanggung jawab atas optimasi di dimensinya sendiri.

### A. Dimensi 1: Query-end Optimization (Query Understanding Component)

Optimasi ini bertujuan menghasilkan representasi kueri yang mempertahankan semantik inti dan memfasilitasi pencocokan. Ini dibagi menjadi dua langkah:

**1. Query Feature Mining:** Mengekstrak fitur penting dari kueri mentah.
*   **Query Reduction:** Menghilangkan konten berlebihan, bising, atau ambigu (misalnya, menghapus *stop words* atau istilah yang tidak relevan).
*   **Query Expansion:** Memperkaya kueri asli dengan informasi tambahan (misalnya, sinonim, API terkait, istilah dari Q&A Stack Overflow) untuk mengatasi masalah ketidakcocokan istilah (*term mismatch*).
*   **Query Transformation:** Mengubah kueri NL menjadi bentuk alternatif atau menambah kueri dengan bentuk tersebut (misalnya, mengubah kueri menjadi *text graph* atau *code description* yang diperkaya).

**2. Query Feature Representation:** Menghasilkan representasi fitur yang melestarikan semantik.
*   **IR-based Feature Representation:** Memperlakukan kueri sebagai teks biasa atau vektor (misalnya, menggunakan VSM, BOW, TF-IDF).
*   **DL-based Feature Representation:** Menerapkan jaringan saraf (*neural networks*) untuk menyandikan kueri menjadi *numerical vector representations* (*embeddings*) yang melestarikan semantik (*e.g.*, CNN, RNN, LSTM, BERT, *Attention Mechanism*).

### B. Dimensi 2: Code-end Optimization (Code Understanding Component)

Optimasi ini bertujuan menghasilkan representasi kode yang melestarikan semantik inti dan nyaman untuk perhitungan pencocokan. Ini juga dibagi menjadi dua langkah:

**1. Code Feature Mining:** Mengekstrak fitur penting dari *snippet* kode mentah.
*   **Fitur Tekstual:** *Method Name*, *API Sequence*, dan *Tokens* (nama variabel, konstanta, komentar).
*   **Fitur Struktural (Intermediate Representations):** *Abstract Syntax Tree* (**AST**), *Data Flow Graph* (**DFG**), *Control Flow Graph* (**CFG**), *Program Dependence Graph* (**PDG**), dan lainnya (misalnya, *Variable-based Flow Graph* - VFG).

**2. Code Feature Representation:** Menghasilkan representasi fitur kode.
*   **IR-based Feature Representation:** Memperlakukan kode sebagai teks, kadang-kadang dilengkapi dengan informasi tambahan (relasional, API, komentar).
*   **DL-based Feature Representation:** Menggunakan jaringan saraf yang kompleks untuk menyandikan fitur tekstual dan struktural menjadi *embeddings* terpadu (*e.g.*, RNN/LSTM untuk urutan, Tree-LSTM untuk AST, GGNN/RGCN untuk grafik).

### C. Dimensi 3: Match-end Optimization (Query-Code Matching Component)

Optimasi ini bertujuan untuk memberi peringkat *snippet* kode berdasarkan relevansinya dengan representasi kueri secara efisien dan benar. Tiga metode utama digunakan:

1.  **Text-based Matching:** Mengukur relevansi menggunakan fitur tekstual (frekuensi kata, *keywords*) berdasarkan model IR tradisional (*e.g.*, EBM, BM25, Lucene).
2.  **Vector-based Matching:**
    *   **Vector Distance-based:** Menghitung jarak (*e.g.*, *cosine similarity* atau *Euclidean distance*) antara vektor fitur berbasis IR.
    *   **Embedding Distance-based:** Menghitung jarak (*e.g.*, *cosine distance* atau *inner product*) antara *embeddings* yang dihasilkan oleh model DL.
3.  **Classification-based Matching:** Mengubah tugas pencocokan menjadi tugas klasifikasi. *Classifier* (misalnya, *Transformer Encoder-based Classifier*) memprediksi probabilitas kecocokan semantik antara kueri dan kode (*e.g.*, *recall and re-rank mechanism*).

## 3. Detail Pengujian

Sebagai survei, paper ini tidak menyajikan hasil eksperimen baru, tetapi menganalisis evolusi teknis berdasarkan tinjauan sistematis.

### Dataset / Korpus
Analisis ini didasarkan pada tinjauan sistematis terhadap $\mathbf{2,191}$ paper kandidat (termasuk *journal*, *conference*, dan ArXiv) yang dipublikasikan hingga September 2023. Setelah penyaringan ketat, $\mathbf{68}$ paper representatif dianalisis secara mendalam.

### Metrik
Meskipun metrik tidak diterapkan dalam survei ini, paper ini mencatat bahwa teknik-teknik yang disurvei bertujuan untuk meningkatkan:

*   **Efektivitas *Code Search*:** Diukur melalui metrik seperti *Mean Reciprocal Rank* (**MRR**), *Precision*, *Recall*, dll.
    $$ \text{MRR} = \frac{1}{|Q|} \sum_{i=1}^{|Q|} \frac{1}{\text{rank}_i} $$
    Di mana $|Q|$ adalah jumlah kueri, dan $\text{rank}_i$ adalah peringkat jawaban yang benar pertama untuk kueri $i$.
*   **Efisiensi *Code Search*:** Diukur melalui kecepatan *retrieval* dan komputasi (*overhead*).

### Definisi Formal Pencarian Kode
Paper ini menginvestigasi skenario *code search* utama di mana kueri ($q$) adalah teks bahasa alami dan hasilnya ($s$) adalah *snippet* kode tingkat metode/fungsi dari korpus ($S$).

$$ \text{Code Search}: \quad \text{Retrieve } s \in S \text{ for } q \text{ such that } \forall s' \in S, s' \neq s $$
$$ \text{where } \quad \text{sim}(\Phi(q), \Psi(s')) \le \text{sim}(\Phi(q), \Psi(s)) \quad \text{ or } \quad p(\Phi(q), \Psi(s')) \le p(\Phi(q), \Psi(s)) $$
Di mana $\Phi(\cdot)$ dan $\Psi(\cdot)$ adalah fungsi representasi fitur untuk kueri dan kode, $\text{sim}(\cdot)$ mengukur kesamaan, dan $p(\cdot)$ adalah fungsi prediksi probabilitas kecocokan semantik.

## 4. Hasil Eksperimen

Karena ini adalah survei, tidak ada "hasil eksperimen" dalam artian pengujian model baru. Sebaliknya, "temuan" disajikan dalam bentuk evolusi dan tren teknis.

### Tren Optimasi Query-end (RQ1)
*   **Feature Mining:** *Query Expansion* adalah yang paling banyak diusulkan (misalnya, menggunakan WordNet, API, Q&A, atau *Model Inference* dari DBN/Transformer) karena secara efektif melengkapi kueri yang pendek atau tidak jelas. *Query Transformation* (misalnya, mengubah kueri menjadi *text graph*) semakin populer.
*   **Feature Representation:** Terjadi pergeseran signifikan dari metode **IR-based** (misalnya, TF-IDF, VSM) ke metode **DL-based** (misalnya, RNN, LSTM, Bi-LSTM, CNN, BERT, T5) dan mekanisme *Attention* (Self-Attention, Co-Attention) untuk mencapai pemahaman semantik yang lebih dalam.

### Tren Optimasi Code-end (RQ2)
*   **Feature Mining:**
    *   **Tekstual:** *Method Name* dan *Tokens* adalah fitur yang paling sering digunakan, seringkali disandikan menggunakan RNN/LSTM/CNN.
    *   **Struktural:** **AST** adalah fitur struktural yang paling sering digunakan. Baru-baru ini, integrasi fitur struktural yang lebih kompak dan semantik seperti **DFG, CFG, PDG**, dan *Program Graph* (disandikan melalui **Tree-LSTM** atau **GNNs**) menjadi tren untuk mengurangi kompleksitas dan meningkatkan akurasi.
*   **Feature Representation:** **DL-based methods** (termasuk *Joint Embedding* untuk menyatukan ruang vektor kode dan kueri) adalah *mainstream* karena kemampuannya memproses fitur struktural dan tekstual secara komprehensif.

### Tren Optimasi Match-end (RQ3)
*   **Text-based Matching:** Populer di awal (misalnya, BM25, Lucene, EBM), sederhana dan efisien, tetapi kurang dalam pemahaman semantik.
*   **Vector Distance-based Matching:** Dominan saat ini.
    *   *Embedding Distance-based* (menggunakan *cosine distance* pada *embeddings* DL) menjadi **metode pencocokan *mainstream*** karena kemampuannya mencocokkan fitur semantik dan sintaksis yang diekstrak oleh DL.
    *   *Inner Product* dan *Euclidean Distance* (L2) juga digunakan.
*   **Classification-based Matching:** Mengubah *matching* menjadi klasifikasi probabilitas (misalnya, menggunakan *Transformer Encoder-based Classifier*). Ini menghasilkan presisi tinggi tetapi membutuhkan biaya komputasi yang mahal, sehingga sering digunakan pada tahap *re-ranking* (*slow classifier*) setelah *filtering* awal (*fast encoder*).

## 5. Kesimpulan

Survei ini memberikan tinjauan 3-dimensi yang komprehensif mengenai evolusi teknik *code search*, mengkategorikannya menjadi optimasi *Query-end*, *Code-end*, dan *Match-end*. Temuan utama menyoroti tren yang jelas: pergeseran dari metode tradisional berbasis IR dan tekstual ke pendekatan *deep learning* yang kompleks (seperti arsitektur *Transformer* dan *GNN*) di semua tiga dimensi untuk mencapai pemahaman semantik yang lebih dalam dari kueri dan kode.

Tantangan yang berkelanjutan meliputi akurasi *feature mining* (*e.g.*, mengidentifikasi istilah bising tanpa kehilangan semantik), integrasi *multi-feature* (*e.g.*, mengatasi redundansi antara *tokens* dan AST), dan efisiensi *matching* pada korpus skala besar.

::: info Dampak Praktis
Riset *code search* di masa depan harus berfokus pada solusi tantangan yang diidentifikasi, seperti mengintegrasikan *Large Language Models* (**LLMs**) untuk *feature mining* dan *representation* yang lebih akurat, yang memanfaatkan kemampuan pemahaman bahasa NL dan PL LLM yang superior. Survei ini berfungsi sebagai peta jalan penting, memandu peneliti untuk merancang inovasi yang ditargetkan pada komponen inti (tiga dimensi) sistem *code search*, yang pada akhirnya akan menghasilkan alat yang lebih efektif dan efisien.
:::