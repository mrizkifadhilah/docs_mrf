---
title: Review Paper - Seleksi Pertanyaan untuk Sintesis Code Search Multimodal Menggunakan Probabilistic Version Spaces
description: Rangkuman paper tentang Seleksi Pertanyaan untuk Sintesis Code Search Multimodal Menggunakan Probabilistic Version Spaces (IEEE Transactions on Software Engineering, 2025).
head:
  - - meta
    - name: keywords
      content: Program synthesis, question selection problem, large language model, probabilistic version spaces, multimodal code search
---

# 013 - Question Selection for Multimodal Code Search Synthesis Using Probabilistic Version Spaces
[https://doi.org/10.1109/TSE.2025.3565387]

**Penulis:** **Jiarong Wu** ᵃ, **Yanyan Jiang** ᵇ*, **Lili Wei** ᶜ, **Congying Xu** ᵃ, **Shing-Chi Cheung** ᵃ, **Chang Xu** ᵇ

**Afiliasi:**
* ᵃ Department of Computer Science and Engineering, The Hong Kong University of Science and Technology, Hong Kong 999077, China
* ᵇ State Key Laboratory for Novel Software Technology, and also with the Department of Computer Science and Technology, Nanjing University, Nanjing 210023, China
* ᶜ Department of Electrical and Computer Engineering, McGill University, Montreal, QC H3A 0G4, Canada

**Kronologi:** Received: 29 April 2024 • Revised: 9 April 2025 • Accepted: 20 April 2025 • Available Online: 29 April 2025

<a href="https://www.scimagojr.com/journalsearch.php?q=18711&tip=sid" target="_blank"><img src="https://www.scimagojr.com/journal_img.php?id=18711" alt="SCImago Journal & Country Rank" /></a>

| Resume Eksekutif |
| :--- |
| **Publikasi:**<br>• **Jurnal:** IEEE Transactions on Software Engineering, Vol 51, No. 6, Juni 2025<br>• **Topik:** Peningkatan efisiensi interaksi dalam Sintesis Program melalui Contoh (*PBE*) untuk *Code Search* menggunakan model probabilitas berbasis LLM.<br><br>**Masalah & Solusi:**<br>• **Masalah:** Alat *Programming by Example* (*PBE*) sebelumnya untuk *Code Search* (*misalnya, ALICE, SPORQ*) hanya mensintesis program yang memenuhi contoh *input-output* yang diberikan. Hal ini sering menghasilkan program yang *overfitting* dan tidak selalu selaras dengan **niat pengguna (*user intent*)** yang sebenarnya. Untuk mengatasi *overfitting*, digunakan sintesis interaktif *Question-Answer* (*QA*), namun **seleksi pertanyaan** yang efisien menjadi tantangan karena jumlah kandidat program yang sangat besar.<br>• **Solusi:** Mengusulkan **EXCALIBUR**, sebuah *synthesizer* interaktif **multi-modal** (*contoh I/O dan deskripsi NL*). EXCALIBUR menjamin *soundness* dan *bounded-completeness*. Untuk meminimalkan upaya interaksi, diperkenalkan **Probabilistic Version Spaces (ProbVS)**. ProbVS menggabungkan *Version Spaces* tradisional (*representasi ringkas dari program kandidat*) dengan **Large Language Models (LLMs)** yang dipicu oleh deskripsi NL, untuk menyesuaikan probabilitas program agar selaras dengan niat pengguna. ProbVS mengarahkan strategi *minimax-branch* untuk seleksi pertanyaan yang optimal.<br><br>**Contoh Penerapan:**<br>• **Sintesis Program Pencarian Pola Kode Java:** EXCALIBUR diimplementasikan untuk sintesis program pencarian pola kode dalam dialek *ExPath* (DSL turunan XPath) untuk Java. Contoh tugas: "Temukan panggilan *toString* dan *hashCode* pada objek tipe *array*."<br>• **Hasil Terbaik:** Menggunakan ProbVS dengan GPT4o, interaksi rata-rata dikurangi dari 4.5 putaran (tanpa ProbVS) menjadi **3.68 putaran**, mengurangi upaya interaksi hingga 18.22%.<br><br>**Metodologi:**<br>• **Sintesis (Encoding Phase):** Menggunakan *Version Spaces* (VS) untuk secara ringkas merepresentasikan *semua* program kandidat yang konsisten dengan contoh I/O dalam batas anggaran pencarian (*search budget*).<br>• **ProbVS (Estimation Phase):** LLM (misalnya, GPT4o) digunakan untuk mengklasifikasikan apakah fragmen kode yang dikunjungi (*Visited Code Fragments/VCF*) selama eksekusi program kandidat relevan dengan deskripsi NL. Probabilitas ini dipropagasikan melalui VS untuk menghitung $\mathbb{P}(P\mid\Phi)$, probabilitas setiap program $P$ selaras dengan niat pengguna.<br>• **Interaksi (Disambiguation Phase):** Menggunakan strategi seleksi pertanyaan **minimax-branch** untuk memilih klaster pertanyaan $Q$ yang meminimalkan probabilitas cabang terburuk (*max-branch probability*), dengan probabilitas yang diberikan oleh ProbVS.<br><br>**Temuan Kunci:**<br>1. **Efektivitas PBE Interaktif:** EXCALIBUR (tanpa ProbVS) berhasil menyelesaikan semua 44 tugas dengan rata-rata 4.5 putaran interaksi, jauh lebih cepat dan lebih andal daripada replikasi SPORQ (maks. 26 tugas terpecahkan).<br>2. **Peningkatan Kinerja ProbVS:** ProbVS dengan LLM canggih (GPT4o) mengurangi rata-rata interaksi hingga 0.82 putaran (18.22%) dibandingkan dengan strategi seleksi pertanyaan SOTA tanpa ProbVS.<br>3. **Korelasi LLM-Kinerja:** Tingkat perbaikan dalam reduksi putaran sangat berkorelasi positif dengan kemampuan estimasi LLM yang mendasarinya (misalnya, GPT4o > QwenCoder > OpenCoder).<br><br>**Kontribusi Utama:**<br>• Mengusulkan EXCALIBUR, *synthesizer* multi-modal (*bounded-complete*) dengan disambiguasi berbasis QA untuk *code search*.<br>• Memperkenalkan **ProbVS**, metodologi baru yang menggabungkan LLM dan *Version Spaces* untuk probabilitas program yang selaras dengan niat pengguna, meningkatkan seleksi pertanyaan.<br>• Evaluasi ekstensif yang menunjukkan efektivitas ProbVS dalam mengurangi upaya interaksi.<br><br>**Dampak:**<br>• **Reduksi Upaya Pengguna:** Secara signifikan mengurangi jumlah interaksi yang dibutuhkan untuk *PBE* dalam *code search*, menjadikan sintesis interaktif lebih praktis dan *user-friendly*.<br>• **Peningkatan Keandalan:** Menyediakan *synthesizer* yang *sound* dan *bounded-complete*, mengatasi masalah *overfitting* yang melekat pada alat *PBE* sebelumnya. |

## 1. Pendahuluan & Masalah

*Code search* atau *linting* adalah tugas umum dalam rekayasa perangkat lunak yang bertujuan untuk mendeteksi kemunculan pola kode spesifik (misalnya, *code smells*, *bugs*, atau isu keamanan). Meskipun alat yang ada seperti CODEQL atau Semgrep sukses, banyak pola bersifat spesifik aplikasi dan tidak didukung secara langsung.

Teknik *Programming by Example* (PBE) telah diterapkan untuk mengatasi hal ini (misalnya, ALICE, SPORQ). Dalam PBE, pengguna menyediakan contoh *input-output* (fragmen kode yang cocok dengan pola target) untuk mensintesis program pencarian. Namun, masalah fundamentalnya adalah:
1.  **Overfitting:** Program yang disintesis mungkin konsisten dengan contoh I/O tetapi menyimpang dari **niat pengguna** (*user intent*) yang sebenarnya (misalnya, sebuah program mencocokkan panggilan metode tanpa argumen secara kebetulan, padahal niatnya adalah mencari panggilan *toString* pada *array*).
2.  **Kurangnya Jaminan:** Tidak ada jaminan bahwa prosedur sintesis akan menemukan program target.

Sintesis Interaktif berbasis *Question-Answer* (*QA*) menjanjikan solusi untuk masalah *overfitting* dengan secara iteratif menanyakan pertanyaan kepada pengguna untuk membedakan program target dari kandidat lain. Namun, tantangan utamanya adalah **Seleksi Pertanyaan** yang efisien, karena jumlah program kandidat bisa mencapai ratusan ribu, yang memerlukan putaran interaksi yang sangat banyak. Solusi SOTA bergantung pada *SMT solver*, yang tidak efisien untuk kode bahasa pemrograman tujuan umum seperti Java.

::: tip Solusi yang Diusulkan
Kami mengusulkan **EXCALIBUR**, *synthesizer* *code search* **multi-modal** (*contoh I/O dan deskripsi Bahasa Alami/NL*), yang menjamin *soundness* dan *bounded-completeness*. Untuk meningkatkan efisiensi interaksi QA, kami memperkenalkan **Probabilistic Version Spaces (ProbVS)**. ProbVS menggunakan **Large Language Models (LLMs)** untuk menyesuaikan probabilitas program kandidat berdasarkan deskripsi NL pengguna, memberikan **distribusi probabilitas yang lebih selaras dengan pengguna** yang memandu strategi seleksi pertanyaan (*minimax-branch*) untuk mengurangi putaran interaksi yang diharapkan.
:::

## 2. Metodologi

EXCALIBUR beroperasi dalam tiga fase: *Encoding*, *Estimation* (ProbVS), dan *Disambiguation*.

### A. Encoding Phase: Representasi Program Konsisten

*   **Spesifikasi Multi-Modal:** Input terdiri dari $\Phi=\langle\Phi_{\epsilon},\Phi_{\mathcal{N}}\rangle$, di mana $\Phi_{\epsilon}$ adalah contoh *input-output* pada *code snippet*, dan $\Phi_{\mathcal{N}}$ adalah deskripsi NL niat pengguna.
*   **Bahasa ExPath:** Program pencarian kode disintesis dalam *Domain-Specific Language* (DSL) yang disederhanakan turunan XPath, disebut **ExPath**. Program ExPath dapat berupa *Path Programs* ($e_1 / e_2 / ...$) atau *Set Programs* (menggunakan operator *Conjunct*, *Disjunct*, *Diff*).
*   **Version Spaces (VS):** Semua program yang konsisten dengan contoh (*consistent programs*) dalam batas anggaran pencarian dienkode secara ringkas dalam struktur VS, yang direpresentasikan sebagai *graph* dengan *EXSTATE* (himpunan fragmen kode yang cocok) sebagai *vertex* dan *path expressions* atau *set operators* sebagai *edge*. VS menjamin *soundness* dan *bounded-completeness*.

### B. Estimation Phase: Probabilistic Version Spaces (ProbVS)

ProbVS bertujuan untuk menetapkan probabilitas $\mathbb{P}(P\mid\Phi)$ untuk setiap program kandidat $P$, di mana program yang lebih selaras dengan deskripsi NL ($\Phi_{\mathcal{N}}$) memiliki probabilitas lebih tinggi.

1.  **Fitur VCF:** Fragmen kode yang **dikunjungi (*Visited Code Fragments/VCF*)** selama eksekusi program kandidat bertindak sebagai fitur biner ($\vec{\omega}$) program.
2.  **Estimasi LLM:** LLM (misalnya, GPT4o) diminta dengan pertanyaan klasifikasi biner untuk memperkirakan probabilitas ($\mathbb{P}(\omega_i\mid\Phi)$) apakah fragmen kode $\omega_i$ terkait dengan deskripsi NL.
3.  **Propagasi Probabilitas:** Dengan asumsi independensi fitur, probabilitas VCF ini dipropagasikan melalui *Version Space* untuk menghitung probabilitas program. Probabilitas program diuraikan sebagai:

$$\mathbb{P}(P|\Phi)=\mathbb{P}(\vec{\omega}|\Phi)\cdot\mathbb{P}(P|\vec{\omega},\Phi)$$
Di mana $\mathbb{P}(\vec{\omega}|\Phi) = \prod_{i}\mathbb{P}(\omega_i|\Phi)$. $\mathbb{P}(P\mid\vec{\omega},\Phi)$ dimodelkan menggunakan fungsi penilaian heuristik $s(P)$ yang memprioritaskan program dengan ekspresi *path* dan *set operator* yang lebih sedikit (kompleksitas sintaksis lebih rendah).

### C. Disambiguation Phase: Sintesis Interaktif QA

*   **Ruang Pertanyaan:** EXCALIBUR menghindari *SMT solver* dengan mengajukan pertanyaan berdasarkan perilaku *runtime* program (apakah fragmen kode tertentu *exactly nested in* atau *nested in* hasil perantara selama evaluasi program).
*   **Seleksi Pertanyaan:** Strategi **minimax-branch** (pendekatan *beam-search* aproksimasi) digunakan untuk memilih klaster pertanyaan $Q$ berukuran $k$ yang meminimalkan probabilitas cabang terburuk:

$$Q^* = \underset{Q}{\operatorname{argmin}} \max_{\alpha} \mathbb{P}(\alpha)$$

Di mana $\mathbb{P}(\alpha)$ adalah probabilitas cabang (*branch*) yang berisi program yang konsisten dengan jawaban $\alpha$. Probabilitas program yang lebih selaras dengan pengguna (dari ProbVS) akan mengarahkan strategi untuk menemukan pertanyaan yang menempatkan program target dalam cabang dengan program lain yang lebih sedikit, sehingga mempercepat disambiguasi.

## 3. Detail Pengujian

### Dataset
Benchmark terdiri dari **44 tugas *code search* Java** yang dikumpulkan dari kode Spoon di GitHub (36 tugas) dan diadaptasi dari SPORQ (8 tugas). Tugas dikelompokkan berdasarkan panjang jalur (*PathLen*) dan jumlah operator himpunan (*#SetOp*), dengan keragaman yang wajar pada operasi semantik dan pola *wildcard*.

### Baseline
1.  **SPORQ (Replikasi):** Replika GENSYNTH, mesin sintesis Datalog, diadaptasi untuk Java (menggunakan skema CODEQL Java) dan dioptimalkan untuk mensimulasikan SPORQ. *SPORQ (min)* membatasi relasi *Datalog* input ke yang digunakan oleh program *ground truth* (batas atas artifisial).
2.  **APRIORI:** Probabilitas program hanya didasarkan pada skor heuristik sintaksis ($s(P)$), tanpa menggunakan LLM (baseline tradisional).
3.  **RANDOM:** Probabilitas seragam untuk semua program (baseline nol).
4.  **OPTIMAL:** ProbVS dengan estimasi LLM yang sempurna dari *ground truth* (batas atas teoritis ProbVS).

### Metrik Evaluasi
*   **Success rate:** Jumlah tugas yang terpecahkan dalam batas waktu (10 menit).
*   **Number of interaction rounds:** Jumlah putaran QA yang diperlukan.
*   **Response time:** Waktu yang diperlukan untuk memproses input dan menghasilkan pertanyaan berikutnya.
*   **Precision (Top 1):** Persentase program top-1 yang disintesis yang memiliki hasil eksekusi yang sama dengan program *ground truth*.
*   **Entropy:** Mengukur ketidakpastian distribusi probabilitas VCF.
*   **Target Probability:** Probabilitas VCF program target.

## 4. Hasil Eksperimen

### RQ1: Efektivitas EXCALIBUR vs SPORQ
| Synthesizer | #Success | Avg #Rounds | Avg Response Time (s) | Precision (Top 1) |
| :--- | :--- | :--- | :--- | :--- |
| **EXCALIBUR (APRIORI)** | **44 (100%)** | **4.50** | **1.09** | 30 (68.18%) |
| SPORQ (min)$^3$ | 26 (59.09%) | 3.77 | 29.68 | 22 (84.62%) |

**Analisis:** EXCALIBUR menyelesaikan **semua tugas (100%)** dalam batas waktu dan memiliki waktu respons rata-rata yang jauh lebih cepat (1.09s) daripada SPORQ (min) (29.68s), menunjukkan kecepatan eksekusi dan efektivitas yang unggul. Sementara *precision* top-1 EXCALIBUR lebih rendah (68.18%), EXCALIBUR memberikan **daftar program berperingkat** (memastikan *bounded-completeness*) yang lebih toleran terhadap kesalahan daripada hanya mengembalikan satu program (*overfitting*).

### RQ2: Efektivitas ProbVS dalam Seleksi Pertanyaan
| Setting | Avg Rounds | Reduksi Putaran (vs APRIORI) |
| :--- | :--- | :--- |
| **OPTIMAL (Upper Bound)** | **2.64** | **1.86** |
| APRIORI / RANDOM (Baseline) | $\sim 4.5$ | - |
| **GPT4o** | **3.68 - 3.84** | **0.64 - 0.82 (14.26% - 17.86%)** |
| QwenCoder | $4.25 - 4.39$ | $0.11 - 0.25$ |
| OpenCoder | $4.64 - 5.02$ | Peningkatan $0.16 - 0.54$ |

**Analisis:** ProbVS dengan LLM berkapasitas tinggi (**GPT4o**) secara signifikan **mengurangi rata-rata putaran interaksi hingga 18.22%**, dibandingkan dengan baseline (APRIORI). Kinerja ini berkorelasi positif dengan kemampuan estimasi LLM; model yang lebih akurat (GPT4o) menghasilkan putaran yang lebih sedikit. Hasil OPTIMAL (2.64 putaran) menunjukkan potensi besar ProbVS di masa depan dengan kemajuan LLM yang lebih baik.

### RQ3: Bagaimana ProbVS Memengaruhi Distribusi Probabilitas
1.  **Entropi:** Entropi rata-rata distribusi VCF untuk semua LLM (GPT4o, QwenCoder, OpenCoder) **lebih kecil** daripada baseline (APRIORI/RANDOM). Ini menunjukkan bahwa ProbVS berhasil menciptakan distribusi probabilitas yang **lebih pasti/tidak acak** dengan memprioritaskan VCF yang selaras dengan NL.
2.  **Probabilitas Target:** Analisis *chi-square test* menunjukkan asosiasi signifikan antara peningkatan probabilitas target (*prop*>1) dan reduksi putaran (*diff*<0). Jika model memiliki estimasi yang lebih baik (*prop*>1), jumlah putaran cenderung berkurang.

## 5. Kesimpulan

Paper ini berhasil memperkenalkan **EXCALIBUR**, *synthesizer* *code search* interaktif **multi-modal** yang menjamin *soundness* dan *bounded-completeness*, mengatasi keterbatasan *overfitting* yang ada pada alat PBE sebelumnya. Kontribusi utamanya, **Probabilistic Version Spaces (ProbVS)**, secara efektif memanfaatkan deskripsi NL pengguna dan kemampuan klasifikasi LLM untuk menghasilkan distribusi probabilitas program yang selaras dengan niat pengguna. Hasil evaluasi pada 44 tugas Java menunjukkan bahwa EXCALIBUR (100% tingkat keberhasilan) dan ProbVS (hingga 18.22% pengurangan putaran interaksi dengan GPT4o) sangat efektif.

::: info Dampak Praktis
ProbVS secara substansial **mempercepat sintesis program interaktif** dengan mengurangi upaya interaksi yang diperlukan dari pengguna. Dengan jaminan *bounded-completeness*, EXCALIBUR menawarkan solusi *code search* yang jauh lebih andal dan praktis, terutama dalam tugas-tugas yang memerlukan pola kode spesifik aplikasi.
:::

---

Would you like me to elaborate on the **ExPath** language or the **minimax-branch** question selection strategy?