---
title: Review Paper - Analisis, Rekomendasi, dan Retrieval Code Klien API RESTful
description: Rangkuman paper tentang API Prober untuk API Analysis, Recommendation, dan Client Code Retrieval berdasarkan OAS (Electronics, 2023).
head:
  - - meta
    - name: keywords
      content: OpenAPI Specification, Latent Dirichlet Allocation, cluster analysis, service recommendation, code example, GitHub
---

# 059 - RESTful API Analysis, Recommendation, and Client Code Retrieval
Tautan (DOI) [https://doi.org/10.3390/electronics12051252]

**Penulis:** **Shang-Pin Ma** $^{1*}$, **Ming-Jen Hsu** $^{1}$, **Hsiao-Jung Chen** $^{1}$, **Chuan-Jie Lin** $^{1}$

**Afiliasi:**
* $^{1}$ Department of Computer Science and Engineering, National Taiwan Ocean University, Keelung 202301, Taiwan

**Kronologi:** Received: 10 January 2023 • Revised: 24 February 2023 • Accepted: 2 March 2023 • Available Online: 5 March 2023

<a href="https://www.scimagojr.com/journalsearch.php?q=21100829272&tip=sid" target="_blank"><img src="https://www.scimagojr.com/journal_img.php?id=21100829272" alt="SCImago Journal & Country Rank" /></a>

| Resume Eksekutif |
| :--- |
| **Publikasi:**<br>• **Jurnal:** Electronics 12, 5 (March 2023)<br>• **Topik:** Pengembangan sistem **API Prober** untuk analisis, pengelompokan, rekomendasi, dan pengambilan kode klien API RESTful berdasarkan **OpenAPI Specification (OAS)** untuk mencapai prinsip **FAIR** (Findability, Accessibility, Interoperability, Reusability).<br><br>**Masalah & Solusi:**<br>• **Masalah:** Direktori API yang ada (seperti ProgrammableWeb, Rapid API Hub) hanya menyediakan informasi dasar dan kategorisasi, tanpa dukungan memadai untuk mencari layanan relevan, merekomendasikan layanan pengganti/gabungan, atau memberikan contoh kode penggunaan yang relevan.<br>• **Solusi:** Mengembangkan **API Prober**, sebuah sistem inspeksi API berbasis OAS. Sistem ini menggunakan pemrosesan semantik (LDA & WordNet) dan analisis graf untuk menganotasi, mengelompokkan (clustering), merekomendasikan API, dan mengambil (*retrieve*) contoh kode klien (Java) dari GitHub menggunakan **Abstract Syntax Tree (AST)** dan aturan pencocokan yang ketat.<br><br>**Contoh Penerapan:**<br>• Diterapkan pada **1439 Web API** (termasuk $24.819$ *endpoint*) yang dikumpulkan dari APIs.guru.<br>• Menganalisis fitur desain RESTful service (misalnya, dukungan HTTPS, kode status HTTP, format JSON).<br>• Merekomendasikan layanan *substitutable* (pengganti) dan *mergeable* (gabungan) berdasarkan kesamaan parameter I/O di dalam klaster yang teridentifikasi.<br><br>**Metodologi:**<br>• **Findability/Accessibility:** Transformasi OAS ke struktur **Graf Neo4j** (node: resource, path, operation, parameter, status code, response). Anotasi semantik menggunakan **LDA** (untuk mengekstrak kata topik) dan **WordNet** (untuk ekspansi istilah). Pencarian utama dilakukan menggunakan **Document Concept Score (DCS)**.<br>• **Interoperability:** Pengelompokan (clustering) API menggunakan **Average Linkage** berdasarkan skor DCS. Rekomendasi layanan (*substitutable* dan *mergeable*) berdasarkan **Parameter Concept Scores (PCS)** dan **Hungarian Mapping Scores (HMS)** untuk kecocokan antarmuka I/O.<br>• **Reusability:** Pengambilan kode klien Java dari GitHub menggunakan **GitHub Search API**. Kode yang diambil difilter dan diekstraksi menggunakan **Java Method Parser (JMP)** yang menganalisis **AST** (Abstract Syntax Tree) untuk memastikan cuplikan kode benar-benar memanggil *service path* target (diberi skor S5 untuk kode klien terbaik).<br><br>**Temuan Kunci:**<br>1. **Clustering Valid:** Pendekatan *clustering* hibrida (Average Linkage + Semantik) menghasilkan klaster API yang semantik dan kohesif (misalnya, klaster *Application Performance Management*), tanpa memerlukan data *mashups* atau *invocation*.<br>2. **Rekomendasi Akurat:** Presisi Top-K Rekomendasi Layanan (*Substitutable* dan *Mergeable*) rata-rata melebihi **0.77** (misalnya, Top-1 mencapai 100%), menunjukkan kemampuan tinggi dalam mengidentifikasi layanan pengganti atau komposit yang sesuai.\\3. **Retrieval Kode Presisi Tinggi:** Presisi Contoh (EP) Top-3 Retrieval Kode Klien dari GitHub menggunakan API Prober melebihi **0.87**, secara signifikan mengungguli *GitHub Search API* dasar (sekitar 0.26-0.31).\\<br>**Kontribusi Utama:**<br>• Menyajikan API Prober, sebuah sistem komprehensif yang menerapkan prinsip **FAIR** pada Web API.<br>• Mengusulkan metode hibrida berbasis OAS dan analisis graf untuk analisis semantik dan *clustering* Web API.<br>• Mengembangkan skema rekomendasi layanan berbasis antarmuka I/O (PCS & HMS) di dalam klaster.<br>• Merancang metode *retrieval* kode klien Java berbasis AST yang efektif dari GitHub.<br><br>**Dampak:**<br>• Meningkatkan kegunaan dan reusabilitas Web API secara signifikan dengan memberikan informasi semantik mendalam, rekomendasi kontekstual, dan contoh kode yang terverifikasi, membantu pengembang dalam implementasi aplikasi modern. |

## 1. Pendahuluan & Masalah

Semakin banyak perusahaan, termasuk raksasa teknologi, mendorong penciptaan sistem perangkat lunak inovatif menggunakan **Web API**, terutama melalui arsitektur **REST (Representational State Transfer)**. Dengan lebih dari $20.000$ layanan REST yang diterbitkan (misalnya, di ProgrammableWeb), kompleksitas dan jumlah API yang besar menjadi kendala besar bagi pengguna. Meskipun direktori API seperti Rapid API Hub dan APIs.guru telah didirikan, mereka umumnya hanya menyediakan informasi dasar atau kategori populer. Mereka **tidak memberikan dukungan yang memadai** untuk:

1.  Menemukan layanan yang relevan atau serupa (Findability/Accessibility).
2.  Merekomendasikan layanan alternatif untuk substitusi atau komposisi (Interoperability).
3.  Menyediakan contoh kode penggunaan yang representatif (Reusability).

Keterbatasan ini menghambat adopsi dan pemanfaatan API secara efektif.

::: tip Solusi yang Diusulkan
Kami mengusulkan **API Prober**, sebuah sistem inspeksi API baru yang menyediakan layanan direktori API dengan berbagai fungsionalitas tambahan untuk mewujudkan prinsip **FAIR** (Findability, Accessibility, Interoperability, dan Reusability) pada Web API, terutama berbasis **OpenAPI Specification (OAS)**. API Prober mengubah OAS menjadi struktur graf, menganotasi konsep semantik menggunakan **LDA** dan **WordNet**, mengelompokkan API, merekomendasikan layanan pengganti/gabungan, dan mengambil contoh kode klien Java dari GitHub menggunakan **AST (Abstract Syntax Tree)**.
:::

## 2. Metodologi

Arsitektur API Prober dibagi menjadi dua blok utama: **Analyzer** (untuk pengumpulan dan analisis data) dan **Runtime** (untuk antarmuka pengguna).

### A. Transformasi OAS ke Node dan Anotasi Semantik

OAS dokumen dianalisis dan diubah menjadi struktur **Graf Neo4j** (Graph DB). Enam jenis *node* utama disimpan: *resource, path, operation, parameter, status codes,* dan *response*. Hubungan ditetapkan di antara *node-node* ini (misalnya, *resource* terhubung ke *path*).

1.  **Tokenization and Stemming:** Teks OAS diolah.
2.  **LDA (Latent Dirichlet Allocation):** Digunakan untuk mengekstrak kata topik dari dokumen OAS.
3.  **WordNet Extension:** Kata topik diperluas dengan istilah tambahan yang memiliki kemiripan semantik tinggi (kemiripan $> 0.9$ menggunakan *Edge Counting Method*).
4.  **Fitur Desain REST:** Sembilan fitur desain umum layanan RESTful (misalnya, dukungan HTTPS, gaya URI REST, penggunaan kode status HTTP) juga diidentifikasi dan disimpan untuk membantu penyaringan layanan.

**Document Concept Score (DCS):** Digunakan sebagai mekanisme kueri utama dan dasar *clustering*. DCS mengukur kesamaan antara OAS target ($T$) dan OAS kandidat ($C$) berdasarkan *resource* dan *operation*, dengan memperhitungkan bobot ekspansi WordNet ($W_{WN}$):
$$DCS=W_{RS} \cdot sim^{RS}(T,C)+W_{OP} \cdot sim^{OP}(T,C)$$

### B. Pengelompokan dan Rekomendasi API

1.  **Pengelompokan (Clustering) API:** Menggunakan metode **Average Linkage** (dipilih berdasarkan skor *Adjusted Rand Index* (ARI) tertinggi) untuk mengelompokkan OAS dokumen menjadi beberapa klaster berdasarkan skor DCS.
2.  **Rekomendasi API:** Layanan yang direkomendasikan harus berada dalam klaster yang sama dengan layanan target. Rekomendasi dibagi menjadi:
    *   **Substitutable Services:** Memiliki parameter *input* dan *output* yang sangat mirip.
    *   **Mergeable Services:** Layanan komposisi horizontal, dibagi menjadi *Input-oriented* (input serupa) dan *Output-oriented* (output serupa).

Metode penilaian untuk rekomendasi meliputi:

*   **Parameter Concept Scores (PCS):** Mengukur kesamaan antara dua parameter berdasarkan VSM, termasuk vektor konsep asli dan ekspansi WordNet.
    $$PCS(PC_{t},PC_{s})=\frac{V_{toc}\cdot V_{soc}+V_{toc}\cdot V_{swc}}{||V_{oc1}||\cdot||V_{oc2}||}$$
*   **Hungarian Mapping Scores (HMS):** Mengukur tingkat kecocokan antarmuka I/O antara dua layanan menggunakan *Hungarian algorithm* untuk menentukan pasangan parameter optimal. $HMS_{input}$ dan $HMS_{output}$ dihitung.
*   **Service Recommendation Score (SRS):** Digunakan untuk layanan *substitutable*.
    $$SRS(TS, CS) = \frac{HMS_{input}(TS, CS) + HMS_{output}(TS, CS)}{2}$$

Prosedur rekomendasi menggunakan *threshold* $t1$ dan $t2$ pada $HMS_{input}$ dan $HMS_{output}$ untuk membedakan antara layanan *substitutable* dan *mergeable*.

### C. Discovery Contoh Kode Klien Layanan

Modul **API Usage Explorer (AUE)** mengambil contoh kode yang berpotensi relevan dari GitHub menggunakan *GitHub Search API*, dengan *service path* target sebagai kueri.

1.  **Penyaringan Awal:** Hasil pencarian GitHub (100 teratas) disaring. Hanya file kode yang *text\_matches* (fragmen yang cocok) mengandung semua token dalam *service path* target yang dipertahankan.
2.  **Java Method Parser (JMP):** Modul ini melakukan analisis struktural pada file Java yang diambil dengan memeriksa **Abstract Syntax Tree (AST)** yang dihasilkan oleh *Java Parser*. JMP mengekstrak 7 bagian AST (misalnya, *Import, Class, Method body*).
3.  **Pencocokan *Service Path* yang Ditingkatkan:** JMP menggunakan 4 sub-metode untuk meningkatkan presisi, termasuk menangani *superset/subset* path dan pemisahan kueri URI opsional.
4.  **Mekanisme Penilaian:** Kode diekstraksi berdasarkan bagaimana *service path* digunakan (misalnya, sebagai variabel, dalam metode, atau dalam *return statement*). Skor S1-S5 diberikan. Skor tertinggi (**S5**) diberikan kepada kode yang menggunakan *service path* dalam variabel/metode dan mengimpor pustaka HTTP umum (misalnya, *Apache Httpclient, okhttp3*), yang menandakan kemungkinan besar itu adalah kode klien API yang valid.

## 3. Detail Pengujian

### Dataset
*   **Corpus:** 1439 Web API (24.819 *endpoint*) dari APIs.guru.
*   **Clustering:** Menggunakan 1439 Web API.
*   **Retrieval Code:** 100 *service path* target dipilih secara acak untuk evaluasi.

### Metrik Evaluasi

1.  **Adjusted Rand Index (ARI):** Metrik eksternal untuk menilai kesesuaian hasil *clustering* dengan hasil yang diharapkan.
2.  **Top-K Precision (SRP):** Digunakan untuk mengevaluasi akurasi rekomendasi layanan. $k \in \{1, 2, 3\}$.
    $$SRP^{k}(TS)=\frac{|\{RS^{k}_{relevant}\}|}{k}$$
    Di mana $RS^{k}_{relevant}$ adalah jumlah layanan yang memuaskan di antara Top-K.
3.  **Code Search Precision (CSP) dan Example Precision (EP):** Digunakan untuk mengevaluasi akurasi *retrieval* kode klien. $E_{i}$ adalah *service path* target.
    $$CSP(E_{i}) = \frac{CSP^{k}_{relevant}}{CSP^{k}}$$
    $$EP^{k}(n)=\frac{\sum_{i=1}^{n}CSP^{k}(E_{i})}{n}$$
    Di mana $CSP^{k}_{relevant}$ adalah metode Java yang menggunakan *service path* target di antara semua metode ($CSP^{k}$) yang ditemukan dalam $k$ file Java teratas.

## 4. Hasil Eksperimen

### A. Analisis Pengelompokan Layanan (RQ1)

*   Total $441$ klaster layanan dihasilkan.
*   Evaluasi pada *top-five* klaster besar menunjukkan bahwa klaster yang dihasilkan secara semantik masuk akal (misalnya, klaster terbesar dengan $90$ layanan diberi label manual *Application performance management*).
*   **Kesimpulan RQ1:** Pendekatan *clustering* yang diusulkan menghasilkan klaster API yang wajar tanpa mengandalkan catatan *linkage* layanan.

### B. Evaluasi Rekomendasi Layanan (RQ2)

| Jenis Rekomendasi | Top-1 SRP | Top-2 SRP | Top-3 SRP |
| :--- | :--- | :--- | :--- |
| Substitutable Services | 1.0 | 0.833 | 0.778 |
| Input-Oriented Mergeable | 1.0 | 1.0 | 0.889 |
| Output-Oriented Mergeable | 1.0 | 0.833 | 0.778 |

*   **Rekomendasi Akurat:** Semua indikator SRP Top-K melebihi $0.778$. Rekomendasi Top-1 berhasil $100\%$.
*   **Kesimpulan RQ2:** Pendekatan rekomendasi API yang diusulkan mampu menemukan layanan yang berguna untuk substitusi atau komposisi.

### C. Evaluasi Discovery Contoh Kode Klien (RQ3)

Perbandingan dilakukan antara API Prober (menggunakan analisis AST dan penilaian) dan *GitHub Search API* dasar.

| Metrik | API Prober (EP) | GitHub Search API (EP) |
| :--- | :--- | :--- |
| Top-1 | 0.872 | 0.319 |
| Top-2 | 0.883 | 0.266 |
| Top-3 | **0.895** | 0.263 |

*   **Presisi Tinggi:** Presisi Contoh (EP) Top-3 API Prober mencapai $\mathbf{0.895}$, menunjukkan kemampuan tinggi untuk menemukan kode klien yang benar.
*   **Keunggulan Jelas:** API Prober secara signifikan mengungguli *GitHub Search API* dasar, yang menegaskan efektivitas metode JMP berbasis AST dan mekanisme penilaian.
*   **Kesimpulan RQ3:** Pendekatan *retrieval* kode yang diusulkan mampu menemukan kode Java yang benar dengan presisi tinggi di sebagian besar situasi.

## 5. Kesimpulan

API Prober adalah sistem novel yang berhasil mengimplementasikan fitur **FAIR** (Findability, Accessibility, Interoperability, dan Reusability) untuk Web API REST-style. Melalui analisis OAS berbasis graf, anotasi semantik, pengelompokan yang valid, rekomendasi layanan yang akurat, dan *retrieval* kode klien Java berbasis AST yang presisi, API Prober menyediakan dukungan yang jauh lebih mendalam daripada sistem direktori API yang ada.

::: info Dampak Praktis
API Prober secara efektif memecahkan masalah menemukan layanan yang relevan, merekomendasikan layanan pengganti/gabungan, dan menyediakan contoh kode penggunaan yang terverifikasi, yang semuanya penting untuk meningkatkan produktivitas pengembang dan memfasilitasi interoperabilitas dalam pengembangan aplikasi modern, terutama dalam konteks aplikasi elektronik yang membutuhkan integrasi Web API.
:::

---

Would you like me to focus on the technical details of the **Java Method Parser (JMP)**, specifically outlining the four enhanced service path matching sub-methods and the scoring rules?