---
title: Review Paper - Penyematan Multigraf Fungsi untuk Pencarian Kode
description: Rangkuman paper tentang metode FuncGraphCS menggunakan Function Multigraph Embedding untuk meningkatkan akurasi pencarian kode (Ruan Jian Xue Bao/Journal of Software, 2024).
head:
  - - meta
    - name: keywords
      content: code search, control flow graph, data dependence graph, function multigraph, RGCN
---

# 042 - 面向代码搜索的函数功能多重图嵌入 (Code-search-oriented Function Multigraph Embedding)
Tautan (DOI) [http://www.jos.org.cn/1000-9825/6940.htm]

**Penulis:** **徐杨** ᵃ, **陈晓杰** ᵃ, **汤德佑** ᵃ, **黄翰** ᵃ*

**Afiliasi:**
* ᵃ 华南理工大学软件学院 (College of Software Engineering, South China University of Technology), 广东广州 510006, China

**Kronologi:** Received: 9 Mei 2022 • Revised: 16 Februari 2023 • Accepted: 27 Maret 2023 • Available Online: 26 Juli 2023

<a href="https://www.scimagojr.com/journalsearch.php?q=19913&tip=sid" target="_blank"><img src="https://www.scimagojr.com/journal_img.php?id=19913" alt="SCImago Journal & Country Rank" /></a>

| Resume Eksekutif |
| :--- |
| **Publikasi:**<br>• **Jurnal:** 软件学报 (Ruan Jian Xue Bao/Journal of Software), Vol. 35, No. 8, pp. 3809–3823 (2024)<br>• **Topik:** Peningkatan akurasi *code search* dengan mengatasi masalah ketidakmampuan *Control Flow Graph* (CFG) dalam menangkap relasi ketergantungan non-langsung antar-pernyataan.<br><br>**Masalah & Solusi:**<br>• **Masalah:** Akurasi pencarian kode terhambat karena model yang ada (teks atau struktur) gagal mengekstrak fitur kontekstual yang akurat. Secara spesifik, *Control Flow Graph* (CFG) tidak secara eksplisit merepresentasikan relasi ketergantungan antar-pernyataan yang bukan merupakan pendahulu atau penerus langsung (*non-direct predecessor/successor*), yang esensial untuk memahami **fungsi** kode.<br>• **Solusi:** Mengusulkan **FuncGraphCS** (*Code-search-oriented Function Multigraph Embedding*). Solusi ini menggunakan strategi **Fusi Awal (*Early Fusion*)** untuk menggabungkan **Data Dependence Graph (DDG)** ke dalam CFG, membentuk **Fungsi Multigraf** (*Function Multigraph*) yang merepresentasikan kode. Multigraf ini secara eksplisit menambahkan ketergantungan data (*data dependencies*) sebagai tipe tepi (edge) yang berbeda, sehingga memperkaya informasi kontekstual untuk setiap simpul pernyataan.<br><br>**Contoh Penerapan:**<br>• Diterapkan pada tugas *function-level code search* di *dataset* **CodeSearchNet (Java)**. Fungsinya adalah memadankan deskripsi kueri (menggunakan komentar fungsi/dokumentasi sebagai pengganti) dengan fungsi kode sumber yang paling relevan.<br><br>**Metodologi:**<br>• **Representasi Kode:** Fungsi diwakili sebagai **Fungsi Multigraf** $\mathbf{G}=(\mathbf{V},\mathbf{E})$, di mana simpul $\mathbf{V}$ adalah pernyataan kode dan tepi $\mathbf{E}$ memiliki dua tipe heterogen: $\mathbf{r=0}$ (*Control Flow*) dan $\mathbf{r=1}$ (*Data Dependence*). DDG hanya ditambahkan jika tepi tersebut belum ada di CFG.<br>• **Fusi Awal:** Data dependensi $\mathbf{E}_{DD}$ difusikan ke dalam $\mathbf{G}_{CF}$ sejak awal, sebelum ekstraksi fitur.<br>• **Ekstraksi Fitur:** Menggunakan **Relational Graph Convolutional Network (RGCN)** untuk mengekstrak fitur dari Multigraf. RGCN dipilih karena kemampuannya menangani tepi heterogen (dua tipe relasi, $\mathbf{r=0}$ dan $\mathbf{r=1}$) dan arah simpul (*directed graph*), memungkinkan agregasi fitur kontekstual yang sensitif terhadap tipe relasi.<br>• **Arsitektur:** Model *dual encoder* di mana kueri (komentar) di-*embed* dengan *Word Embedding* dan *Average Pooling*, dan kode di-*embed* dengan **RGCN** (2 layer).<br>• **Loss Function:** Menggunakan *Triplet Loss* untuk memaksimalkan kesamaan kosinus antara pasangan positif (*query/comment* $\mathbf{h}_{Q}^{+}$ dan *code* $\mathbf{h}_{graph}$) dan meminimalkan kesamaan terhadap *hard negative samples* ($\mathbf{h}_{Q_{j}}^{-}$).<br>$$\mathrm{loss}=\max\left\{1-\mathrm{sim}(\mathbf{h}_{graph},\mathbf{h}_{Q}^{+})+\max_{j}\mathrm{sim}(\mathbf{h}_{graph},\mathbf{h}_{Q_{j}}^{-}),0\right\}$$<br><br>**Temuan Kunci:**<br>1. **Kinerja SOTA:** FuncGraphCS mencapai $\mathbf{MRR}$ $\mathbf{0.6301}$, melampaui metode berbasis teks (NBOW: 0.5436) dan metode berbasis struktur (*multi-modal* atau *AST/PDG*), termasuk MRNCS ($\mathbf{0.5960}$) sebesar lebih dari $\mathbf{5\%}$.<br>2. **Kontribusi CFG Dominan:** Studi ablasi menunjukkan bahwa **CFG** (*Control Flow Graph*) memberikan kontribusi yang jauh lebih besar terhadap akurasi pencarian kode ($\mathbf{MRR}$ $\mathbf{0.6236}$) dibandingkan DDG saja ($\mathbf{MRR}$ $\mathbf{0.5890}$), memvalidasi bahwa struktur urutan/cabang/loop (CFG) adalah konteks fungsional yang paling penting.<br>3. **DDG Sebagai Suplemen:** Meskipun kontribusi DDG terhadap peningkatan MRR dari CFG hanya sedikit (dari 0.6236 menjadi 0.6301), hal ini membenarkan perannya sebagai **suplemen** untuk melengkapi relasi *non-direct predecessor/successor* yang hilang dalam CFG.<br>4. **Fusion Strategy:** Strategi *Early Fusion* (Multigraf) FuncGraphCS menunjukkan kinerja tertinggi dibandingkan *Intermediate Fusion* (vektor sum/concat), meskipun perbedaannya minimal, menegaskan bahwa konten tekstual (pernyataan) tetap menjadi fitur paling penting.<br><br>**Kontribusi Utama:**<br>• Mengusulkan **Fungsi Multigraf** baru yang memadukan CFG dan DDG menggunakan strategi Fusi Awal untuk representasi kode, mengatasi kelemahan CFG yang tidak lengkap.<br>• Menggunakan **RGCN** untuk secara efektif mengekstrak fitur kode dari struktur Multigraf yang heterogen dan berarah.<br>• Membuktikan bahwa fitur kontekstual berbasis CFG adalah kunci untuk akurasi *code search* yang tinggi.<br><br>**Dampak:**<br>• Metode ini menyediakan alat yang lebih akurat untuk *code search* fungsi-level, membantu pengembang memahami dan menggunakan kembali kode dengan lebih efisien, karena ekstraksi fitur yang ditingkatkan oleh Multigraf lebih akurat merefleksikan **fungsi** semantik kode. |

## 1. Pendahuluan & Masalah

*Code search* adalah aktivitas yang sangat sering dilakukan oleh pengembang untuk menemukan dan menggunakan kembali kode berkualitas tinggi. Masalah fundamental dalam *code search* adalah bagaimana meningkatkan akurasi pemadanan antara kueri bahasa alami (NL) yang heterogen dengan kode sumber (*source code*) yang sangat terstruktur.

Akurasi pemadanan sangat bergantung pada **ekstraksi fitur kode** yang tepat. Semantik suatu pernyataan kode tidak hanya bergantung pada teksnya sendiri, tetapi juga pada **konteks** sekitarnya. Struktur kode (urutan, cabang, perulangan) menyediakan informasi kontekstual yang kaya untuk memahami fungsionalitas kode.

Metode *code search* yang ada (berbasis teks atau berbasis struktur seperti AST dan PDG) sering gagal menangkap fitur kontekstual yang akurat. Secara khusus, *Control Flow Graph* (CFG) menangkap struktur urutan, cabang, dan perulangan, tetapi **gagal mengekspresikan relasi ketergantungan non-langsung** antar-pernyataan. Relasi seperti *data dependence* (ketergantungan data) sangat penting untuk memahami fungsi lengkap suatu pernyataan (misalnya, variabel dibuat di satu tempat dan ditutup jauh kemudian).

::: tip Solusi yang Diusulkan
Untuk mengatasi masalah ini, FuncGraphCS mengusulkan **Penyematan Multigraf Fungsi (*Function Multigraph Embedding*)**. Metode ini menggunakan strategi **Fusi Awal (*Early Fusion*)** untuk menggabungkan relasi ketergantungan data (*Data Dependence Graph*, DDG) ke dalam *Control Flow Graph* (CFG), membentuk **Fungsi Multigraf**. Multigraf ini, dengan tepi heterogen (kontrol dan data), memungkinkan ekstraksi fitur kode yang lebih kaya konteks menggunakan **RGCN**.
:::

## 2. Metodologi

FuncGraphCS mengadopsi kerangka *dual encoder* untuk mengekstrak fitur kode dan kueri secara independen, kemudian membandingkan kesamaannya.

### A. Fungsi Multigraf

**Fungsi Multigraf** ($\mathbf{G}$) didefinisikan sebagai gabungan dari CFG ($\mathbf{G}_{CF}$) dan DDG ($\mathbf{G}_{DD}$).
*   **Simpul ($\mathbf{V}$):** Setiap simpul mewakili satu pernyataan kode.
*   **Tepi ($\mathbf{E}$):** Tepi adalah berarah dan memiliki dua tipe relasi heterogen ($\mathbf{r} \in \mathbf{R}=\{0,1\}$):
    *   $\mathbf{r=0}$ (Relasi Kontrol/CFG): Merepresentasikan urutan eksekusi, termasuk struktur cabang dan perulangan.
    *   $\mathbf{r=1}$ (Relasi Ketergantungan Data/DDG): Ditambahkan **hanya jika** tepi $\mathbf{(v_i, v_j)}$ tidak ada di $\mathbf{G}_{CF}$, bertujuan untuk melengkapi relasi non-langsung (misalnya, antara deklarasi dan penggunaan akhir).

Strategi **Fusi Awal** digunakan karena simpul CFG dan DDG berbasis pada pernyataan kode yang sama, memungkinkan RGCN memproses informasi multimodal ini (kontrol dan data) secara bersamaan.

### B. Ekstraksi Fitur Fungsi

Ekstraksi fitur multigraf dibagi menjadi tiga langkah (lihat Gambar 3):

1.  **Ekstraksi Fitur Pernyataan Simpul (*Node Statement Feature*):** Fitur awal setiap simpul ($\mathbf{e}_{stmt}$) diperoleh dengan melakukan *Word Embedding* pada token pernyataan, diikuti oleh **Vector Average** (rata-rata vektor kata).
    $$\mathbf{e}_{stmt}=\frac{1}{n}\sum_{i=1}^{n}\mathbf{e}_{t_{i}}$$

2.  **Ekstraksi Fitur Kontekstual Pernyataan:** Menggunakan **Relational Graph Convolutional Network (RGCN)** 2-layer. RGCN secara khusus digunakan karena kemampuannya menangani tepi heterogen ($\mathbf{r=0}$ dan $\mathbf{r=1}$), memungkinkan simpul menggabungkan informasi dari tetangga berdasarkan tipe relasi dan arahnya, sehingga menghasilkan fitur simpul yang ditingkatkan secara kontekstual ($\mathbf{h}_{i}^{(L)}$).

3.  **Pembentukan Fitur Graf (*Graph Feature*):** Fitur akhir fungsi ($\mathbf{h}_{graph}$) dihasilkan dengan melakukan **Vector Average** pada semua fitur simpul yang ditingkatkan secara kontekstual.
    $$\mathbf{h}_{graph}=\frac{1}{m}\sum_{i=1}^{m}\mathbf{h}_{i}^{(L)}$$

### C. Ekstraksi Fitur Kueri dan Fungsi Rugi

Fitur kueri/komentar ($\mathbf{h}_{Q}$) diekstraksi menggunakan proses yang sama dengan fitur pernyataan simpul: *Word Embedding* diikuti oleh *Vector Average*.

Fungsi rugi yang digunakan adalah **Triplet Loss** dengan *hard negative sampling*:
$$\mathrm{loss}=\max\left\{1-\mathrm{sim}(\mathbf{h}_{graph},\mathbf{h}_{Q}^{+})+\max_{j}\mathrm{sim}(\mathbf{h}_{graph},\mathbf{h}_{Q_{j}}^{-}),0\right\}$$
Tujuan pelatihan adalah untuk meminimalkan *loss* dengan memaksimalkan kesamaan kosinus ($\mathrm{sim}(\cdot,\cdot)$) antara pasangan positif ($\mathbf{h}_{graph}$ dan $\mathbf{h}_{Q}^{+}$) dan meminimalkan kesamaan terhadap sampel negatif tersulit ($\mathbf{h}_{Q_{j}}^{-}$).

## 3. Detail Pengujian

### Dataset
*   **CodeSearchNet (Java):** Digunakan untuk eksperimen, setelah dilakukan pra-pemrosesan ekstensif (menghapus *keyword* seperti `public`/`static`, menghapus sampel dengan komentar non-Inggris/terlalu pendek, dan menghapus sampel yang tidak dapat diurai oleh alat Progex).

### Metrik
*   **Mean Reciprocal Rank (MRR):** Metrik utama untuk mengukur peringkat hasil.
$$MRR=\frac{1}{|Q|}\sum_{i=1}^{|Q|}\frac{1}{rank_{i}}$$
*   **Akurasi (*Accuracy*):** $\mathrm{ACC}@\mathbf{k}$ (dengan $\mathbf{k} \in \{1, 5, 10\}$) mengukur persentase kueri yang jawaban benarnya berada di $\mathbf{k}$ peringkat teratas.
$$ACC@k=\frac{\mathrm{count}}{|Q|}$$

### Model Dasar (*Baseline*)
Model dibandingkan dengan *baseline* berbasis teks (**NCS, DeepCS, NBOW**) dan berbasis struktur (**MMAN, DGMS, MRNCS** (MM-SBT)).

## 4. Hasil Eksperimen

### RQ1: Perbandingan Kinerja

Tabel 4 menunjukkan perbandingan MRR antara FuncGraphCS dan metode *baseline* lainnya.

| Metode | MRR | ACC@1 | ACC@5 | ACC@10 |
| :--- | :--- | :--- | :--- | :--- |
| NCS | 0.3667 | 0.2884 | 0.4543 | 0.4548 |
| DeepCS | 0.4607 | 0.3575 | 0.5793 | 0.6588 |
| NBOW | 0.5436 | 0.4471 | 0.6603 | 0.7245 |
| MMAN | 0.4942 | 0.3811 | 0.6294 | 0.7187 |
| DGMS | 0.4651 | 0.3395 | 0.6129 | 0.7056 |
| MRNCS (MM-SBT) | 0.5960 | 0.5030 | 0.7061 | 0.7678 |
| **FuncGraphCS (ours)** | **0.6301** | **0.5249** | **0.7580** | **0.8282** |

**Analisis:** FuncGraphCS mencapai MRR tertinggi (**0.6301**), melampaui metode berbasis teks terbaik (NBOW) sebesar $\mathbf{15.9\%}$ dan metode berbasis struktur terbaik (MRNCS) sebesar $\mathbf{5.7\%}$. Hasil ini menunjukkan bahwa Multigraf Fungsi yang menangkap konteks fungsional kode adalah representasi yang unggul untuk *code search*.

### RQ2: Studi Ablasi Komponen Graf

Tabel 5 membandingkan kontribusi relatif antara CFG dan DDG.

| Metode | MRR | ACC@1 | ACC@5 | ACC@10 |
| :--- | :--- | :--- | :--- | :--- |
| FuncGraphCS-cfg (ours) | 0.6236 | 0.5220 | 0.7501 | 0.8210 |
| FuncGraphCS-dd (ours) | 0.5890 | 0.4806 | 0.7185 | 0.7897 |
| **FuncGraphCS (ours)** | **0.6301** | **0.5249** | **0.7580** | **0.8282** |

**Analisis:**
1.  **CFG Dominan:** $\mathbf{FuncGraphCS-cfg}$ (hanya menggunakan CFG) menunjukkan MRR yang jauh lebih tinggi daripada $\mathbf{FuncGraphCS-dd}$ (hanya DDG), membuktikan bahwa relasi struktural *sequence/branch/loop* (CFG) adalah konteks yang lebih penting untuk pemahaman fungsi kode.
2.  **DDG Suplemen:** $\mathbf{FuncGraphCS}$ (CFG + DDG) memiliki MRR yang sedikit lebih tinggi daripada $\mathbf{FuncGraphCS-cfg}$ (0.6301 vs 0.6236). Ini mengonfirmasi hipotesis bahwa relasi ketergantungan data berfungsi sebagai **pelengkap** untuk mengisi relasi non-langsung yang kurang dalam CFG.

### RQ3: Perbandingan Strategi Fusi

Tabel 6 membandingkan strategi **Fusi Awal** (Multigraf yang diolah RGCN) dengan dua strategi **Fusi Menengah** (setelah ekstraksi fitur individu).

| Metode | MRR | ACC@1 | ACC@5 | ACC@10 |
| :--- | :--- | :--- | :--- | :--- |
| FuncGraphCS-sum (ours) | 0.6260 | 0.5158 | 0.7559 | 0.8290 |
| FuncGraphCS-concat (ours) | 0.6199 | 0.5133 | 0.7532 | 0.8238 |
| **FuncGraphCS (ours)** | **0.6301** | **0.5249** | **0.7580** | **0.8282** |

**Analisis:** Strategi **Fusi Awal** (FuncGraphCS) mengungguli Fusi Menengah (vektor *sum* dan *concat*), meskipun perbedaannya kecil. Hal ini menunjukkan bahwa **fitur tekstual** adalah komponen terpenting dari fitur kode, dan perbedaan strategi fusi struktural hanya memberikan dampak marjinal.

## 5. Kesimpulan

FuncGraphCS berhasil meningkatkan akurasi *code search* dengan mengatasi keterbatasan representasi struktural kode yang ada. Dengan mengusulkan **Fungsi Multigraf** melalui **Fusi Awal** CFG dan DDG, dan menggunakan **RGCN** untuk mengekstrak fitur dari tepi heterogen, model ini secara efektif menangkap konteks fungsional kode.

Eksperimen membuktikan peningkatan MRR lebih dari $\mathbf{5\%}$ dibandingkan dengan metode SOTA berbasis struktur. Studi ablasi menegaskan bahwa **CFG** memberikan kontribusi utama, sementara DDG berperan sebagai pelengkap penting.

::: info Dampak Praktis
Metode ini menekankan pentingnya **konteks fungsional** (terutama alur kontrol) dalam pencarian kode. Ini mengarahkan penelitian di masa depan untuk fokus pada pembuatan *dataset* kueri-kode yang selaras dengan skenario aplikasi nyata (daripada hanya komentar), yang merupakan kunci untuk memajukan bidang *code search* secara praktis.
:::