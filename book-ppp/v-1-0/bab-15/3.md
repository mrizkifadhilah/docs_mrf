# ðŸ“˜ SUB-BAB 15.3: STUDI KASUS INTEGRASI: SMART RETAIL SYSTEM

## ðŸŽ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Menganalisis arsitektur sistem yang kompleks dengan mengintegrasikan komponen **Mobile**, **Web**, **IoT**, dan **Cloud**.
2.  Memetakan aliran data antar-platform menggunakan **API Gateway** sebagai pintu gerbang terpusat.
3.  Melihat penerapan nyata **Microservices** dan **Polyglot Persistence** dalam satu ekosistem bisnis yang utuh.

---

## ðŸ”— Context & Hook
Pernahkah kamu masuk ke toko modern (seperti Amazon Go atau toko ritel pintar) di mana kamu bisa mengambil barang dan langsung keluar tanpa antre di kasir? Atau melihat stok di rak yang otomatis terisi ulang sebelum habis?

Ini bukan sihir. Ini adalah orkestrasi teknologi.
* **HP-mu (Mobile)** menjadi dompet digital.
* **Rak Toko (IoT)** menjadi mata-mata stok.
* **Laptop Manajer (Web)** menjadi pusat kendali.
* **Awan (Cloud)** menjadi otak yang menghubungkan semuanya.

Di sub-bab ini, kita tidak belajar teori baru. Kita akan **merakit** semua teori dari Bab 1 hingga Bab 14 menjadi satu sistem raksasa yang bekerja harmonis.

---

## ðŸ’¡ Analogi: Pertunjukan Orkestra
Bayangkan sebuah konser musik besar:
* **Pemain Biola (Mobile App):** Berinteraksi langsung dengan penonton (User). Lincah dan menonjol.
* **Pemain Drum (IoT Sensors):** Menjaga tempo di latar belakang. Tidak terlihat, tapi memberikan detak jantung data secara terus-menerus.
* **Konduktor (API Gateway/Cloud):** Berdiri di tengah. Memastikan Biola dan Drum tidak bertabrakan. Mengatur kapan data masuk dan keluar.
* **Partitur Musik (Database):** Sumber kebenaran yang dibaca oleh semua pemain agar nadanya (datanya) sama.

---

## ðŸ“š Inti Materi: Bedah Arsitektur Smart Retail

Sistem ini melayani 3 pengguna: Pelanggan (Mobile), Manajer (Web), dan Sistem Fisik (IoT).

### 1. Lapisan Frontend (Client)
* **Mobile App (Pelanggan):** Dibangun dengan **Flutter** (Cross-Platform). Fitur: Scan Barcode barang, Bayar via E-Wallet. Menggunakan **Local Database** (SQLite) untuk menyimpan riwayat belanja (*Offline-First*).
* **Web Dashboard (Manajer):** Dibangun dengan **React**. Fitur: Melihat grafik penjualan *real-time*. Menggunakan **WebSocket** untuk menerima update data live tanpa *refresh* halaman.
* **IoT Device (Rak Pintar):** Sensor berat di rak. Menggunakan protokol **MQTT** (bukan HTTP) karena hemat daya, mengirim data setiap kali barang diambil.

### 2. Lapisan Penghubung (Gateway)
Semua *client* di atas tidak bicara langsung ke Database. Mereka bicara ke **API Gateway**.
* Gateway melakukan **Otentikasi (JWT)**: "Apakah ini pelanggan valid?"
* Gateway melakukan **Routing**: "Data sensor kirim ke Service Stok. Data pembayaran kirim ke Service Bank."

### 3. Lapisan Backend (Microservices)
Backend dipecah menjadi kontainer-kontainer kecil (**Docker**) yang diatur oleh **Kubernetes**:
* **Service Katalog:** Mengelola nama & harga barang. (Database: MySQL/SQL).
* **Service Stok (Real-time):** Menerima data IoT. (Database: Redis/NoSQL agar cepat).
* **Service Notifikasi:** Mengirim email/push notif promo.

### 4. Alur Kerja Nyata
1.  **Budi (Pelanggan)** scan barang di toko -> Mobile App kirim Request HTTP ke API Gateway.
2.  **Rak (IoT)** mendeteksi barang berkurang -> Kirim pesan MQTT ke Broker.
3.  **Service Stok** menerima sinyal MQTT -> Update Redis -> Kirim sinyal WebSocket ke Dashboard Manajer.
4.  **Layar Manajer** berkedip: "Stok Susu menipis!" (dalam milidetik).

---

## ðŸ“± Contoh Penerapan: Skenario Flash Sale
Toko mengadakan diskon 90% untuk 100 unit iPhone.
1.  **Masalah:** Ribuan orang menekan tombol "Beli" bersamaan di Mobile App.
2.  **Solusi Microservices:**
    * Kubernetes mendeteksi lonjakan CPU di **Service Transaksi**.
    * Kubernetes otomatis membuat 50 kontainer baru untuk Service Transaksi.
    * Service lain (misal: IoT Rak) tidak terganggu.
3.  **Hasil:** Transaksi lancar, stok ter-update akurat (Atomic Transaction), tidak ada yang beli barang ghaib (stok minus).

---

## ðŸ“– Mini-Glossary
* **Orchestration:** Pengaturan otomatis sistem komputer yang kompleks (seperti Kubernetes mengatur Docker).
* **MQTT:** Protokol pesan ringan untuk IoT (mesin-ke-mesin).
* **WebSocket:** Protokol komunikasi dua arah *real-time* antara browser dan server.
* **API Gateway:** "Satpam" pintu depan yang menerima semua request dari luar dan meneruskannya ke layanan internal yang tepat.

---

## ðŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Analisis Arsitektur:** Mengapa Sensor IoT di rak toko menggunakan protokol MQTT untuk melapor ke server, bukan menggunakan HTTP REST API seperti aplikasi Mobile?
    * a. Karena sensor IoT biasanya memiliki daya pemrosesan dan baterai yang sangat terbatas; MQTT jauh lebih ringan (overhead kecil) dan efisien daripada HTTP.
    * b. Karena HTTP terlalu cepat.
    * c. Karena sensor tidak punya alamat IP.
    * d. Karena MQTT lebih aman.
    * e. Karena Mobile App membenci MQTT.

2.  **Integrasi:** Dalam sistem Smart Retail ini, Manajer Toko bisa melihat stok barang berkurang di layar komputernya *tepat saat* pelanggan mengambil barang dari rak, tanpa perlu me-refresh halaman web. Teknologi apa yang memungkinkan hal ini?
    * a. Caching Redis.
    * b. WebSocket (Komunikasi dua arah real-time).
    * c. SQL Injection.
    * d. Docker Container.
    * e. Offline-First.

3.  **Skenario:** Jika **Service Notifikasi** (pengirim email promo) tiba-tiba *crash* karena error kode, apa dampaknya terhadap Pelanggan yang sedang melakukan pembayaran di kasir (menggunakan **Service Transaksi**)?
    * a. Pembayaran gagal total.
    * b. Seluruh toko mati lampu.
    * c. Tidak ada dampak (Fault Isolation); pembayaran tetap lancar karena Service Transaksi berjalan di kontainer terpisah.
    * d. Database terhapus.
    * e. HP Pelanggan restart.

4.  **Database:** Data "Daftar Harga Barang" (Katalog) jarang berubah tapi butuh struktur rapi. Data "Posisi Keranjang Belanjaan Sementara" berubah sangat cepat dan strukturnya dinamis. Strategi *Polyglot Persistence* mana yang tepat?
    * a. Katalog: NoSQL, Keranjang: SQL.
    * b. Katalog: SQL (MySQL), Keranjang: Key-Value Store (Redis).
    * c. Semuanya pakai Excel.
    * d. Semuanya pakai File Teks.
    * e. Tidak perlu database.

5.  **Peran Gateway:** Apa fungsi API Gateway dalam skenario di mana pelanggan menggunakan berbagai jenis klien (Android, iOS, Web) untuk mengakses backend yang sama?
    * a. Mengubah kode Android menjadi iOS.
    * b. Menyediakan satu pintu masuk standar yang menyembunyikan kerumitan ribuan Microservices di belakangnya, serta menangani otentikasi sentral.
    * c. Menyimpan semua data barang.
    * d. Membuat tampilan aplikasi menjadi bagus.
    * e. Memperbaiki HP rusak.

### Kunci Jawaban
1.  **a** (Efisiensi *bandwidth* dan energi adalah kunci IoT).
2.  **b** (HTTP butuh *refresh*/*polling*, WebSocket *push* data instan).
3.  **c** (Keunggulan utama arsitektur Microservices adalah isolasi kegagalan).
4.  **b** (SQL untuk integritas data master, Redis untuk kecepatan data sementara).
5.  **b** (*Abstraction Layer* untuk klien agar tidak pusing menghubungi servis satu per satu).

---

## ðŸš€ Mini Challenge
**Hubungkan Titik-Titik:**
Ambil secarik kertas.
1.  Gambar lingkaran (User HP).
2.  Gambar kotak (API Gateway).
3.  Gambar 3 tabung kecil (Service A, B, C).
4.  Gambar tabung besar (Database).
5.  Tarik garis: User -> Gateway -> Service A -> Database.
6.  Ini adalah *Request Flow*. Sekarang bayangkan Service A mati. Coret Service A. Apakah User bisa lewat jalur lain ke Service B? (Ya, via Gateway).

---
*Siap mengintip masa depan? Ketik **"Lanjut"** untuk masuk ke **Sub-Bab 15.4: Tren Masa Depan: WASM & Edge Computing**.*