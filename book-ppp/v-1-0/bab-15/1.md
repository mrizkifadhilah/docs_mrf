# ğŸ“˜ SUB-BAB 15.1: EVOLUSI ARSITEKTUR: MONOLITIK VS MICROSERVICES

## ğŸ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Membedakan arsitektur **Monolitik** (satu kesatuan) dan **Microservices** (terpecah-pecah).
2.  Menjelaskan konsep **Scalability Independen** dan **Fault Isolation** sebagai keunggulan utama Microservices.
3.  Menganalisis *trade-off* kompleksitas yang muncul saat beralih ke sistem terdistribusi.

---

## ğŸ”— Context & Hook
Bayangkan sebuah Toko Kelontong kecil. Hanya ada satu kasir yang merangkap tukang bersih-bersih, tukang stok barang, dan manajer. Jika kasir sakit, seluruh toko tutup. Ini efisien saat toko masih kecil, tapi apa yang terjadi jika pelanggan membludak menjadi 1.000 orang per hari? Satu orang itu akan pingsan.

Dalam dunia software, aplikasi yang "satu orang melakukan segalanya" disebut **Monolitik**. Saat pengguna bertambah, kita tidak bisa hanya menyuruh "satu orang" itu bekerja lebih cepat. Kita butuh tim khusus: Tim Kasir, Tim Gudang, dan Tim Kebersihan yang bekerja sendiri-sendiri tapi saling komunikasi. Inilah **Microservices**.

---

## ğŸ’¡ Analogi: Truk Raksasa vs. Armada Motor
* **Monolitik = Truk Kontainer Raksasa:**
    Satu kendaraan besar mengangkut semua barang (Login, Pembayaran, Katalog, Pengiriman).
    * *Kelebihan:* Mudah dikemudikan (deploy) jika muatan sedikit.
    * *Masalah:* Jika satu ban bocor, seluruh truk berhenti. Jika muatan bertambah sedikit, kamu harus beli truk raksasa baru yang mahal (*Vertical Scaling*). Sulit berbelok (kurang lincah).
* **Microservices = Armada 100 Motor:**
    Barang dibagi-bagi ke 100 motor. Motor A bawa Katalog, Motor B bawa Pembayaran.
    * *Kelebihan:* Jika Motor A mogok, Motor B tetap jalan (Pembayaran aman). Jika butuh angkut lebih banyak Katalog, cukup tambah Motor A saja (*Horizontal Scaling*). Sangat lincah.
    * *Masalah:* Mengatur lalu lintas 100 motor jauh lebih pusing daripada menyetir 1 truk.

---

## ğŸ“š Inti Materi

### 1. Arsitektur Monolitik
Adalah desain tradisional di mana seluruh fungsionalitas aplikasi (Frontend, Backend, Database Logic) disatukan dalam satu basis kode dan satu file *executable* (.jar/.exe).
* **Masalah:** Jika kamu ingin mengubah satu baris kode di fitur "Diskon", kamu harus me-*restart* seluruh aplikasi "Toko".
* **Skalabilitas:** Sulit. Kamu harus menduplikasi seluruh "Toko" (server besar) walaupun yang sibuk hanya bagian kasirnya saja.

### 2. Arsitektur Microservices
Aplikasi dipecah menjadi layanan-layanan kecil (*services*) yang berdiri sendiri dan berkomunikasi lewat jaringan (API).
* **Service Inventaris:** Fokus menghitung stok.
* **Service Pengiriman:** Fokus memanggil kurir.
* **Service Autentikasi:** Fokus login user.

### 3. Keunggulan Utama Microservices
* **Scalability Independen:** Jika fitur "Pencarian Produk" sedang ramai (CPU tinggi), kamu cukup memperbanyak (scale-out) server "Pencarian" saja. Server "Login" tidak perlu ditambah. Hemat biaya.
* **Ketahanan (Resilience/Fault Isolation):** Jika Service Pengiriman *crash* (error), user tetap bisa *browsing* barang dan login. Sistem tidak mati total.
* **Kebebasan Teknologi:** Service A bisa ditulis pakai Java, Service B pakai Python (Go/Node.js).

### 4. Trade-off (Harga yang Harus Dibayar)
Microservices itu rumit.
* **Kompleksitas Jaringan:** Karena terpisah, komunikasi antar service bisa gagal (network timeout).
* **Monitoring Sulit:** Melacak *error* yang melompat dari Service A ke B butuh alat canggih (Observability - Bab 14).

---

## ğŸ“± Contoh Penerapan: Smart Retail System
Bayangkan sistem backend untuk Toko Ritel Modern:
1.  **Skenario Monolitik:** Saat *Flash Sale* 12.12, server kewalahan karena jutaan orang mencari barang. Akibatnya, fitur "Login Admin" ikut lambat dan tidak bisa dibuka, padahal Admin tidak ikut Flash Sale.
2.  **Skenario Microservices:**
    * Traffic membludak di **Service Katalog**.
    * Sistem otomatis menambah 50 server baru khusus untuk **Service Katalog**.
    * **Service Login Admin** tetap berjalan tenang di 1 server terpisah.
    * Hasil: Pelanja nyaman, Admin tetap bisa kerja.

---

## ğŸ“– Mini-Glossary
* **Monolitik:** Arsitektur perangkat lunak di mana semua komponen digabungkan menjadi satu program tunggal.
* **Microservices:** Pendekatan arsitektur di mana aplikasi dibangun sebagai sekumpulan layanan kecil yang berjalan di prosesnya sendiri-sendiri.
* **Decoupling:** Proses memisahkan komponen sistem agar tidak saling bergantung satu sama lain.
* **Fault Isolation:** Kemampuan sistem untuk membatasi dampak kegagalan agar tidak menyebar ke seluruh sistem.

---

## ğŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Analisis:** Mengapa arsitektur Microservices dianggap lebih "Resilient" (Tangguh) daripada Monolitik saat terjadi *bug* fatal di salah satu fitur?
    * a. Karena Microservices menggunakan komputer yang lebih mahal.
    * b. Karena isolasi proses; jika satu service *crash*, service lain tetap berjalan normal (sistem tidak mati total).
    * c. Karena Monolitik tidak punya fitur error handling.
    * d. Karena Microservices tidak punya *bug*.
    * e. Karena database-nya satu.

2.  **Skenario:** Kamu memiliki aplikasi Monolitik E-Commerce. Fitur "Chat Penjual" sangat boros memori, sedangkan fitur "Transaksi" sangat ringan. Apa yang terjadi jika kamu ingin men-*scale* aplikasi ini?
    * a. Kamu bisa memisahkan memori hanya untuk Chat.
    * b. Kamu terpaksa menduplikasi seluruh aplikasi (termasuk fitur Transaksi yang ringan) ke server baru yang besar, memboroskan resource.
    * c. Aplikasi akan otomatis memecah diri.
    * d. Kamu harus menghapus fitur Chat.
    * e. Server akan menolak.

3.  **Trade-off:** Apa tantangan teknis terbesar yang muncul ketika kita memecah aplikasi Monolitik menjadi 100 Microservices?
    * a. Kode program jadi terlalu sedikit.
    * b. Hard disk penuh.
    * c. Kompleksitas komunikasi jaringan (latency, timeout) dan kesulitan dalam *monitoring* atau *debugging* lintas service (Distributed Tracing).
    * d. User bingung.
    * e. Listrik boros.

4.  **Konsep:** Istilah "Scalability Independen" dalam Microservices berarti...
    * a. Semua service harus di-scale bersamaan.
    * b. Setiap service bisa ditingkatkan kapasitasnya (CPU/RAM/Jumlah Instance) secara terpisah sesuai kebutuhan beban kerjanya masing-masing.
    * c. Aplikasi tidak perlu server.
    * d. Developer bisa bekerja sendiri.
    * e. Database bisa membesar sendiri.

5.  **Strategi:** Kapan sebaiknya kamu **TIDAK** menggunakan Microservices dan tetap bertahan dengan Monolitik?
    * a. Saat tim developer masih kecil (misal: 3 orang) dan produk masih tahap awal (MVP), karena kompleksitas Microservices akan memperlambat pengembangan.
    * b. Saat pengguna sudah jutaan.
    * c. Saat kamu punya uang banyak.
    * d. Saat kamu ingin belajar teknologi baru.
    * e. Saat aplikasi butuh keamanan tinggi.

### Kunci Jawaban
1.  **b** (Isolasi kegagalan adalah fitur kunci ketahanan sistem terdistribusi).
2.  **b** (Kelemahan *scaling* Monolitik adalah ketidakmampuan memilah resource per fitur).
3.  **c** ("Fallacies of Distributed Computing": jaringan tidak bisa diandalkan 100%, menambah kerumitan).
4.  **b** (Efisiensi sumber daya yang presisi).
5.  **a** (Microservices memiliki "tax" atau biaya operasional tinggi yang tidak sepadan untuk tim kecil).

---

## ğŸš€ Mini Challenge
**Desain Sistem:**
Ambil kertas. Gambar kotak besar bernama "GOJEK MONOLITIK". Di dalamnya ada: *GoRide, GoFood, GoSend, GoPay*.
1.  Jika *GoFood* error karena database restoran mati, apakah *GoRide* di dalam kotak yang sama bisa terpengaruh? (Ya, bisa jadi satu aplikasi hang).
2.  Sekarang gambar 4 kotak kecil terpisah yang dihubungkan garis panah (Jaringan).
3.  Jika kotak *GoFood* meledak (dicoret), apakah kotak *GoRide* masih utuh?
4.  Inilah visualisasi kekuatan Microservices!

---
*Siap membungkus service-service kecil ini agar mudah dikirim? Ketik **"Lanjut"** untuk masuk ke **Sub-Bab 15.2: Revolusi Deployment: Docker & Kubernetes**.*