---
title: 'Sesi 8.3: Shard Key dan Data Balancing'
description: 'Menganalisis peran dan strategi pemilihan Shard Key yang efektif untuk menghindari masalah Hot Shard dan memelihara distribusi data yang merata.'
lang: id-ID
date: 2025-12-05
tag:
  - MongoDB
  - Sharding
  - Shard Key
  - Database Performance
level: Mahir
---

# ğŸ“š Sesi 8.3: Shard Key, Data Balancing, dan Kinerja

*Target audiens: Mahir. Developer/Arsitek yang bertanggung jawab atas kinerja dan pemeliharaan MongoDB Sharded Cluster.*

### Tujuan Pembelajaran
Setelah mempelajari materi ini, peserta mampu:

*   Menjelaskan fungsi kritis **Shard Key** dan konsekuensi dari pemilihan yang buruk.
*   Mengidentifikasi dan menjelaskan masalah **Hot Shard** dan **Jumbo Chunk**.
*   Menjelaskan peran **Balancer** dalam menjaga distribusi data merata (Even Distribution).

---

### 1. ğŸ”— Context & Hook (Bridging Awal)

**Recap (Sesi 8.1):** Kita sudah tahu Sharding memecah data menjadi **Shards** yang dikelola oleh **Mongos** dan **Config Servers**.

**The Hook (Fakta/Masalah Pemantik):** Meskipun kita sudah membagi data menjadi 10 server, semua *query* dan *write* tetap menyerbu hanya satu server (Shard) saja. Server itu *overload* sementara 9 server lainnya menganggur. Ini disebut **Hot Shard**.

**Pertanyaan Pemantik:** Apa yang mengontrol ke mana setiap dokumen baru harus ditempatkan? Bagaimana kita memastikan beban kerja tersebar adil ke semua Shards agar semua sumber daya terpakai?

**Target Superpower:** Hari ini, kita akan mendapatkan *superpower* untuk mengontrol **distribusi data** dan **beban kerja** di seluruh *cluster* menggunakan **Shard Key** dan memahami mekanisme *balancing*.

---

### 2. ğŸ§  Mental Model (Analogi)

Bayangkan Anda mengelola **Gudang Logistik Otomatis** (Sharded Cluster).

*   **Barcode (Shard Key):** Setiap paket (Dokumen) memiliki *barcode* unik. *Barcode* ini bukan hanya identifikasi, tetapi juga **menentukan ke rak mana (Shard) paket itu harus pergi**. Jika Anda memilih *barcode* yang buruk (misalnya, hanya berdasarkan warna), semua paket kuning akan menumpuk di satu rak, menyebabkan **Hot Shard** (Rak Panas).
*   **Robot Pemindah Barang (Balancer):** Ini adalah robot yang secara otomatis berpatroli. Jika Rak A kelebihan muatan (terlalu banyak *Chunk* data) dan Rak B kosong, robot ini akan memindahkan sebagian paket dari Rak A ke Rak B untuk menjaga keseimbangan.

---

### 3. âš™ï¸ Deep Dive (Inti Materi Engineering)

#### Definisi Shard Key
**Shard Key** adalah sebuah *field* atau *compound field* (kombinasi *field*) yang ada di dalam setiap dokumen, yang dipilih untuk menentukan bagaimana data didistribusikan ke seluruh Shards. Shard Key adalah **satu-satunya hal yang tidak dapat diubah** setelah koleksi di-shard.

#### Tiga Sifat Shard Key Kritis

1.  **Kardinalitas Tinggi (High Cardinality):** Harus memiliki banyak nilai unik (misalnya, `user_id`, bukan `gender`). Kardinalitas rendah menyebabkan *Hot Shard*.
2.  **Frekuensi Tulis/Akses Merata (Even Frequency):** Nilai harus diakses dan ditulis secara merata di sepanjang rentang. Shard Key berdasarkan waktu (*Timestamp*) seringkali buruk karena *write* hanya terjadi pada *Shard* terbaru (**Time-Series Hot Shard**).
3.  **Lokalitas Query (Query Isolation):** Shard Key idealnya harus digunakan dalam sebagian besar *query* aplikasi untuk memastikan *query* diarahkan hanya ke satu atau beberapa Shards (*Targeted Query*), bukan ke semua Shards (*Scatter-Gather*).

#### Jenis Shard Key (Strategi Partisi)

| Tipe Shard Key | Deskripsi | Kapan Digunakan |
| :--- | :--- | :--- |
| **Hashed Sharding** | Menggunakan *hash function* untuk menghitung Shard Key. Menyediakan distribusi data yang paling merata (Even Distribution). | Ideal untuk data yang memerlukan penyebaran beban **write** merata ke semua Shards. |
| **Ranged Sharding** | Membagi data berdasarkan rentang nilai Shard Key. | Ideal ketika *query* sering meminta data dalam **rentang** tertentu (misalnya, tanggal atau kode pos). |

#### Masalah Utama: Hot Shard dan Balancer

*   **Hot Shard:** Terjadi ketika semua *query* dan *write* terkonsentrasi pada satu Shard (biasanya akibat *Shard Key* yang buruk atau *Ranged Sharding* yang bersifat monotonik/berurutan). **Mengalahkan tujuan utama Sharding.**
*   **Balancer:** Sebuah proses otomatis yang berjalan di Config Servers. Tugasnya memantau distribusi **Chunks** (unit data yang dialokasikan) di seluruh Shards. Jika distribusi tidak merata, Balancer akan memindahkan *Chunk* dari Shard yang padat ke Shard yang kosong (**Chunk Migration**).
*   **Jumbo Chunk:** *Chunk* yang melebihi batas ukuran maksimum yang ditentukan. *Jumbo Chunk* tidak dapat dipindahkan oleh Balancer, sering terjadi ketika Shard Key memiliki kardinalitas rendah atau ketika terjadi *write* besar yang cepat.

---

### 4. Contoh Penerapan

*   **Aplikasi Global:** Menggunakan *Hashed Sharding* pada `user_id` untuk menyebarkan beban *write* pengguna baru ke seluruh dunia.
*   **Sistem Log:** Menggunakan *Ranged Sharding* pada `date` dan *Hashed* pada `log_source` (Compound Key) untuk memungkinkan *query* berdasarkan tanggal dan menyebarkan *write* berdasarkan sumber.

---

### 5. Mini-Glossary

*   **Shard Key:** Field yang menentukan penempatan dokumen.
*   **Hot Shard:** Shard yang menerima beban kerja yang tidak proporsional.
*   **Balancer:** Proses otomatis yang menyeimbangkan *Chunk* antar Shard.
*   **Chunk:** Unit terkecil dari data yang dimigrasikan oleh Balancer.
*   **Cardinality:** Jumlah nilai unik pada suatu *field*.

---

### 6. Visual yang Disarankan

*   Diagram perbandingan Ranged vs. Hashed Sharding.
*   Ilustrasi Hot Shard (satu Shard penuh, yang lain kosong).
*   Visualisasi proses Balancer memindahkan Chunk.

---

### 7. Evaluasi Singkat

1.  Shard Key yang ideal harus memiliki **Kardinalitas Tinggi** untuk distribusi yang merata.
2.  Masalah **Hot Shard** terjadi ketika **beban kerja** terkonsentrasi pada satu Shard.
3.  Proses yang bertanggung jawab untuk memindahkan *Chunk* antar Shards adalah **Balancer**.
4.  Sebuah *query* yang tidak menggunakan **Shard Key** cenderung menghasilkan operasi **Scatter-Gather**.
5.  *Hashed Sharding* sangat baik untuk menyebarkan beban **write** secara merata.

**5 Soal Pilihan Ganda (HOTS)**

1.  Tim *engineer* menggunakan *Ranged Sharding* pada *field* **`created_at`** (tanggal pembuatan). Apa masalah kinerja yang paling mungkin terjadi seiring berjalannya waktu?
    *   a. *Query* akan selalu menghasilkan *scatter-gather*.
    *   b. **Terjadi Hot Shard** karena semua *write* baru hanya menargetkan *chunk* dan *shard* terbaru.
    *   c. Balancer akan berhenti bekerja karena *Jumbo Chunk*.
    *   d. Config Servers akan kelebihan beban.
    *   e. Semua Shard akan menerima *write* secara merata.
2.  Mengapa **Kardinalitas Tinggi** (misalnya, jutaan nilai unik) merupakan persyaratan penting untuk Shard Key yang efektif?
    *   a. Karena *query* dapat berjalan lebih cepat tanpa *indexing*.
    *   b. Untuk memastikan bahwa *Chunk* memiliki peluang lebih tinggi untuk **didistribusikan secara merata** ke seluruh Shards.
    *   c. Untuk membatasi ukuran dokumen menjadi di bawah 16MB.
    *   d. Ini memungkinkan *Balancer* untuk bekerja lebih cepat.
    *   e. *Hashed Sharding* hanya dapat digunakan dengan *field* Kardinalitas Tinggi.
3.  Dalam skenario apa mekanisme **Hashed Sharding** lebih unggul daripada **Ranged Sharding**?
    *   a. Ketika Anda perlu mencari data berdasarkan rentang waktu.
    *   b. Ketika Anda ingin memastikan semua data yang berdekatan tersimpan di Shard yang sama.
    *   c. **Ketika tujuan utamanya adalah menyebarkan beban *insert* (tulis) secara *random* dan merata** ke seluruh *cluster*.
    *   d. Ketika *query* sering menggunakan *field* yang bersifat monotonik.
    *   e. Ketika Anda ingin Balancer berhenti bekerja.
4.  Apa yang dimaksud dengan *Query Isolation* dalam konteks pemilihan Shard Key?
    *   a. Memastikan data sensitif terisolasi dari data publik.
    *   b. **Memastikan *query* yang diberikan hanya menargetkan satu atau beberapa Shards** alih-alih melakukan *Scatter-Gather*.
    *   c. Mencegah Balancer memindahkan *Chunk* saat *query* sedang berlangsung.
    *   d. Membatasi jumlah *field* yang digunakan dalam Shard Key.
    *   e. Hanya mengizinkan *query* *read* ke Primary Shard.
5.  Masalah **Jumbo Chunk** terjadi ketika sebuah *Chunk* melebihi batas konfigurasi dan **tidak dapat dimigrasikan**. Hal ini sering disebabkan oleh:
    *   a. Kegagalan Mongos.
    *   b. Kardinalitas Shard Key yang terlalu tinggi.
    *   c. **Operasi *insert/update* dalam jumlah besar yang menargetkan satu nilai Shard Key** dalam waktu singkat.
    *   d. Penggunaan Ranged Sharding.
    *   e. Config Servers kelebihan beban.

*Jawaban HOTS Quiz:* 1. b, 2. b, 3. c, 4. b, 5. c

---

### 8. Mini-Challenge

**Tantangan:** Anda ingin menyimpan data pesanan (koleksi `orders`) dengan *Shard Key* **`{customer_id: 1, date: 1}` (Compound Key)**. Jelaskan mengapa ini lebih baik daripada hanya menggunakan **`{date: 1}`**.
> (Jawaban: `{date: 1}` akan menyebabkan Hot Shard (semua *write* ke hari ini). `{customer_id: 1, date: 1}` menyebarkan beban *write* (berdasarkan ID pelanggan yang *random*) dan pada saat yang sama, mempertahankan *lokalitas query* â€” semua pesanan satu pelanggan akan cenderung berada di Shard yang sama, memungkinkan *targeted query*).