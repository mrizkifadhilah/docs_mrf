---
title: 'Sesi 8.2: Anatomi Sharded Cluster'
description: 'Mengenal komponen-komponen utama MongoDB Sharded Cluster dan bagaimana mereka berinteraksi untuk mendistribusikan data dan query.'
lang: id-ID
date: 2025-12-05
tag:
  - MongoDB
  - Sharding
  - Architecture
  - Database Components
level: Menengah
---

# ðŸ“š Sesi 8.2: Membongkar Komponen Utama Sharded Cluster

*Target audiens: Menengah. Peserta yang mulai merencanakan atau bekerja dengan arsitektur database skala besar.*

### Tujuan Pembelajaran
Setelah mempelajari materi ini, peserta mampu:

*   Mengidentifikasi dan menjelaskan peran dari **tiga komponen utama** Sharded Cluster.
*   Menjelaskan bagaimana *query* dirutekan melalui cluster.
*   Memahami fungsi kritis dari **Config Servers**.

---

### 1. ðŸ”— Context & Hook (Bridging Awal)

**Recap (Sesi 8.1):** Kita memahami Sharding adalah mekanisme untuk membagi data secara horizontal ke beberapa server. Tujuannya: skalabilitas dan ketersediaan tinggi.

**The Hook (Fakta/Masalah Pemantik):** Membagi data itu mudah, tetapi bagaimana cara kita, sebagai aplikasi, tahu server mana yang menyimpan data yang kita cari? Kita tidak ingin *mengacak* semua server untuk setiap permintaan.

**Pertanyaan Pemantik:** Apa yang bertindak sebagai "petunjuk arah" atau "pintu masuk" cerdas yang tahu persis di mana setiap potongan data berada dalam arsitektur Sharding yang kompleks?

**Target Superpower:** Hari ini, kita akan mendapatkan *superpower* untuk melihat di balik layar dan memahami arsitektur yang memungkinkan MongoDB Sharding bekerja secara transparan bagi aplikasi.

---

### 2. ðŸ§  Mental Model (Analogi)

Bayangkan sebuah perusahaan *e-commerce* raksasa yang menyimpan inventarisnya di banyak gudang berbeda (Shards).

*   **Gudang Penyimpanan (Shard):** Ini adalah tempat data (inventaris) aktual disimpan. Setiap Gudang bekerja independen. Di MongoDB, ini adalah **Replica Set** yang menyimpan sebagian data.
*   **Pusat Informasi Utama (Config Servers):** Ini adalah server super kritis yang menyimpan **peta** lengkap: "Barang A disimpan di Gudang 3", "Barang B disimpan di Gudang 5". Tanpa peta ini, sistem lumpuh.
*   **Resepsionis/Petugas Gerbang (Mongos):** Ini adalah titik kontak pertama bagi pelanggan (Aplikasi). Anda hanya berbicara dengan Petugas Gerbang. Petugas Gerbang mencari di Pusat Informasi Utama (Config) dan merutekan permintaan Anda **langsung** ke Gudang yang benar (Shard).

---

### 3. âš™ï¸ Deep Dive (Inti Materi Engineering)

MongoDB **Sharded Cluster** terdiri dari tiga komponen utama yang saling berinteraksi:

#### 1. Shards
*   **Peran:** Tempat penyimpanan data aktual (data *payload*).
*   **Struktur:** Setiap Shard adalah sebuah **Replica Set** mandiri (minimal 3 anggota) untuk menjamin Redundansi dan Ketersediaan Tinggi.
*   **Fungsi:** Menyimpan **Subset** dari total data *cluster*.

#### 2. Config Servers
*   **Peran:** Menyimpan semua **Metadata Cluster**. Ini termasuk:
    *   **Peta Sharding (Chunk Metadata):** Informasi tentang rentang kunci (`Shard Key`) yang berada di Shard mana.
    *   Daftar semua Shards dan lokasinya.
    *   Konfigurasi *Balancer*.
*   **Struktur Kritis:** Harus diimplementasikan sebagai **Replica Set** (minimal 3 anggota) untuk ketersediaan. Config Servers sangat sensitif; kehilangan mayoritas anggota dapat melumpuhkan *cluster*.

#### 3. Mongos (Query Router)
*   **Peran:** Bertindak sebagai *interface* antara aplikasi dan Sharded Cluster. Aplikasi **hanya** berkomunikasi dengan Mongos.
*   **Fungsi:**
    *   **Routing Query:** Menerima *query* dari aplikasi, berkonsultasi dengan Config Servers untuk menemukan Shard yang tepat, dan merutekan *query* ke Shard tersebut (*Targeted Query*).
    *   **Aggregation:** Mengumpulkan hasil dari beberapa Shard dan menggabungkannya sebelum mengirimkannya kembali ke aplikasi (*Scatter-Gather Query*).

#### Alur Query (Targeted Read)

1.  Aplikasi mengirimkan *query* ke **Mongos**.
2.  Mongos memeriksa **Config Servers** untuk mengetahui di Shard mana data yang dicari (berdasarkan *Shard Key*) berada.
3.  Mongos merutekan *query* langsung ke **Shard** yang relevan.
4.  Shard mengeksekusi *query* dan mengembalikan hasilnya ke Mongos.
5.  Mongos mengembalikan hasil akhir ke Aplikasi.

---

### 4. Peran dan Kebutuhan

| Komponen | Min. Kebutuhan (HA) | Kunci Kinerja |
| :--- | :--- | :--- |
| **Shard** | 3 (Replica Set) | Kecepatan Disk I/O dan RAM untuk data. |
| **Config Servers** | 3 (Replica Set) | Jaringan yang sangat stabil dan cepat untuk Metadata. |
| **Mongos** | 1 (Idealnya 2+ untuk Redundansi) | Kemampuan Jaringan dan CPU untuk merutekan *query*. |

---

### 5. Mini-Glossary

*   **Shard:** Replica Set yang menyimpan subset data.
*   **Mongos:** Router *query* antara aplikasi dan cluster.
*   **Config Servers:** Penyimpan metadata Sharding (peta data).
*   **Chunk:** Unit dasar data yang dimigrasikan antar Shards.
*   **Targeted Query:** *Query* yang dirutekan hanya ke satu atau beberapa Shards yang relevan.

---

### 6. Visual yang Disarankan

*   Diagram arsitektur yang menunjukkan 1 (atau lebih) Mongos terhubung ke 3 Config Servers dan 3+ Shards (masing-masing 3 anggota Replica Set). Tunjukkan panah alur *query*.

---

### 7. Evaluasi Singkat

1.  Komponen yang berfungsi sebagai *router* antara aplikasi dan data adalah **Mongos**.
2.  Setiap **Shard** diimplementasikan sebagai sebuah **Replica Set**.
3.  Data yang disimpan di **Config Servers** adalah **Metadata Cluster** (peta data).
4.  Sebuah **Targeted Query** hanya menargetkan **Shard** yang relevan.
5.  Unit data yang dapat dimigrasikan antar Shards disebut **Chunk**.

**5 Soal Pilihan Ganda (HOTS)**

1.  Sebuah aplikasi kehilangan koneksi ke salah satu dari tiga Config Servers, tetapi dua lainnya masih beroperasi. Apa konsekuensi yang paling mungkin terjadi?
    *   a. Data pada Shard yang terkait dengan Config Server yang gagal akan hilang.
    *   b. Mongos akan berhenti merutekan semua *query*.
    *   c. **Cluster dapat terus beroperasi** karena Config Servers bekerja sebagai Replica Set dan masih memiliki Mayoritas (2 dari 3).
    *   d. Config Servers akan memulai migrasi *Chunk* secara otomatis.
    *   e. Semua *read* akan diubah menjadi *Targeted Query*.
2.  Apa kerugian kinerja utama dari **Scatter-Gather Query** (sebuah *query* harus menjangkau semua Shards)?
    *   a. Config Servers harus menyimpan metadata yang lebih besar.
    *   b. **Query membutuhkan waktu selama Shard yang paling lambat memprosesnya** dan meningkatkan latensi.
    *   c. Balancer secara otomatis akan berhenti bekerja.
    *   d. Mongos tidak dapat mengumpulkan hasilnya dengan benar.
    *   e. *Chunk* akan menjadi *Jumbo Chunk* yang tidak dapat dimigrasikan.
3.  Di mana **Peta Sharding** (informasi tentang Shard Key dan Chunk) disimpan?
    *   a. Di setiap Mongos secara terpisah.
    *   b. Di Replica Set Primary dari setiap Shard.
    *   c. Di **Config Servers**.
    *   d. Di sisi Aplikasi (Driver).
    *   e. Disimpan di Mongos dan Shard secara paralel.
4.  Mengapa setiap **Shard** di MongoDB *Cluster* harus berupa **Replica Set**?
    *   a. Agar *Balancer* dapat bekerja lebih cepat.
    *   b. Untuk memungkinkan *range query*.
    *   c. **Untuk menjamin Ketersediaan Tinggi (HA) dan Redundansi** pada subset data tersebut.
    *   d. Untuk membatasi ukuran Shard Key.
    *   e. Agar Mongos dapat melakukan *join* data.
5.  Manakah dari komponen berikut yang **tidak** menyimpan data *payload* (data aplikasi) secara langsung, melainkan hanya metadata atau informasi routing?
    *   a. Shard Primary.
    *   b. Shard Secondary.
    *   c. **Mongos**.
    *   d. Config Servers.
    *   e. Kedua C dan D.

*Jawaban HOTS Quiz:* 1. c, 2. b, 3. c, 4. c, 5. c

---

### 8. Mini-Challenge

**Tantangan:** Jika Anda ingin meningkatkan kapasitas *read* total *cluster* tanpa mengubah Shard Key, apa yang harus Anda lakukan pada komponen Shard?
> (Jawaban: Anda dapat menambahkan lebih banyak anggota **Secondary** ke setiap **Replica Set Shard** (horizontal scaling pada *read*), dan mengizinkan *read* dari Secondarys, sehingga meningkatkan total throughput *read* cluster).