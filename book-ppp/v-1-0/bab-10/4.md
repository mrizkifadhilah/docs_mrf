# ðŸ“˜ SUB-BAB 10.4: TEKNIK OFFLINE-FIRST: SINKRONISASI DAN RESOLUSI KONFLIK

## ðŸŽ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Menjelaskan mekanisme kerja strategi **Offline-First** menggunakan *persistent queue* (antrian persisten).
2.  Mengidentifikasi penyebab terjadinya **Konflik Sinkronisasi** data.
3.  Menerapkan strategi resolusi konflik yang tepat, seperti **Last Write Wins** atau **Merge Conflict**.

---

## ðŸ”— Context & Hook
Pernahkah kamu mengirim pesan WhatsApp saat sinyal hilang di dalam lift? Pesan itu tidak hilang, tapi muncul ikon "Jam Pasir". Begitu kamu keluar lift dan dapat sinyal, pesan otomatis terkirim (menjadi "Ceklis").

Ini terlihat sederhana, tapi di belakang layar ada proses rumit yang disebut **Sinkronisasi**. Masalah muncul jika kamu dan temanmu mengedit dokumen bersama (misalnya Google Docs) saat sama-sama offline. Ketika online kembali, editan siapa yang akan disimpan? Apakah editanmu menimpa editan temanmu, atau sebaliknya? Inilah mimpi buruk *software engineer*: **Konflik Data**.

---

## ðŸ’¡ Analogi: Kotak Pos dan Editor Majalah
1.  **Offline Queue (Antrian Offline):**
    Bayangkan kamu menulis 5 surat (data) di malam hari saat Kantor Pos tutup (Offline). Kamu tidak membuang surat itu, tapi menumpuknya di **Kotak Surat Depan Rumah (Persistent Queue)**. Besok pagi saat Kantor Pos buka (Online), tukang pos mengambil *semua* tumpukan surat itu sekaligus untuk dikirim.
2.  **Konflik Data:**
    Bayangkan dua editor sedang mengoreksi satu artikel yang sama di kertas terpisah. Editor A mengubah judul menjadi "Merah". Editor B mengubah judul menjadi "Biru". Saat mereka menyatukan pekerjaan, mana yang dipilih?
    * **Last Write Wins:** Siapa yang mengumpul terakhir, itu yang dipakai.
    * **Manual Merge:** Duduk bersama dan diskusikan judul baru ("Ungu"?).

---

## ðŸ“š Inti Materi

### 1. Strategi Offline-First
Aplikasi tradisional akan *error* jika tidak ada internet. Aplikasi **Offline-First** didesain agar fitur utamanya tetap jalan tanpa internet.
* **Cara Kerja:** Saat offline, aplikasi tidak mencoba mengirim data ke server (karena pasti gagal). Sebaliknya, aplikasi menyimpan operasi/perubahan (*mutations*) tersebut ke dalam **Persistent Queue** di database lokal.
* **Persistent Queue:** Antrian ini harus disimpan di *disk* (bukan RAM), agar jika HP mati/restart, data yang belum terkirim tidak hilang.

### 2. Proses Sinkronisasi (Sync)
Ketika koneksi internet pulih:
1.  Klien mendeteksi sinyal kembali.
2.  Klien mengirimkan semua operasi yang tertunda di *queue* secara berurutan ke server.
3.  Server memproses data, memperbarui database pusat, dan mengirim konfirmasi (*ack*) balik ke klien.

### 3. Konflik Sinkronisasi dan Resolusinya
Konflik terjadi ketika dua pihak mengubah data yang sama pada waktu yang bersamaan atau saat salah satu sedang offline. Strategi penyelesaiannya:

* **Last Write Wins (LWW):** Strategi paling umum dan mudah. Perubahan dengan *timestamp* paling baru dianggap sebagai pemenang dan menimpa data lama.
    * *Risiko:* Data dari pengguna lain yang *timestamp*-nya lebih lama akan hilang tertimpa.
* **Client Wins / Server Wins:** Menentukan otoritas mutlak (apakah data di HP selalu benar, atau data di Server selalu benar).
* **Merge Conflict / Manual Resolution:** Membutuhkan logika bisnis yang cerdas atau interaksi manusia untuk menggabungkan dua perubahan (seperti di Git atau Google Docs).

---

## ðŸ“± Contoh Penerapan: Aplikasi Catatan Bersama (Shared Notes)
Misalkan Budi dan Ani berbagi satu catatan belanja.
1.  **Kondisi:** Stok awal "Apel: 5".
2.  **Offline:** Budi (offline) ubah jadi "Apel: 10". Ani (offline) ubah jadi "Apel: 0".
3.  **Online:** Keduanya online kembali.
4.  **Skenario Last Write Wins:**
    * Budi simpan pukul 10:01.
    * Ani simpan pukul 10:05.
    * Server melihat Ani lebih baru. Hasil akhir: "Apel: 0". Perubahan Budi hilang.
5.  **Skenario Merge (Cerdas):** Server melihat kedua perubahan adalah "penambahan/pengurangan", lalu menghitung selisihnya, bukan menimpa nilainya.

---

## ðŸ“– Mini-Glossary
* **Persistent Queue:** Antrian penyimpanan data sementara di hard disk/storage lokal yang aman dari *restart*.
* **Mutation:** Sebuah operasi perubahan data (Create, Update, atau Delete).
* **Conflict:** Situasi di mana sistem bingung menentukan versi data mana yang benar karena ada dua perubahan berbeda pada objek yang sama.
* **Timestamp:** Penanda waktu digital yang digunakan untuk menentukan urutan kejadian.

---

## ðŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Analisis:** Mengapa *queue* (antrian) untuk data offline harus bersifat "Persistent" (disimpan di disk/SQLite), bukan hanya disimpan di variabel memori (RAM)?
    * a. Agar lebih cepat diakses.
    * b. Agar data tidak hilang jika pengguna menutup aplikasi atau me-restart HP sebelum sinyal kembali.
    * c. Karena RAM harganya mahal.
    * d. Agar server bisa membaca RAM HP pengguna.
    * e. Karena Persistent Queue tidak butuh internet.

2.  **Strategi:** Dalam aplikasi *Collaborative Text Editor* (seperti Google Docs), strategi resolusi konflik mana yang paling **BURUK** untuk pengalaman pengguna?
    * a. Operational Transformation (Merge canggih).
    * b. Manual Merge (User disuruh pilih).
    * c. Last Write Wins (Menimpa tulisan teman tanpa peringatan).
    * d. Real-time Sync.
    * e. Conflict Flagging.

3.  **Urutan:** Apa langkah pertama yang dilakukan aplikasi Offline-First begitu mendeteksi koneksi internet kembali menyala?
    * a. Menghapus semua data lokal.
    * b. Mengirim data di *persistent queue* ke server.
    * c. Meminta user login ulang.
    * d. Mengunduh update aplikasi.
    * e. Mematikan fitur edit.

4.  **Kasus:** Budi mengedit profilnya saat offline (Jam 08.00). Server mencatat profil lama Budi. Tono (Admin) mengedit profil Budi di server (Jam 08.05). Budi online kembali (Jam 08.10). Jika sistem menggunakan *Last Write Wins* berdasarkan waktu *edit* (bukan waktu sync), data siapa yang menang?
    * a. Data Budi (08.00) menang karena dia yang punya akun.
    * b. Data Tono (08.05) menang karena waktu editnya lebih baru daripada waktu edit Budi.
    * c. Data Budi menang karena dia online jam 08.10.
    * d. Terjadi error sistem.
    * e. Data keduanya digabung.

5.  **Konsep:** Apa tujuan utama dari fitur "Acknowledgement (Ack)" yang dikirim server ke klien setelah sinkronisasi selesai?
    * a. Memberitahu klien bahwa data sudah diterima aman, sehingga klien boleh menghapus data itu dari antrian lokal.
    * b. Meminta bayaran pulsa.
    * c. Memberitahu klien untuk offline lagi.
    * d. Mengirim iklan.
    * e. Mereset password.

### Kunci Jawaban
1.  **b** (RAM bersifat *volatile*/hilang saat mati, Disk bersifat *persistent*/tetap ada).
2.  **c** (LWW buruk untuk dokumen teks karena satu paragraf tulisan teman bisa hilang tertimpa begitu saja).
3.  **b** (Prioritas utama adalah mengosongkan antrian tunda/pending changes).
4.  **b** (Dalam LWW berbasis waktu edit, 08.05 > 08.00, jadi data Tono yang disimpan, meskipun Budi baru sync jam 08.10).
5.  **a** (Ack adalah sinyal sukses agar klien tidak mengirim ulang data yang sama/duplikasi).

---

## ðŸš€ Mini Challenge
**Eksperimen Mode Pesawat:**
1.  Buka aplikasi pencatat (Notes) yang tersinkron ke Cloud (misal: Google Keep/Apple Notes) di dua perangkat berbeda (HP dan Laptop).
2.  Matikan internet di **kedua** perangkat.
3.  Di HP: Edit Catatan A baris pertama jadi "HALO".
4.  Di Laptop: Edit Catatan A baris pertama jadi "DUNIA".
5.  Nyalakan internet di kedua perangkat bersamaan.
6.  Lihat hasilnya: Siapa yang menang? Atau apakah teksnya bergabung jadi "HALO DUNIA"? Ini cara kamu mengetahui strategi konflik aplikasi tersebut!