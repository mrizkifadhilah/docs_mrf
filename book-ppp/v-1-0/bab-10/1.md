# ğŸ“˜ SUB-BAB 10.1: ARSITEKTUR DATA: KESEIMBANGAN SERVER DAN LOKAL

## ğŸ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Membedakan peran **Database Server** (Remote) sebagai sumber kebenaran utama dan **Database Lokal** (Client) sebagai penyimpan sementara.
2.  Menganalisis *trade-off* (kompromi) arsitektural antara kecepatan akses data lokal versus integritas data terpusat.
3.  Menentukan strategi penyimpanan yang tepat untuk jenis data sensitif versus data *cache*.

---

## ğŸ”— Context & Hook
Pernahkah kamu membuka aplikasi Instagram atau Twitter saat sinyal hilang, tapi kamu masih bisa melihat foto-foto lama yang sudah pernah kamu *load* sebelumnya? Namun, ketika kamu mencoba memberi *like*, muncul tulisan "No Internet Connection"?

Itulah keajaiban (dan batasan) dari manajemen data **Lokal** vs **Server**. Aplikasi tidak mati total karena ada data yang disimpan di HP kamu, tetapi fitur inti yang butuh verifikasi (seperti *like* yang harus dihitung global) terhenti. Bagaimana arsitek sistem memutuskan data mana yang ditaruh di HP dan mana yang wajib di Server? Inilah inti dari sub-bab ini.

---

## ğŸ’¡ Analogi: Perpustakaan Pusat vs. Buku Catatan
Bayangkan sebuah **Sistem Perpustakaan Kota**:

* **Database Server = Perpustakaan Pusat:** Ini adalah gedung besar yang menyimpan *semua* buku yang ada. Ini adalah **Single Source of Truth**. Jika kamu ingin tahu apakah sebuah buku tersedia atau dipinjam orang lain, kamu wajib mengecek ke sini. Datanya lengkap, akurat, tapi kamu butuh waktu (perjalanan) untuk ke sana.
* **Database Lokal = Tas Ransel Kamu:** Kamu meminjam 3 buku dan menaruhnya di tas. Kamu bisa membaca buku di tasmu kapan saja (cepat, tanpa perjalanan), bahkan saat perpustakaan tutup (offline). Tapi, tasmu punya kapasitas terbatas, dan buku di tasmu mungkin "basi" (mungkin ada edisi revisi baru di perpustakaan pusat yang belum kamu tahu).

---

## ğŸ“š Inti Materi

### 1. Dua Lokasi Penyimpanan Utama
Aplikasi platform modern tidak menyimpan data di satu tempat saja. Data terdistribusi di dua lokasi utama:

* **Database Server (Remote):**
    * Biasanya menggunakan database besar seperti MySQL, PostgreSQL, atau MongoDB.
    * Berfungsi sebagai **Single Source of Truth** (Sumber Kebenaran Tunggal).
    * Data di sini diakses oleh klien melalui API dan harus *scalable* untuk melayani ribuan pengguna sekaligus.
    * **Prioritas:** Integritas, Keamanan, dan Sentralisasi.

* **Database Lokal (Client):**
    * Berada di dalam perangkat pengguna (HP, Browser, Laptop). Contohnya: SQLite (Mobile) atau LocalStorage/IndexedDB (Web).
    * Menyimpan **subset** (sebagian kecil) data yang relevan bagi pengguna tersebut.
    * Digunakan untuk **Caching** (mempercepat *loading*) dan mendukung operasi **Offline-First**.
    * **Prioritas:** Kecepatan Akses (Latensi Rendah) dan Ketersediaan saat Offline.

### 2. The Great Trade-off: Kecepatan vs. Integritas
Keputusan arsitektural terbesar di sini adalah menyeimbangkan dua hal yang sering bertentangan:
* **Data Lokal:** Sangat cepat diakses, tetapi berisiko "kedaluwarsa" (stale) atau tidak sinkron dengan server pusat.
* **Data Server:** Selalu benar dan mutakhir, tetapi lambat diakses (karena latensi jaringan) dan tidak bisa diakses tanpa internet.

### 3. Strategi Penempatan Data
Sebagai aturan praktis (rule of thumb):
* **Data Sensitif & Transaksional:** Wajib di **Server**. Contoh: Saldo bank, stok barang gudang, password user.
* **Data Sesi & Cache:** Boleh di **Lokal**. Contoh: Token login (agar tidak login ulang tiap buka aplikasi), feed berita yang baru dibaca, draft pesan yang belum dikirim.

---

## ğŸ“± Contoh Penerapan: Aplikasi E-Commerce
Mari lihat aplikasi belanja online:

1.  **Daftar Produk (Home Screen):** Disimpan di **Database Lokal (Cache)**. Saat user buka aplikasi, produk langsung muncul instan tanpa loading lama. Aplikasi diam-diam mengecek ke Server di *background* untuk melihat apakah ada perubahan harga.
2.  **Keranjang Belanja:** Disimpan di **Lokal** sementara. User bisa tambah barang meski offline.
3.  **Checkout & Pembayaran:** Wajib diproses di **Server**. Aplikasi harus memastikan stok barang benar-benar ada dan saldo user cukup. Tidak boleh ada toleransi data "basi" di sini.

---

## ğŸ“– Mini-Glossary
* **Single Source of Truth:** Prinsip bahwa data yang valid dan menjadi rujukan utama hanya ada di satu tempat (biasanya Server).
* **Caching:** Proses menyimpan salinan data di lokasi penyimpanan sementara (lokal) agar bisa diambil lebih cepat di masa depan.
* **Offline-First:** Pendekatan pengembangan di mana aplikasi dirancang untuk berfungsi dengan baik tanpa koneksi internet terlebih dahulu, baru kemudian menyinkronkan data.

---

## ğŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Kasus:** Sebuah aplikasi berita ingin meningkatkan kepuasan pengguna. Pengguna sering mengeluh aplikasi menampilkan layar putih kosong ("blank") selama 5 detik saat dibuka di area dengan sinyal buruk. Solusi arsitektural apa yang paling tepat?
    * a. Memindahkan semua database berita ke Cloud yang lebih mahal.
    * b. Menggunakan Database Lokal (SQLite) untuk menyimpan *headline* berita terakhir yang diunduh.
    * c. Memaksa pengguna untuk selalu online sebelum membuka aplikasi.
    * d. Mengganti protokol HTTP dengan FTP.
    * e. Menghapus fitur gambar pada berita.

2.  **Kasus:** Pada aplikasi Mobile Banking, fitur "Transfer Uang" tidak pernah diizinkan berjalan saat mode *offline*. Mengapa arsitek sistem menerapkan batasan ini?
    * a. Karena Database Lokal tidak mampu menyimpan angka nominal besar.
    * b. Karena HP pengguna tidak memiliki daya pemrosesan yang cukup untuk enkripsi.
    * c. Karena Database Server adalah *Single Source of Truth* untuk validasi saldo dan integritas transaksi.
    * d. Karena protokol HTTP tidak bisa berjalan di jaringan 4G.
    * e. Agar pengguna hemat kuota internet.

3.  **Analisis:** Apa risiko terbesar jika developer menyimpan data sensitif seperti "Riwayat Medis Pasien" secara permanen dan tidak terenkripsi hanya di Database Lokal (HP Dokter)?
    * a. Aplikasi menjadi lambat.
    * b. Data tidak bisa diakses jika HP hilang atau rusak (kehilangan data permanen) dan risiko kebocoran privasi fisik.
    * c. Server menjadi terlalu penuh.
    * d. Dokter tidak bisa bekerja saat offline.
    * e. Pasien tidak bisa login.

4.  **Konsep:** Manakah pernyataan berikut yang paling tepat menggambarkan hubungan antara Database Lokal dan Database Server?
    * a. Database Lokal menggantikan sepenuhnya Database Server di aplikasi modern.
    * b. Database Server hanyalah backup dari Database Lokal.
    * c. Database Lokal menyimpan *subset* data untuk kecepatan, sedangkan Database Server menyimpan data inti untuk kebenaran.
    * d. Database Lokal digunakan untuk data keuangan, Database Server untuk data gambar.
    * e. Tidak ada hubungan antara keduanya.

5.  **Strategi:** Anda membangun aplikasi media sosial. Saat user menekan tombol "Like", ikon hati langsung berubah merah (instan), padahal sinyal sedang buruk. Beberapa detik kemudian baru server mencatatnya. Teknik apa ini?
    * a. Server-Side Rendering.
    * b. Optimistic UI update menggunakan penyimpanan state Lokal.
    * c. SQL Injection.
    * d. Blocking I/O.
    * e. Data Mining.

### Kunci Jawaban
1.  **b** (Menyimpan *cache* lokal memungkinkan konten tampil instan/Offline-First).
2.  **c** (Transaksi keuangan membutuhkan integritas data pusat yang ketat/ACID).
3.  **b** (Data lokal berisiko hilang jika device rusak dan isu keamanan fisik, serta tidak tersinkronisasi pusat).
4.  **c** (Lokal untuk *speed/subset*, Server untuk *truth/core*).
5.  **b** (Memanipulasi tampilan lokal agar terasa cepat sebelum server merespons).

---

## ğŸš€ Mini Challenge
Buka aplikasi **WhatsApp** di HP-mu. Matikan koneksi internet (Airplane Mode).
1.  Coba buka *chat* lama. Apakah bisa terbaca? (Identifikasi: Ini data Lokal atau Server?)
2.  Coba kirim pesan baru. Apa yang terjadi pada ikon status pesan (jam pasir/ceklis)?
3.  Renungkan: Di mana pesan "jam pasir" itu disimpan sementara sebelum internet nyala kembali?