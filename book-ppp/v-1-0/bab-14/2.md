# ğŸ“˜ SUB-BAB 14.2: OPTIMASI CPU: THROTTLING & DEBOUNCING

## ğŸ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Menjelaskan masalah kinerja yang disebabkan oleh *event handler* yang dipicu terlalu sering (seperti *scrolling* atau *resizing*).
2.  Membedakan antara teknik **Throttling** (membatasi laju) dan **Debouncing** (menunda hingga berhenti).
3.  Memilih teknik yang tepat untuk skenario interaksi pengguna yang berbeda.

---

## ğŸ”— Context & Hook
Bayangkan kamu sedang mengetik di kolom pencarian Google. Kamu baru mengetik huruf "J", tapi komputer sudah sibuk mencari hasil untuk "J". Lalu kamu ketik "Ja", komputer mencari lagi. "Jak", cari lagi. "Jakarta", cari lagi.

Jika kamu mengetik cepat, CPU server akan dibombardir ratusan permintaan pencarian yang tidak berguna (karena kamu belum selesai mengetik). Ini pemborosan sumber daya yang masif!

Sama halnya saat kamu *scrolling* halaman web. Event "scroll" bisa terjadi 100 kali per detik. Jika setiap kali *scroll* kamu menyuruh CPU menghitung ulang layout, HP pengguna akan panas dan baterai bocor. Bagaimana cara "menenangkan" CPU agar tidak panik merespons setiap gerakan kecil? Jawabannya adalah **Throttling** dan **Debouncing**.

---

## ğŸ’¡ Analogi: Lift dan Senapan Mesin
1.  **Debouncing = Pintu Lift:**
    Lift tidak langsung menutup pintu setiap ada orang masuk. Ia menunggu. Jika ada orang lain masuk, *timer* di-reset. Pintu hanya akan tertutup jika **tidak ada lagi orang yang masuk** selama 5 detik.
    * *Prinsip:* "Tunggu sampai selesai, baru jalan."
2.  **Throttling = Senapan Mesin:**
    Meski kamu menahan pelatuk terus-menerus, peluru keluar dengan irama yang tetap (misal: 1 peluru tiap 0,5 detik). Tidak peduli seberapa cepat kamu menekan, laju tembakan dibatasi.
    * *Prinsip:* "Jalan terus, tapi batasi kecepatannya (maksimal X kali per detik)."

---

## ğŸ“š Inti Materi

### 1. Masalah: Event Storm
Beberapa interaksi pengguna memicu event dalam jumlah yang sangat banyak dan sangat cepat (*rapid-fire events*):
* `onScroll` (menggulir layar).
* `onResize` (mengubah ukuran jendela).
* `onKeyup` (mengetik teks).
Menjalankan fungsi berat (seperti request API atau kalkulasi DOM) pada setiap event ini akan mematikan responsivitas aplikasi.

### 2. Debouncing (Menunda)
Teknik ini memastikan fungsi hanya dipanggil **sekali** setelah pengguna **berhenti** melakukan aksi selama waktu tertentu.
* **Cara Kerja:** Jika event terjadi lagi sebelum waktu habis, batalkan timer lama dan mulai timer baru.
* **Penggunaan Ideal:** Kolom Pencarian (*Search Bar*). Jangan cari saat user masih mengetik. Cari hanya saat user berhenti mengetik selama 300ms.

### 3. Throttling (Membatasi)
Teknik ini membatasi fungsi agar hanya dijalankan **paling banyak sekali** dalam periode waktu tertentu.
* **Cara Kerja:** Jika fungsi baru saja dijalankan, abaikan semua panggilan berikutnya sampai 100ms berlalu.
* **Penggunaan Ideal:** *Infinite Scroll* (Memuat konten baru saat digulir). Kita perlu mengecek posisi scroll secara berkala (misal tiap 200ms) untuk memuat data, bukan menunggu user berhenti scroll.

---

## ğŸ“± Contoh Penerapan
1.  **Search Autocomplete (Debouncing):**
    * *Tanpa Debounce:* User ketik "Sepatu", API dipanggil 6 kali (S, Se, Sep, Sepa, Sepat, Sepatu). Server menangis.
    * *Dengan Debounce:* API hanya dipanggil 1 kali, yaitu 300ms setelah user selesai mengetik huruf "u".
2.  **Game Menembak (Throttling):**
    * User menekan tombol "Tembak" secepat kilat (10x per detik). Tapi aturan game membatasi senjata hanya boleh menembak 2x per detik. Throttling mengabaikan 8 klik lainnya.

---

## ğŸ“– Mini-Glossary
* **Debouncing:** Teknik optimasi yang menunda eksekusi fungsi sampai serangkaian event cepat berhenti.
* **Throttling:** Teknik optimasi yang menjamin fungsi hanya dijalankan sekali dalam interval waktu tertentu, tidak peduli seberapa sering event dipicu.
* **Event Handler:** Kode yang dijalankan sebagai respons terhadap aksi pengguna (klik, ketik, geser).
* **Rapid-fire Events:** Event yang terjadi beruntun dengan sangat cepat.

---

## ğŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Skenario:** Kamu membuat fitur "Auto-Save" pada aplikasi editor teks online (seperti Google Docs). Kamu ingin dokumen disimpan otomatis saat pengguna sedang berpikir (berhenti mengetik sebentar). Teknik mana yang paling tepat?
    * a. Throttling.
    * b. Debouncing.
    * c. Blocking I/O.
    * d. Caching.
    * e. Hardcoding.

2.  **Analisis:** Mengapa teknik *Debouncing* **TIDAK COCOK** digunakan untuk game karakter yang harus melompat segera saat tombol spasi ditekan?
    * a. Karena Debouncing akan membuat karakter melompat berkali-kali.
    * b. Karena Debouncing akan menunda lompatan sampai pemain melepas tombol atau berhenti menekan tombol lain, menyebabkan *input lag* yang parah.
    * c. Karena Debouncing terlalu cepat.
    * d. Karena Debouncing hanya untuk mouse.
    * e. Karena game tidak butuh optimasi.

3.  **Perbandingan:** Jika pengguna melakukan *scrolling* cepat selama 5 detik tanpa henti.
    * **Throttling (1 detik):** Fungsi akan dijalankan 5 kali (pada detik ke-1, 2, 3, 4, 5).
    * **Debouncing (1 detik):** Fungsi akan dijalankan...
    * a. 5 kali juga.
    * b. 1 kali saja, yaitu setelah pengguna berhenti scrolling di akhir detik ke-5.
    * c. 0 kali.
    * d. 10 kali.
    * e. Setiap milidetik.

4.  **Identifikasi:** Fitur "Cek Ketersediaan Username" pada form pendaftaran. Saat user mengetik username, sistem mengecek ke database apakah nama itu sudah dipakai. Strategi terbaik untuk menghemat bandwidth server adalah...
    * a. Mengecek setiap kali huruf diketik (onKeyup).
    * b. Mengecek menggunakan Throttling setiap 5 detik.
    * c. Mengecek menggunakan Debouncing (misal: 500ms setelah berhenti mengetik).
    * d. Mengecek saat user klik tombol Submit saja (validasi akhir).
    * e. Tidak perlu dicek.

5.  **Konsep:** Apa tujuan utama dari kedua teknik ini (Throttling & Debouncing)?
    * a. Mempercepat koneksi internet.
    * b. Mengurangi beban kerja CPU dan jumlah panggilan fungsi yang tidak perlu (efisiensi) akibat event yang berlebihan.
    * c. Membuat animasi lebih halus.
    * d. Mencegah hacker.
    * e. Menambah memori RAM.

### Kunci Jawaban
1.  **b** (Menyimpan *setelah* aksi berhenti adalah definisi Debouncing).
2.  **b** (Game butuh respons instan/real-time, penundaan Debouncing haram hukumnya di sini).
3.  **b** (Debouncing me-reset timer setiap ada event baru, jadi hanya dieksekusi di akhir).
4.  **c** (Memberikan *feedback* cepat tanpa membebani server dengan request parsial).
5.  **b** (Intinya adalah efisiensi pemrosesan event).

---

## ğŸš€ Mini Challenge
**Eksperimen Logika:**
Bayangkan kamu adalah **Lift**.
1.  Skenario A: Pintu terbuka. Orang masuk. Kamu tunggu 3 detik. Orang lain masuk di detik ke-2. Kamu reset timer jadi 3 detik lagi. Kapan pintu tertutup? (Ini Debouncing).
2.  Skenario B: Pintu terbuka. Kamu punya aturan: "Pintu harus menutup setiap 10 detik sekali, tidak peduli ada yang menahan tombol atau tidak." (Ini Throttling).
3.  Mana yang lebih aman untuk lift sebenarnya? (Biasanya Debouncing, agar orang tidak tergencet!).

---
*Siap berburu bug yang bersembunyi? Ketik **"Lanjut"** untuk masuk ke **Sub-Bab 14.3: Debugging Lanjut**.*