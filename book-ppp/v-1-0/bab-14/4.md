# üìò SUB-BAB 14.4: OBSERVABILITY: MATA-MATA DI PRODUCTION

## üéØ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Menjelaskan konsep **Observability** dan mengapa "Logging biasa" tidak cukup untuk aplikasi modern.
2.  Menerapkan **Structured Logging** (JSON) agar log mudah dicari dan dianalisis oleh mesin.
3.  Menggunakan alat **Error Reporting** otomatis (seperti Sentry/Crashlytics) untuk mendeteksi *crash* di perangkat pengguna secara *real-time*.

---

## üîó Context & Hook
Bayangkan kamu adalah pemilik pabrik mobil. Mobilmu dijual ke ribuan orang. Suatu hari, seorang pelanggan menelepon: "Mobil saya mogok!" Lalu dia menutup telepon.

Kamu tidak tahu di mana dia, apa yang dia lakukan sebelum mogok, atau bagian mesin mana yang rusak. Kamu buta total.

Inilah nasib developer yang tidak menerapkan **Observability**. Saat aplikasi *crash* di HP pengguna di London, kamu yang sedang tidur di Jakarta tidak akan tahu. Aplikasi yang baik harus punya "Kotak Hitam" (seperti di pesawat) yang otomatis mengirim laporan detail detik-detik sebelum kecelakaan terjadi.

---

## üí° Analogi: Kotak Hitam Pesawat (Black Box)
* **Log Biasa (Console.log):** Seperti **Catatan Harian Pilot** yang ditulis tangan di kertas. "Mesin bunyi aneh." Jika kertasnya terbakar saat kecelakaan, datanya hilang. Sulit dicari.
* **Observability (Structured Log & Error Reporting):** Seperti **Flight Data Recorder (Black Box)**.
    * Merekam ribuan sensor secara digital (Suhu, Ketinggian, Tekanan).
    * Data terstruktur dan dikirim ke satelit (Cloud).
    * Saat kecelakaan, tim investigasi bisa memutar ulang kejadian (*Replay*) untuk tahu persis penyebabnya tanpa perlu menebak-nebak.

---

## üìö Inti Materi

### 1. Masalah: "It Works on My Machine"
Di komputer developer, semua jalan lancar. Di *Production* (dunia nyata), server bisa kehabisan memori, jaringan pengguna bisa putus nyambung, atau database bisa *timeout*. Kita butuh mata-mata di sana.

### 2. Structured Logging (Log Terstruktur)
Jangan menulis log berupa teks bebas. Tulislah log sebagai **Data** (JSON).
* *Buruk:* `print("Error login user budi")` -> Susah di-filter.
* *Baik:* `logger.error({ event: "login_failed", user_id: "budi", reason: "wrong_password", ip: "192.168.1.1" })`
* **Keuntungan:** Kamu bisa masuk ke dashboard log dan melakukan query: *"Tampilkan semua error login yang berasal dari IP ini"*. Mesin bisa membacanya.

### 3. Error Reporting & Alerting
Gunakan alat pihak ketiga seperti **Sentry**, **Firebase Crashlytics**, atau **New Relic**.
* Alat ini disisipkan di kodemu.
* Jika aplikasi *crash* (Force Close), alat ini otomatis menangkap *Stack Trace* (daftar fungsi penyebab error), tipe HP pengguna, dan sisa baterai saat itu.
* Alat ini lalu mengirim notifikasi (Email/Slack) ke developer: *"Hei, ada bug baru di Halaman Pembayaran, terjadi pada 50 user iPhone 12!"*

### 4. Post-Mortem Analysis
Dengan data di atas, tim bisa melakukan **Post-Mortem** (Bedah Mayat) setelah insiden. Tujuannya bukan mencari siapa yang salah, tapi mencari **Root Cause** (akar masalah) agar tidak terulang lagi.

---

## üì± Contoh Penerapan: E-Commerce saat Harbolnas
1.  **Kejadian:** Transaksi gagal massal jam 12.00 siang.
2.  **Tanpa Observability:** Developer panik, cek server satu-satu, baca file teks ribuan baris. Waktu perbaikan: 2 jam. Kerugian miliaran.
3.  **Dengan Observability:**
    * Alert masuk ke Slack: *"High Failure Rate on Checkout API"*.
    * Developer buka Dashboard Log. Filter `event: "checkout_error"`.
    * Terlihat pola: Semua error memiliki pesan `Database Connection Timeout`.
    * Kesimpulan instan: Database overload.
    * Solusi: Tambah kapasitas database. Waktu perbaikan: 5 menit.

---

## üìñ Mini-Glossary
* **Observability:** Kemampuan untuk memahami kondisi internal sistem hanya dengan melihat data output-nya (Logs, Metrics, Traces).
* **Structured Logging:** Praktik menulis log dalam format terstandarisasi (biasanya JSON) agar mudah diindeks dan dicari (*queryable*).
* **Stack Trace:** Daftar urutan pemanggilan fungsi yang aktif saat sebuah *exception* atau *crash* terjadi.
* **Crashlytics:** Layanan pelaporan *crash* otomatis, sangat populer di pengembangan Mobile.

---

## üìù Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Analisis:** Mengapa log dengan format teks biasa (seperti `"User 123 gagal bayar karena saldo kurang"`) dianggap buruk untuk aplikasi skala besar?
    * a. Karena memakan banyak memori.
    * b. Karena sulit dianalisis secara otomatis oleh mesin/software monitoring (susah di-query atau di-filter berdasarkan User ID atau jenis error).
    * c. Karena teks biasa tidak aman.
    * d. Karena developer malas membaca.
    * e. Karena tidak berwarna.

2.  **Skenario:** Aplikasi Android-mu tiba-tiba *crash* hanya pada pengguna yang menggunakan HP Samsung tipe lama. Kamu tidak punya HP tersebut untuk tes. Fitur apa yang bisa menyelamatkanmu?
    * a. Profiler.
    * b. Breakpoint.
    * c. Error Reporting / Crashlytics (yang mengirimkan laporan detail tentang lingkungan hardware saat crash terjadi).
    * d. Throttling.
    * e. SQL Injection.

3.  **Identifikasi:** Manakah di bawah ini yang merupakan contoh **Structured Logging** yang baik?
    * a. `System.out.println("Error 500");`
    * b. `log.write("Database mati jam 5 sore");`
    * c. `{"level": "error", "timestamp": "2023-10-01T17:00:00Z", "service": "payment", "error_code": 500, "message": "Connection refused"}`
    * d. `// Todo: Fix this bug later`
    * e. `console.log(variable);`

4.  **Konsep:** Apa tujuan utama dari aktivitas *Post-Mortem Analysis* setelah insiden sistem terjadi?
    * a. Menghukum programmer yang membuat bug.
    * b. Mencari akar masalah (*Root Cause*) berdasarkan data log/metrik untuk mencegah insiden yang sama terulang kembali.
    * c. Menghapus semua log agar bersih.
    * d. Meminta maaf ke user.
    * e. Mengganti server baru.

5.  **Strategi:** Kamu ingin tahu berapa rata-rata waktu yang dibutuhkan user untuk menyelesaikan proses "Checkout". Data ini bukan error, tapi metrik performa. Ke mana data ini sebaiknya dikirim?
    * a. Ke Crashlytics (khusus crash).
    * b. Ke Monitoring/Analytics Dashboard (seperti Datadog/Google Analytics) melalui log atau *event tracking*.
    * c. Ke email pribadi CEO.
    * d. Dicatat di buku tulis.
    * e. Diabaikan.

### Kunci Jawaban
1.  **b** (Log teks tidak *machine-readable*, membuat analisis massal mustahil).
2.  **c** (Laporan Crashlytics menyertakan detail device spesifik yang membantu reproduksi bug).
3.  **c** (Format JSON Key-Value memungkinkan filtering dan agregasi).
4.  **b** (Fokus pada perbaikan sistem, bukan menyalahkan individu/*blameless culture*).
5.  **b** (Observability juga mencakup *Metrics* bisnis/kinerja, bukan cuma error).

---

## üöÄ Mini Challenge
**Simulasi Log JSON:**
Bayangkan kamu harus melaporkan error: "Gagal upload foto karena internet putus" untuk user bernama "Sari" (ID: 99).
1.  Tuliskan di kertas/notepad format log JSON-nya.
2.  Pastikan ada *key* untuk: `timestamp`, `user_id`, `action`, `error_message`, dan `connection_status`.
3.  Bandingkan kemudahannya dengan menulis kalimat: "Sari gagal upload foto jam segini karena internet mati." Mana yang lebih mudah jika kamu mau mencari "Semua user yang gagal karena internet mati"?

---
*Bab 14 Selesai! Kamu sekarang adalah dokter bedah kode yang handal. Ketik **"Lanjut"** untuk masuk ke **Bagian Penutup (Outro)**.*