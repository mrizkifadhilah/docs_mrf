# ðŸ“˜ SUB-BAB 14.1: PERFORMANCE PROFILING: MENCARI BOTTLENECK

## ðŸŽ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Menggunakan alat **Profiler** untuk mengukur penggunaan CPU dan Memori aplikasi secara *real-time*.
2.  Mendeteksi dan menganalisis **Bottleneck** (sumbatan kinerja) menggunakan visualisasi *Flame Graph*.
3.  Mengidentifikasi tanda-tanda **Memory Leak** (kebocoran memori) yang menyebabkan aplikasi melambat seiring waktu.

---

## ðŸ”— Context & Hook
Bayangkan kamu adalah seorang pembalap F1. Mobilmu terasa lambat di tikungan. Kamu tidak bisa sembarangan menebak, "Ah, mungkin bannya kempes," atau "Mungkin mesinnya rusak." Kamu butuh data. Tim mekanik akan menyolokkan komputer ke mobil untuk melihat grafik telemetri: suhu mesin, tekanan oli, dan RPM.

Dalam pemrograman, menebak-nebak penyebab aplikasi lambat ("Sepertinya *looping* ini berat deh...") adalah tindakan amatir. Profesional menggunakan data. Alat telemetri untuk *software* itu disebut **Profiler**. Tanpa Profiler, optimasi hanyalah tebak-tebakan buta.

---

## ðŸ’¡ Analogi: Dokter dan Mesin Rontgen
* **Aplikasi Lambat = Pasien Sakit:**
    Pasien datang mengeluh "Saya lemas". Dokter tidak langsung membedah perutnya.
* **Profiler = Mesin Rontgen/MRI:**
    Dokter menggunakan alat *scan* untuk melihat ke dalam tubuh tanpa membedahnya.
    * Jika terlihat ada sumbatan di pembuluh darah, itu adalah **CPU Bottleneck** (prosesor macet).
    * Jika terlihat ada cairan menumpuk yang tidak terbuang, itu adalah **Memory Leak** (sampah memori menumpuk).

---

## ðŸ“š Inti Materi

### 1. Apa itu Performance Profiling?
*Profiling* adalah proses memantau perilaku aplikasi saat sedang berjalan (*runtime*) untuk mengukur konsumsi sumber daya. Alatnya disebut **Profiler** (misalnya: Chrome DevTools Performance Tab, Android Studio Profiler, Xcode Instruments).

### 2. Dua Metrik Utama
Profiler biasanya memantau dua hal vital:
* **CPU Usage (Waktu Proses):** Seberapa keras otak komputer bekerja. Jika CPU terus-menerus 100%, HP akan panas dan baterai boros. Alat visualisasinya sering disebut **Flame Graph** atau **Call Tree**, yang menunjukkan fungsi mana yang paling lama memakan waktu CPU.
* **Memory Consumption (RAM):** Seberapa banyak ruang memori yang dipakai.

### 3. Masalah Klasik: Memory Leak
Bahasa modern (Java, JS, Python) memiliki **Garbage Collection (GC)**, yaitu petugas kebersihan otomatis yang membuang data tak terpakai dari RAM.
* **Memory Leak** terjadi ketika kodemu secara tidak sengaja "memegang" referensi ke objek yang sudah tidak dipakai, sehingga GC tidak berani membuangnya.
* **Dampak:** RAM perlahan penuh. Aplikasi awalnya cepat, tapi setelah 1 jam menjadi sangat lambat, dan akhirnya *crash* (Force Close) karena kehabisan memori (*Out of Memory*).
* **Solusi:** Gunakan fitur **Heap Snapshot** di Profiler untuk memotret isi memori dan mencari objek yang jumlahnya terus bertambah secara tidak wajar.

---

## ðŸ“± Contoh Penerapan: Aplikasi Galeri Foto
Kamu membuat aplikasi galeri. Pengguna melapor: "Makin lama dipakai *scrolling*, makin nge-lag."
1.  **Analisis:** Kamu menyalakan Profiler Memori.
2.  **Temuan:** Kamu melihat grafik RAM berbentuk "Tangga" (naik terus, tidak pernah turun).
3.  **Investigasi:** Kamu ambil *Heap Snapshot*. Ternyata, setiap kali foto digeser keluar layar, objek foto itu tidak dihapus dari memori karena masih ada variabel global yang menyimpannya.
4.  **Perbaikan:** Hapus referensi variabel tersebut. Grafik RAM kembali "Gergaji" (naik saat *load*, turun saat GC bekerja). Masalah selesai.

---

## ðŸ“– Mini-Glossary
* **Profiler:** Alat analisis kinerja untuk memantau penggunaan CPU, Memori, dan Jaringan secara *real-time*.
* **Bottleneck:** Titik kemacetan dalam sistem yang membatasi kinerja keseluruhan (bagian paling lambat).
* **Garbage Collection (GC):** Mekanisme otomatis membebaskan memori yang tidak lagi digunakan oleh program.
* **Memory Leak:** Kondisi di mana memori gagal dibebaskan, menyebabkan penggunaan RAM terus meningkat hingga aplikasi *crash*.
* **Heap Snapshot:** Potret instan isi memori pada satu titik waktu tertentu untuk analisis objek.
* **Flame Graph:** Visualisasi grafik batang bertumpuk untuk melihat seberapa dalam dan lama sebuah fungsi kode dijalankan.

---

## ðŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Diagnosis:** Jika sebuah aplikasi berjalan sangat lancar di 5 menit pertama, tetapi menjadi sangat lambat dan patah-patah setelah digunakan selama 30 menit tanpa henti, apa diagnosis yang paling mungkin?
    * a. CPU Bottleneck (Algoritma sorting terlalu berat).
    * b. Jaringan internet terputus.
    * c. Memory Leak (Kebocoran memori yang menumpuk).
    * d. Server down.
    * e. Resolusi layar terlalu tinggi.

2.  **Analisis Tool:** Kamu melihat **Flame Graph** di Profiler. Ada satu batang yang sangat lebar (panjang secara horizontal). Apa artinya?
    * a. Fungsi tersebut memakan banyak memori.
    * b. Fungsi tersebut memakan waktu eksekusi CPU yang lama (lambat).
    * c. Fungsi tersebut dipanggil berkali-kali.
    * d. Fungsi tersebut error.
    * e. Fungsi tersebut sudah dihapus.

3.  **Konsep:** Mengapa kita tidak boleh hanya mengandalkan *Garbage Collector (GC)* untuk mencegah kehabisan memori?
    * a. Karena GC kadang-kadang mogok kerja.
    * b. Karena GC hanya bisa menghapus objek yang tidak memiliki referensi (yang benar-benar dilepas oleh developer); jika developer lupa melepas referensi, GC tidak bisa menyentuhnya.
    * c. Karena GC memakan biaya lisensi mahal.
    * d. Karena GC hanya ada di bahasa C++.
    * e. Karena GC menghapus kode program.

4.  **Strategi:** Kapan waktu yang paling tepat untuk menggunakan Profiler?
    * a. Setiap kali menulis satu baris kode.
    * b. Hanya saat user sudah komplain aplikasi crash.
    * c. Secara berkala saat fase testing (QA) dan saat ada indikasi masalah kinerja, untuk memvalidasi asumsi.
    * d. Saat aplikasi sedang di-install.
    * e. Tidak perlu pakai Profiler, cukup tebak saja.

5.  **Identifikasi:** Manakah di bawah ini yang merupakan tanda visual dari penggunaan memori yang SEHAT pada grafik Profiler?
    * a. Garis lurus yang terus menanjak naik tanpa henti.
    * b. Garis rata di angka 0.
    * c. Pola "Gergaji" (Sawtooth): Naik saat alokasi objek, lalu turun drastis saat Garbage Collector (GC) membersihkannya, dan berulang stabil.
    * d. Pola acak yang tidak beraturan.
    * e. Grafik yang hilang timbul.

### Kunci Jawaban
1.  **c** (Gejala khas Memory Leak adalah degradasi performa seiring durasi pemakaian).
2.  **b** (Lebar pada Flame Graph merepresentasikan durasi waktu CPU).
3.  **b** (GC bukan sihir; developer tetap harus memutus referensi objek yang tidak dipakai).
4.  **c** (*Profiling* adalah alat diagnostik dan validasi, bukan alat penulisan kode).
5.  **c** (Pola gergaji menandakan GC bekerja efektif membersihkan sampah memori secara berkala).

---

## ðŸš€ Mini Challenge
**Detektif Chrome:**
1.  Buka browser Google Chrome di PC/Laptop.
2.  Buka website berita yang berat (banyak iklan).
3.  Klik kanan -> **Inspect** -> Pilih tab **Performance**.
4.  Klik tombol rekam (lingkaran), lalu *scroll* halaman web tersebut naik-turun selama 5 detik. Stop rekaman.
5.  Lihat grafiknya: Apakah ada warna kuning/merah yang mendominasi?
6.  Pindah ke tab **Memory**, pilih "Heap Snapshot", dan klik "Take Snapshot". Lihat berapa MB memori yang dimakan satu halaman web itu. (Kadang bisa kaget melihat angka 100MB+ untuk satu tab!).

---
*Siap mendinginkan CPU yang kepanasan? Ketik **"Lanjut"** untuk masuk ke **Sub-Bab 14.2: Optimasi CPU: Throttling & Debouncing**.*