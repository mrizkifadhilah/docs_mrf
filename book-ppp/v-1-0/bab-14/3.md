# ğŸ“˜ SUB-BAB 14.3: DEBUGGING LANJUT: BUKAN SEKADAR PRINT()

## ğŸ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Menjelaskan keterbatasan teknik *debugging* primitif menggunakan `print` atau `console.log`.
2.  Menggunakan **Breakpoints** untuk menghentikan waktu eksekusi dan memeriksa *state* aplikasi.
3.  Menerapkan **Conditional Breakpoints** untuk menangkap *bug* yang hanya muncul pada kondisi langka (misalnya: iterasi ke-999).

---

## ğŸ”— Context & Hook
Jujur saja, berapa sering kamu memperbaiki *bug* dengan cara menaburkan kode `print("Masuk sini")` atau `console.log(variable)` di mana-mana? Lalu setelah *bug* ketemu, kamu lupa menghapus kode sampah itu sampai terbawa ke *production*.

Teknik "Print Debugging" itu ibarat mencari jarum di tumpukan jerami dengan cara membakar jeraminya sedikit demi sedikit. Sangat lambat dan kotor.

Ada cara yang jauh lebih elegan: **Menjadi Pengendali Waktu**. Bagaimana jika kamu bisa membekukan waktu tepat saat *bug* terjadi, lalu berjalan-jalan di dalam kode untuk memeriksa isi variabel satu per satu? Itulah kekuatan **Breakpoints**.

---

## ğŸ’¡ Analogi: CCTV vs. Time Stop
* **Print Debugging = Rekaman CCTV:**
    Kamu hanya bisa melihat apa yang sudah terjadi setelah kejadian selesai. Kamu harus memutar ulang rekaman berjam-jam hanya untuk melihat momen 1 detik saat pencuri masuk. Jika kameranya kurang pas (lupa *print* variabel penting), kamu tidak tahu apa-apa.
* **Breakpoints = Time Stop (Dokter Strange):**
    Kamu bisa menghentikan waktu tepat saat pencuri (bug) hendak masuk. Kamu bisa berjalan mendekati pencuri itu, memeriksa isi sakunya (variabel), melihat dari mana dia datang (*call stack*), dan bahkan mengubah isi dompetnya (*evaluate expression*) untuk melihat apa yang akan terjadi selanjutnya.

---

## ğŸ“š Inti Materi

### 1. Masalah dengan Print()
* **Tidak Efisien:** Kamu harus menebak di mana harus menaruh *print*. Jika salah, harus edit kode dan *restart* aplikasi.
* **Kotor:** Sering lupa dihapus, mengotori *log* server.
* **Terbatas:** Hanya menampilkan teks string, tidak bisa melihat kedalaman objek yang kompleks atau urutan pemanggilan fungsi.

### 2. Breakpoints (Titik Henti)
Fitur standar di semua IDE modern (VS Code, Android Studio, Xcode).
* Kamu cukup klik di samping nomor baris kode (biasanya muncul titik merah).
* Saat eksekusi program mencapai baris itu, program akan **PAUSE** (berhenti sementara).
* Di saat berhenti, kamu bisa melihat nilai **SEMUA** variabel yang aktif saat itu tanpa perlu mencetaknya satu per satu.

### 3. Conditional Breakpoints (Jurus Rahasia)
Bagaimana jika *bug* hanya muncul di perulangan (*loop*) ke-999 dari 1000 data?
* Jika pakai *Breakpoint* biasa, kamu harus menekan tombol "Resume" 998 kali. Capek!
* Solusinya: **Conditional Breakpoint**.
* Kamu bisa memberi syarat pada titik merah itu: *"Hanya berhenti jika `i == 999` atau `saldo < 0`"*.
* Debugger akan mengabaikan 998 putaran pertama dan otomatis berhenti tepat di momen kritis. Efisiensi tingkat dewa.

---

## ğŸ“± Contoh Penerapan: Bug Diskon
Aplikasi *e-commerce* salah hitung diskon, tapi hanya untuk barang yang harganya di atas 10 juta.
1.  **Cara Kuno:** Pasang `print(harga)` di dalam loop. *Spamming* console dengan ribuan harga murah yang tidak relevan.
2.  **Cara Pro:** Pasang *Breakpoint* di baris perhitungan diskon. Klik kanan titik merahnya, pilih "Edit Condition". Masukkan: `item.price > 10000000`.
3.  **Hasil:** Jalankan aplikasi. Debugger otomatis membekukan aplikasi tepat saat barang mahal diproses. Kamu bisa langsung cek kenapa rumusnya salah.

---

## ğŸ“– Mini-Glossary
* **Breakpoint:** Penanda visual di baris kode yang menginstruksikan *debugger* untuk menunda eksekusi program di titik tersebut.
* **Conditional Breakpoint:** Breakpoint yang hanya aktif jika kondisi logika tertentu (Boolean) terpenuhi.
* **Step Over:** Perintah debugger untuk menjalankan baris kode berikutnya tanpa masuk ke dalam detail fungsi.
* **Step Into:** Perintah debugger untuk masuk ke dalam detail fungsi yang sedang dipanggil.
* **Call Stack:** Daftar riwayat fungsi yang dipanggil hingga mencapai titik saat ini (jejak langkah kode).

---

## ğŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Analisis:** Kamu sedang men-*debug* sebuah fungsi yang dipanggil 50 kali per detik (seperti fungsi render animasi). Kamu ingin memeriksa variabel di dalamnya. Mengapa menggunakan `print()` adalah ide yang sangat buruk di kasus ini?
    * a. Karena tinta printer mahal.
    * b. Karena `print` akan membanjiri *console* dengan ribuan baris teks per detik, membuat komputer lambat dan log sulit dibaca (noise).
    * c. Karena `print` tidak bisa mencetak angka.
    * d. Karena `print` akan menghapus variabel.
    * e. Karena `print` hanya jalan di Windows.

2.  **Skenario:** Ada *bug* aneh di mana saldo user menjadi negatif (`-5000`). Kamu tidak tahu kapan dan fungsi mana yang menyebabkannya. Fitur debugger apa yang paling efektif untuk menangkap pelakunya?
    * a. Pasang `print("Saldo sekarang: " + saldo)` di setiap baris kode.
    * b. Pasang *Conditional Breakpoint* pada variabel saldo dengan syarat `saldo < 0` (atau Watchpoint).
    * c. Baca ulang kode dari baris pertama sampai akhir.
    * d. Matikan aplikasi.
    * e. Hapus fitur saldo.

3.  **Perbandingan:** Apa keunggulan utama melihat variabel melalui panel *Variables* saat Breakpoint aktif dibandingkan dengan membacanya lewat log `print`?
    * a. Panel Variables bisa diedit warnanya.
    * b. Panel Variables bersifat interaktif; kamu bisa mengeksplorasi objek yang dalam (nested objects) dan bahkan mengubah nilainya secara langsung (*runtime editing*) untuk eksperimen.
    * c. Panel Variables lebih kecil font-nya.
    * d. Log print lebih akurat.
    * e. Tidak ada bedanya.

4.  **Konsep:** Istilah "Call Stack" dalam debugging merujuk pada...
    * a. Tumpukan kertas di meja developer.
    * b. Daftar fungsi yang sedang antre untuk dijalankan.
    * c. Jejak hierarki pemanggilan fungsi (misal: Fungsi A memanggil Fungsi B, B memanggil C) yang membantu melacak dari mana kita berasal sebelum sampai di titik *bug*.
    * d. Database error.
    * e. Memori yang bocor.

5.  **Strategi:** Kapan sebaiknya kamu tetap menggunakan `print` atau *Logging* daripada Breakpoint?
    * a. Saat men-*debug* masalah yang hanya terjadi di lingkungan *Production* (di HP user atau server live) di mana kamu tidak bisa menyambungkan IDE Debugger.
    * b. Saat kamu malas buka IDE.
    * c. Saat kodenya pendek.
    * d. Saat komputermu lambat.
    * e. Tidak ada alasan, Breakpoint selalu lebih baik.

### Kunci Jawaban
1.  **b** (Masalah *Noise* dan degradasi performa I/O akibat *logging* berlebihan).
2.  **b** (*Trap the culprit*: menjebak nilai variabel tepat saat ia berubah menjadi nilai invalid).
3.  **b** (Fleksibilitas inspeksi *deep-dive* dan manipulasi data *on-the-fly*).
4.  **c** (Konteks eksekusi sangat penting untuk memahami alur logika yang rumit).
5.  **a** (*Remote debugging* di production seringkali tidak memungkinkan, jadi *Log* terstruktur adalah satu-satunya jejak).

---

## ğŸš€ Mini Challenge
**Debugger Pertama:**
Jika kamu menggunakan VS Code atau Chrome DevTools:
1.  Tulis kode *loop* sederhana: `for (let i = 0; i < 100; i++) { console.log(i); }`.
2.  Klik di sebelah kiri angka baris `console.log`. Titik merah muncul.
3.  Jalankan kode (Run/Debug). Program akan berhenti di `i=0`.
4.  Klik kanan titik merah -> **Edit Breakpoint** -> Masukkan Expression: `i === 50`.
5.  Tekan tombol "Continue" (Panah Play).
6.  Program akan jalan cepat dan tiba-tiba berhenti lagi. Cek nilai `i`. Apakah `50`? Selamat, kamu sudah bisa memanipulasi waktu!

---
*Siap memantau aplikasi yang sudah ada di tangan user? Ketik **"Lanjut"** untuk masuk ke **Sub-Bab 14.4: Observability: Mata-Mata di Production**.*