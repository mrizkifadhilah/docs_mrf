---
title: Review Paper - Pencarian Kode Sintaksis dengan Sequence-to-Tree Matching
description: Rangkuman paper tentang pencarian kode sintaksis menggunakan pencocokan sequence-to-tree untuk fragmen kode yang tidak lengkap (Proc. ACM Program. Lang., 2024).
head:
  - - meta
    - name: keywords
      content: Code Search, Syntactic Analysis, Tree Wildcards, Sequence-to-Tree Matching, Incomplete Code Fragments, Tree Automata
---

# 027 - Syntactic Code Search with Sequence-to-Tree Matching: Supporting Syntactic Search with Incomplete Code Fragments
Tautan (DOI) [10.1145/3656460](https://doi.org/10.1145/3656460)

**Penulis:** **Gabriel Matute** ¹, **Wode Ni** ², **Titus Barik** ³, **Alvin Cheung** ¹, **Sarah E. Chasins** ¹

**Afiliasi:**
* ¹ University of California, Berkeley, USA
* ² Carnegie Mellon University, USA
* ³ Apple, USA

**Kronologi:** Publication Date: June 2024 • Article: 230

<a href="https://www.scimagojr.com/journalsearch.php?q=21101020042&tip=sid" target="_blank"><img src="https://www.scimagojr.com/journal_img.php?id=21101020042" alt="SCImago Journal & Country Rank" /></a>

| Resume Eksekutif |
| :--- |
| **Publikasi:**<br>• **Jurnal:** Proc. ACM Program. Lang. 8, PLDI, Article 230 (June 2024)<br>• **Topik:** Mengusulkan arsitektur dan algoritma baru untuk mendukung pencarian kode sintaksis (*syntactic search*) yang *tree-aware* menggunakan fragmen kueri yang tidak lengkap dan tidak dapat diurai (*unparsable*).<br><br>**Masalah & Solusi:**<br>• **Masalah:** Alat pencarian sintaksis ringan (*lightweight syntactic search tools*) saat ini (misalnya, Semgrep, Comby) memerlukan kueri berupa *snippet* kode yang **lengkap dan dapat diurai (*parsable*)** menjadi pohon sintaks. Keterbatasan ini menghalangi pengembang mendapatkan *feedback* langsung dan menyebabkan kueri yang sedang dikerjakan (*in-progress*) menjadi tidak berguna.<br>• **Solusi:** Mengusulkan arsitektur pencarian baru yang **hanya mengandalkan *tokenizing*** kueri, bahkan jika kueri tersebut tidak dapat diurai. Diperkenalkan semantik pencocokan baru: **Sequence-to-Tree Matching (STMatch)**, yang memungkinkan *token sequence* dengan *wildcard* yang *tree-aware* dicocokkan terhadap *Concrete Syntax Tree* (CST) kode sumber.<br><br>**Contoh Penerapan:**<br>• **stsearch:** Implementasi alat pencarian sintaksis yang menerapkan pendekatan STMatch, terbukti dapat memproses semua kueri yang *tokenizable*, termasuk kueri parsial/tidak lengkap, dan memberikan *feedback* langsung kepada pengembang.<br><br>**Metodologi:**<br>• **Arsitektur Baru:** Menghapus langkah *parsing* kueri. Kueri hanya melalui *Lexer* untuk menghasilkan *token sequence* (bukan *tree pattern*). Kode sumber tetap di-*parse* menjadi *Concrete Syntax Tree* (CST).<br>• **Sequence-to-Tree Matching (STMatch):** Algoritma pencocokan novel yang memformalkan semantik pencocokan sebagai pengenalan *regular tree language* yang ditentukan oleh pola, mirip dengan *finite tree automaton* (FTA) *top-down*.<br>• **Wildcard *Tree-Aware***: Memperkenalkan *wildcard* $\mathbf{\$\_}$ (*subtree wildcard*) untuk mencocokkan seluruh *subtree* (untuk ekspresi bersarang) dan $\mathbf{...}$ (*siblings wildcard*) untuk mencocokkan *siblings* yang berdekatan.<br>• **Algoritma STMatch:** Algoritma deterministik yang mengimplementasikan automata melalui traversal *pre-order* pada pohon sintaks, mencocokkan *token* konkret dengan daun (*leaves*) pohon, dan menggunakan *backtracking* untuk menyelesaikan ambiguitas *wildcard*.<br><br>**Temuan Kunci:**<br>1. **Dukungan Kueri Parsial:** *stsearch* berhasil menerima dan memproses **semua kueri parsial yang *tokenizable***, memberikan *feedback* penting di awal proses penulisan kueri.<br>2. **Kinerja Komparatif:** Untuk kueri lengkap yang sudah ada, *stsearch* memiliki hasil yang sebanding dengan Semgrep, hanya mengecualikan $\mathbf{4.95\%}$ dari kecocokan Semgrep (sebagian besar karena fitur *semantics-aware* Semgrep yang belum diimplementasikan di *stsearch*).<br>3. **Inklusi Kecocokan Parsial:** *stsearch* menghasilkan $\mathbf{67.65\%}$ kecocokan tambahan dibandingkan Semgrep untuk *benchmark* kueri yang lengkap, karena *stsearch* secara eksplisit mendukung dan menampilkan kecocokan parsial.<br>4. **Performa Interaktif:** Prototipe *stsearch* non-optimal sudah cukup berkineng untuk memberikan *feedback* secara langsung pada kecepatan interaktif (median waktu pencarian $\mathbf{270 \mu s}$ per file, $99^\text{th}$ persentil $\mathbf{24 \text{ ms}}$).<br><br>**Kontribusi Utama:**<br>• Bahasa kueri pencarian sintaksis baru dan semantik formal untuk menerima fragmen kode yang *tokenizable* tetapi tidak *parsable*.<br>• Algoritma pencocokan **STMatch** yang mencocokkan urutan *token* dengan *wildcard* terhadap pohon sintaks kode sumber.<br>• Implementasi *open-source*, **stsearch**, yang membuktikan kelayakan pendekatan ini.<br><br>**Dampak:**<br>• Membuka potensi untuk *live feedback* yang lebih baik selama penulisan kueri pencarian sintaksis, meningkatkan dukungan untuk pengaturan interaktif dan pengalaman pengembang secara keseluruhan. |

## 1. Pendahuluan & Masalah

Pengembang seringkali menggunakan alat pencarian kode sintaksis ringan (*lightweight syntactic search tools*), seperti Semgrep atau Comby, yang memanfaatkan struktur pohon kode untuk memberikan ekspresivitas yang lebih tinggi daripada pencarian berbasis string atau *regex*. Alat-alat ini memungkinkan pengembang menentukan pola sintaksis yang mencakup *placeholder* (*wildcard*).

Namun, alat-alat *syntactic search* yang ada saat ini, yang mengandalkan teknik pencocokan pohon-ke-pohon (*tree-to-tree matching*) tradisional, memiliki batasan utama: **mereka memerlukan kueri untuk diurai sepenuhnya menjadi pohon sintaks yang terbentuk dengan baik (*well-formed tree*).** Akibatnya, fragmen kueri yang sedang dikerjakan (*in-progress*) atau *snippet* yang tidak lengkap, yang mungkin valid secara leksikal (*tokenizable*) tetapi tidak dapat diurai (*unparsable*), menghasilkan kesalahan *parsing* dan sama sekali tidak memberikan hasil atau *feedback* kepada pengembang.

::: tip Solusi yang Diusulkan
Penelitian ini mengusulkan arsitektur pencarian baru yang menghilangkan kendala *parsability* pada kueri. Dengan hanya mengasumsikan kueri *tokenizable*, diperkenalkan semantik pencocokan *Sequence-to-Tree Matching* (**STMatch**) yang inovatif, yang mampu mencocokkan urutan *token* kueri terhadap pohon sintaks kode sumber, sambil tetap mendukung *wildcard* yang *tree-aware*. Ini memungkinkan *feedback* langsung saat kueri sedang ditulis.
:::

## 2. Metodologi

Untuk mengatasi batasan *parsability*, **stsearch** mengadopsi arsitektur *sequence-to-tree* yang berbeda dari sistem tradisional *tree-to-tree*.

### A. Arsitektur stsearch

Berbeda dengan sistem tradisional yang memproses kueri dan kode melalui *Lexer* dan *Parser* untuk menghasilkan *tree pattern*, arsitektur *stsearch* (*bi-modal*) hanya mengandalkan *Lexer* untuk kueri:
1.  **Query Processing:** Kueri hanya melewati **Lexer** untuk menghasilkan **urutan *token*** (*token sequence*). Langkah *Parser* dihilangkan.
2.  **Code Processing:** Kode sumber tetap melalui *Lexer* dan *Parser* (menggunakan *error-tolerant parser* seperti Tree-Sitter) untuk menghasilkan **pohon sintaks konkret (CST)**.
3.  **Sequence-to-Tree Matching:** Algoritma novel **STMatch** mencocokkan *token sequence* (kueri) terhadap pohon sintaks (kode).

### B. Query Language dan Wildcards

Bahasa kueri *stsearch* adalah **reguler** dan memungkinkan penggunaan kembali *lexer* sumber. Kueri adalah urutan *token* dari bahasa sumber, diperluas dengan *wildcard* yang *tree-aware*:
*   **Subtree Wildcard ($\$_$):** Mirip dengan *placeholder* ekspresi; memastikan bahwa seluruh *subtree* dalam CST dicocokkan, mempertahankan ekspresivitas untuk ekspresi bersarang (*nested expressions*).
*   **Siblings Wildcard ($\ldots$):** Mirip dengan *zero-or-more items placeholder*; memastikan bahwa *siblings* yang berdekatan dalam pohon dicocokkan (dapat mencocokkan nol atau lebih *subtree* yang berdekatan).

### C. Semantik Sequence-to-Tree Matching

Semantik pencocokan diformalkan dengan mereduksi masalah *sequence-to-tree matching* menjadi masalah pemeriksaan keanggotaan dalam **Regular Tree Language** yang dikenali oleh *Finite Tree Automaton* (FTA) *top-down* ($\mathcal{H}(p)=(Q,\mathfrak{F},I,\Delta)$).

Secara intuitif, semantik ini memastikan bahwa:
1.  **Token Konkret:** Setiap *token* konkret dalam pola muncul secara berurutan (*in order*) di daun (*leaves*) pohon.
2.  **Wildcard:** Setiap *wildcard* ($\$_$ atau $\ldots$) harus mencocokkan *subtree* yang lengkap segera setelah *token* terakhir yang dicocokkan, yang memungkinkan pohon diabaikan dalam jumlah tertentu, tetapi harus dalam batasan struktur sintaksis.

### D. Algoritma STMatch

Algoritma **STMatch** adalah algoritma **deterministik** yang mengimplementasikan logika FTA ini menggunakan traversal *pre-order* pada pohon sintaks melalui antarmuka *cursor*.

*   **Pencocokan Token Konkret:** Jika elemen berikutnya dalam pola adalah *token* konkret, algoritma harus mencocokkan daun paling kiri (*leftmost leaf*) berikutnya di pohon dan melanjutkan dengan *subtree* berikutnya.
*   **Pencocokan Wildcard:** Jika elemen berikutnya adalah *wildcard* ($\$_$), algoritma menebak *subtree* yang cocok saat ini. Jika pencocokan gagal, algoritma melakukan **backtracking** dan mencoba *subtree* berikutnya pada tulang belakang kiri (*left spine*) hingga berhasil atau kehabisan kandidat.
*   **Kompleksitas:** Kompleksitas *worst-case* teoritis algoritma adalah $\mathcal{O}(k \cdot d^{h+1})$, di mana $k$ adalah panjang kueri, $h$ adalah jumlah *wildcard*, dan $d$ adalah kedalaman maksimum pohon. Namun, dalam praktik, $k, h, d$ cenderung kecil, membuat algoritma cukup cepat.

## 3. Detail Pengujian

### Implementasi
Penelitian ini mengimplementasikan **stsearch** dalam bahasa **Rust** menggunakan *Tree-Sitter Rust bindings* dan *tree-sitter-javascript* untuk *parser*. Algoritma STMatch diimplementasikan secara mandiri (*free-standing*) di Rust.

### Benchmark Suite
*   **Kueri:** Diekstrak $\mathbf{308}$ kueri unik yang lengkap untuk *framework* Express dari repositori aturan Semgrep (*semgrep-rules*). Kueri ini kemudian digunakan untuk menghasilkan $\mathbf{1,107}$ kueri parsial *tokenizable* yang unik dan tidak ambigu (*unambiguous partial queries*).
*   **Korpus Kode:** $\mathbf{100}$ repositori paket npm yang bergantung langsung pada Express dan memiliki kode sumber publik di GitHub, terdiri dari total $\mathbf{15,233}$ file.

### Metrik
Evaluasi berpusat pada tiga pertanyaan penelitian (RQ):

**RQ1: Perbandingan Semantik (Kueri Lengkap):** Diukur dari **tingkat eksklusi** (*percentage excluded*) dan **tingkat inklusi** (*percentage included*) hasil *stsearch* dibandingkan dengan Semgrep, berdasarkan kecocokan rentang karakter yang identik.

**RQ2: Evolusi Kueri Parsial:** Diukur dari bagaimana hasil yang difilter dan hasil yang disertakan berkonvergensi ke hasil akhir (kueri lengkap) seiring dengan penambahan *token* prefix.

**RQ3: Performa Interaktif:** Diukur dari waktu eksekusi *stsearch* untuk *parsing* dan *searching* (satuan: ms).

## 4. Hasil Eksperimen

### RQ1: Perbandingan Semantik (Kueri Lengkap)

| Fase | Semgrep Matches | stsearch Excludes (dari Semgrep) | stsearch Matches (Total) |
| :--- | :--- | :--- | :--- |
| **Total** | 6,339,494 | **313,836 (4.95%)** | 18,629,106 (termasuk kecocokan parsial) |

*   **Eksklusi (stsearch tidak menemukan, Semgrep menemukan):** *stsearch* mengecualikan hanya $\mathbf{4.95\%}$ dari kecocokan Semgrep. Sebagian besar disebabkan oleh fitur *semantics-aware* Semgrep (misalnya, *constant propagation*, mengabaikan urutan kunci dalam literal objek, *rewriting* sintaks) yang belum diimplementasikan dalam *stsearch* yang *language-agnostic*.
*   **Inklusi (stsearch menemukan, Semgrep tidak):** *stsearch* menghasilkan $\mathbf{67.65\%}$ **kecocokan tambahan**. Ini karena *stsearch* dirancang untuk menampilkan kecocokan parsial, bahkan untuk kueri yang lengkap dan dapat diurai.

### RQ2: Evolusi Kueri Parsial

*   **Penyaringan (Filtering):** Sebagian besar kueri menunjukkan bahwa **beberapa *token* konkret pertama** (setelah *wildcard* pertama) melakukan sebagian besar penyaringan hasil.
*   **Konvergensi:** Hasil untuk kueri parsial sering kali **berkonvergensi** ke hasil kueri lengkap jauh sebelum *token* terakhir ditambahkan. Ini mengindikasikan bahwa pengembang dapat menghentikan penulisan kueri lebih awal karena *feedback* yang diberikan sudah memadai.

### RQ3: Performa Interaktif

*stsearch* menunjukkan kinerja yang memadai untuk *feedback* interaktif.

| Fase | Rata-rata $\pm$ SD | Median | Persentil ke-99 |
| :--- | :--- | :--- | :--- |
| *Tree-Sitter* parsing (per file) | $3 \pm 31$ ms | $660 \mu$s | 29 ms |
| **stsearch searching** (per file) | $10 \pm 480$ ms | **$270 \mu$s** | 24 ms |

*   Waktu pencarian median $\mathbf{270 \mu \text{s}}$ per file. Mengasumsikan *parsing* sudah dilakukan, sistem dapat menyelesaikan pencarian kurang dari satu detik untuk $\mathbf{91.10\%}$ repositori. Ini membuktikan bahwa prototipe *stsearch* cukup *performant* untuk memberikan *feedback* langsung pada kecepatan interaktif.

## 5. Kesimpulan

Paper ini memperkenalkan arsitektur dan algoritma **STMatch** yang revolusioner untuk mendukung pencarian kode sintaksis menggunakan kueri yang hanya *tokenizable*, tidak harus *parsable*. Dengan menghilangkan persyaratan *parsing* kueri dan memformalkan *Sequence-to-Tree Matching* melalui *tree automata*, *stsearch* berhasil mengatasi keterbatasan utama alat *syntactic search* yang ada.

*stsearch* tidak hanya memberikan hasil yang sebanding dengan SOTA (Semgrep) untuk kueri lengkap, tetapi yang lebih penting, ia sepenuhnya mendukung kueri parsial/tidak lengkap, memberikan *feedback* penting di awal proses penulisan.

::: info Dampak Praktis
Pendekatan *stsearch* membuka peluang signifikan untuk meningkatkan pengalaman pengembang dengan memungkinkan **umpan balik langsung (*live feedback*)** selama penulisan kueri. Dengan menerima spesifikasi yang sedang dikerjakan, *stsearch* dapat secara fundamental meningkatkan dukungan untuk pengaturan interaktif dalam *code search* dan *program transformation*.
:::