---
title: Review Paper - Studi Empiris Penggunaan API dari Mesin Pencari dan Pustaka Lokal
description: Rangkuman paper tentang studi empiris pertama mengenai penggunaan API di dalam kode pustaka (library code) dibandingkan dengan kode klien dari mesin pencari kode (Empirical Software Engineering, 2023).
head:
  - - meta
    - name: keywords
      content: API usage, API library, Empirical study, Code search engine, CODEEX, Internal usages, Java
---

# 051 - An empirical study on API usages from code search engine and local library
Tautan (DOI) [https://doi.org/10.1007/s10664-023-10304-z]

**Penulis:** **Hao Zhong** ᵃ*, **Xiaoyin Wang** ᵇ

**Afiliasi:**
* ᵃ Department of Computer Science and Engineering, Shanghai Jiao Tong University, Shanghai, China
* ᵇ Department of Computer Science, University of Texas at San Antonio, San Antonio, TX 78249, USA

**Kronologi:** Accepted: 9 February 2023 • Published Online: 13 April 2023

<a href="https://www.scimagojr.com/journalsearch.php?q=18650&tip=sid" target="_blank"><img src="https://www.scimagojr.com/journal_img.php?id=18650" alt="SCImago Journal & Country Rank" /></a>

| Resume Eksekutif |
| :--- |
| **Publikasi:**<br>• **Jurnal:** Empirical Software Engineering, Vol. 28, Article 63 (2023)<br>• **Topik:** Studi empiris perbandingan penggunaan API yang diekstraksi dari kode pustaka lokal (*library code*) dengan kode klien (*client code*) yang diambil dari mesin pencari kode (SearchCode). Fokus utama adalah mengatasi tantangan *internal usages* dalam kode pustaka.<br><br>**Masalah & Solusi:**<br>• **Masalah:** Meskipun kode pustaka dikenal mengandung penggunaan API yang lebih ringkas dan efektif, **tidak ada** studi yang menganalisis penggunaan API di dalam kode pustaka secara langsung karena kesulitan menghilangkan **internal usages** (panggilan ke elemen kode privat/terproteksi yang tidak dapat diakses klien). Mengabaikan *internal usages* akan melebih-lebihkan penggunaan API dari kode pustaka.<br>• **Solusi:** Mengusulkan alat **CODEEX** yang dirancang untuk mengekstrak sampel kode klien dari SearchCode dan, yang terpenting, **secara akurat menghilangkan *internal usages*** dari kode pustaka lokal untuk membandingkan penggunaan API secara adil dan valid dari perspektif klien.<br><br>**Contoh Penerapan:**<br>• Studi empiris pertama yang membandingkan penggunaan API untuk $\mathbf{5}$ pustaka Java populer: **accumulo, cassandra, karaf, lucene,** dan **poi**.<br>• Melakukan eksperimen terkontrol dengan $\mathbf{20}$ tugas pemrograman menggunakan pustaka **poi** untuk membandingkan efektivitas kedua sumber dalam membantu pemrograman.<br><br>**Metodologi:**<br>• **Alat:** **CODEEX** dibangun di atas PPA (*Partial Program Analysis*) untuk kode Internet (menghilangkan sampel tidak relevan dan usang) dan **JDT** (*Java Development Tools*) yang diperluas untuk kode pustaka lokal.<br>• **Penghapusan Internal Usages:** Untuk kode pustaka, CODEEX menghapus nama paket dan secara eksplisit mengimpor semua kelas. Kesalahan kompilasi akibat *internal usages* (misalnya panggilan metode privat) diidentifikasi dan diatasi menggunakan $\mathbf{9}$ **Removers ROI** (*Removing Internal usages*) dan $\mathbf{9}$ **Removers ROM** (*Removing consequential errors*), memastikan kode pustaka yang diekstraksi dapat dikompilasi dari sisi klien.<br>• **Analisis:** Mengukur **cakupan API** (kelas, metode, urutan panggilan) dan **karakteristik sampel** (repetisi, tumpang tindih) dari kedua sumber.<br>• **Eksperimen Manusia:** $\mathbf{4}$ mahasiswa PhD menyelesaikan $\mathbf{20}$ tugas dengan batas waktu $\mathbf{90}$ menit, membandingkan bantuan dari sampel SearchCode vs. sampel CODEEX (kode pustaka).<br><br>**Temuan Kunci (6 *Findings*):**<br>1. **Keterbatasan SearchCode (F1):** Rata-rata, hanya $\mathbf{9.3\%}$ kelas API yang memiliki sampel yang relevan dan terbaru dari kode Internet (SearchCode).<br>2. **Kekayaan Kode Pustaka (F2):** Sampel dari **kode pustaka** mencakup $\mathbf{4.0}$ kali lebih banyak kelas API, $\mathbf{4.7}$ kali lebih banyak metode API, dan $\mathbf{3.0}$ kali lebih banyak urutan panggilan (*call sequences*) daripada kode Internet, meskipun jumlah sampelnya lebih sedikit.<br>3. **Karakteristik Unik (F3):** Urutan panggilan dari **kode pustaka** **kurang repetitif** dibandingkan kode Internet, menantang teknik penambangan pola berbasis frekuensi.<br>4. **Tumpang Tindih yang Komplementer (F4):** Kedua sumber memiliki $\mathbf{90\%}$ kelas API dan $\mathbf{80\%}$ metode API yang tumpang tindih, tetapi tumpang tindih urutan panggilannya hanya sekitar $\mathbf{20\%}$, menunjukkan bahwa kedua sumber **saling melengkapi**.<br>5. **Efektivitas Bantuan (F5):** Dalam eksperimen terkontrol, penggunaan API yang lebih banyak (kode pustaka) **tidak** secara signifikan menghasilkan tugas yang lebih lengkap, menyoroti pentingnya teknik **rekomendasi kode** yang efektif.<br><br>**Kontribusi Utama:**<br>• Mengusulkan **CODEEX**, alat pertama yang secara valid mengekstrak penggunaan API dari kode pustaka dengan menghilangkan *internal usages* secara otomatis.<br>• Melakukan studi empiris skala besar pertama yang membandingkan penggunaan API dari kode klien (Internet) dan kode pustaka lokal.<br>• Memberikan wawasan mendalam mengenai potensi kode pustaka sebagai sumber belajar API yang jauh lebih kaya.<br><br>**Dampak:**<br>• **Motivasi Penelitian:** Hasil ini memotivasi penelitian di masa depan untuk mengembangkan mesin pencari dan alat rekomendasi API yang secara eksplisit memanfaatkan kekayaan penggunaan API dari kode pustaka.<br>• **Pemahaman Kekurangan:** Menjelaskan mengapa pengembang sering kesulitan menemukan sampel yang memadai (karena cakupan kode Internet yang rendah) dan mengapa kuantitas sampel yang lebih banyak saja tidak cukup untuk membantu pemrograman (membutuhkan teknik rekomendasi). |

## 1. Pendahuluan & Masalah

*Application Programming Interface* (API) adalah komponen penting dalam pengembangan perangkat lunak, tetapi pemrogram sering mengeluh bahwa **sulit untuk mempelajari penggunaan API** yang tepat. Untuk mengatasi hal ini, mereka mengandalkan mesin pencari kode (*code search engines*) seperti SearchCode, yang mengambil sampel kode klien (*client code*) dari repositori *online* skala Internet.

Namun, sampel yang diambil ini seringkali tidak memadai, terutama untuk API baru atau kurang populer. Di sisi lain, kode pustaka (*library code*) yang mendefinisikan API tersebut secara internal juga memanggil API-nya sendiri dengan cara yang **lebih ringkas dan efektif**, karena ditulis oleh pengembang yang paling memahami API. Meskipun kode pustaka menjanjikan sumber belajar yang lebih baik, upaya penelitian sebelumnya gagal memanfaatkannya karena tantangan teknis: kode pustaka mengandung **panggilan internal** (*internal usages*) ke elemen privat atau terproteksi yang tidak dapat diakses dari sisi klien. Jika *internal usages* ini tidak dihapus, studi empiris akan melebih-lebihkan penggunaan API dari kode pustaka.

::: tip Solusi yang Diusulkan
Untuk mengatasi kesenjangan pengetahuan ini, kami mengusulkan dan mengimplementasikan alat **CODEEX** yang secara otomatis menghilangkan *internal usages* yang tidak dapat diakses klien dari kode pustaka. Dengan dukungan CODEEX, kami melakukan studi empiris pertama yang valid secara klinis untuk membandingkan secara kuantitatif dan kualitatif penggunaan API yang diekstraksi dari kode pustaka dengan yang diekstraksi dari mesin pencari kode Internet.
:::

## 2. Metodologi

### A. Subjek Studi

Studi ini menggunakan $\mathbf{5}$ pustaka Java yang populer namun bervariasi dalam ukuran dan popularitas: **accumulo, cassandra, karaf, lucene,** dan **poi**. Untuk kode Internet, digunakan mesin pencari kode populer, **SearchCode**, yang memiliki repositori skala Internet.

### B. CODEEX: Ekstraksi Kode Internet

CODEEX mengekstrak sampel dari SearchCode dan menyaringnya menggunakan PPA (*Partial Program Analysis*) untuk:
1.  Menghilangkan sampel **tidak relevan** (impor tidak terpakai).
2.  Menghilangkan sampel **usang** (*obsolete*) yang memanggil API yang tidak ada dalam versi pustaka terbaru yang disurvei. Analisis dilakukan secara konservatif; jika API usage tidak melanggar kompatibilitas mundur (*backward compatibility*), sampel tidak dihapus.

### C. CODEEX: Penghapusan Panggilan Internal (*Internal Call Remover*)

Penghapusan panggilan internal dari kode pustaka adalah inti dari metodologi ini, memastikan sampel yang diekstraksi dapat dikompilasi dan diakses dari sisi klien.

1.  **Pra-pemrosesan:** CODEEX menggunakan **JDT** (*Java Development Tools*) yang lebih akurat daripada PPA. Nama paket pustaka dihapus, dan semua kelas paket diimpor secara eksplisit, yang mengungkapkan *internal usages* sebagai kesalahan kompilasi.
2.  **Remover ROI (Internal Usages):** Menghilangkan kode yang secara langsung memanggil elemen internal (privat/terproteksi) yang tidak dapat diakses klien. Terdapat 6 aturan (ROI1 hingga ROI6), mencakup penghapusan pernyataan, metode/konstruktor dengan parameter tipe internal, *super type* internal, *cast* yang tidak kompatibel, dan anonim/enumerasi yang bermasalah.
3.  **Remover ROM (Consequential Errors):** Menangani kesalahan kompilasi sekunder yang timbul setelah penghapusan kode internal. Terdapat 9 aturan (ROM1 hingga ROM9), termasuk penghapusan *catch clauses*, penghapusan variabel yang tidak dikenal, penghapusan *final modifiers*, dan pembuatan pernyataan *return* atau *initializer* nilai yang hilang.

CODEEX menerapkan *removers* ini berulang kali hingga semua kesalahan kompilasi hilang.

## 3. Detail Pengujian

### Dataset
*   **Pustaka:** $\mathbf{5}$ pustaka Java (accumulo, cassandra, karaf, lucene, poi).
*   **Data Internet:** Sampel dari SearchCode (dibatasi pada $\mathbf{20}$ halaman teratas per kelas API).
*   **Data Pustaka Lokal:** Kode sumber pustaka yang telah diolah oleh CODEEX.

### Baseline
Perbandingan dilakukan antara API usages yang diekstraksi dari dua sumber:
1.  **Kode Internet (SearchCode):** Sampel kode klien yang relevan dan terbaru.
2.  **Kode Pustaka Lokal (CODEEX):** Kode pustaka dengan *internal usages* yang telah dihapus.

### Metrik
Kami menganalisis *API usages* pada $\mathbf{3}$ granularitas:
1.  **Kelas API:** Jumlah kelas API unik yang dipanggil.
2.  **Metode API:** Jumlah metode API unik yang dipanggil.
3.  **Urutan Panggilan (Call Sequences):** Jumlah urutan panggilan unik yang diekstrak dari sampel. Urutan panggilan diekstrak menggunakan analisis statis ringan, mengabaikan kondisi percabangan.

Selain itu, dilakukan eksperimen terkontrol untuk RQ5, mengukur jumlah tugas pemrograman yang **diselesaikan** menggunakan kedua sumber.

$$API~Coverage~(\%R) = \frac{Real~Samples}{Class~Count} \times 100\%$$

Di mana $Real~Samples$ adalah jumlah kelas API dengan sampel yang relevan dan terbaru yang diekstrak, dan $Class~Count$ adalah total kelas API.

## 4. Hasil Eksperimen

### RQ1 & RQ2: Cakupan API

Hasil menunjukkan perbedaan besar dalam cakupan API:

| Name | Internet Code (Kelas API) | Library Code (Kelas API) | Library Code / Internet Code |
| :--- | :--- | :--- | :--- |
| **Total** | 1,019 (9.3%) | 4,209 (38.4%) | **4.0 kali** |
| Metode API (CCM/LCM) | 3,062 | 14,500 | **4.7 kali** |
| Urutan Panggilan (CCS/LCS) | 4,587 | 13,856 | **3.0 kali** |

**Temuan 1 (F1):** Rata-rata, SearchCode hanya dapat mengumpulkan sampel yang relevan dan terbaru untuk **9.3%** kelas API, yang menjelaskan mengapa pemrogram sering mengeluh kurangnya sampel.

**Temuan 2 (F2):** Sampel dari **kode pustaka** mencakup $\mathbf{4.0}$ kali lebih banyak kelas, $\mathbf{4.7}$ kali lebih banyak metode, dan $\mathbf{3.0}$ kali lebih banyak urutan panggilan dibandingkan kode Internet, menunjukkan kekayaan sumber daya yang belum dimanfaatkan.

### RQ3: Karakteristik Sampel

*   Distribusi sampel menunjukkan bahwa sebagian kecil kelas API populer memiliki sampel yang jauh lebih banyak dari kedua sumber.
*   **Temuan 3 (F3):** Urutan panggilan dari **kode pustaka** **kurang repetitif** (frekuensi median lebih rendah) dibandingkan kode Internet. Hal ini menyiratkan bahwa kode pustaka menawarkan lebih banyak *unique usages*, meskipun menantang untuk ditambang dengan teknik berbasis frekuensi.

### RQ4: Tumpang Tindih Penggunaan API

| Granularitas | % Common | % Internet Only | % Library Only | Implikasi |
| :--- | :--- | :--- | :--- | :--- |
| **Kelas API** | $\sim$90% | Kecil | Besar | Kode Pustaka mencakup hampir semua kelas API Internet. |
| **Metode API** | $\sim$80% | Sedang | Sangat Besar | Kode Pustaka mencakup sebagian besar metode API Internet. |
| **Urutan Panggilan** | $\sim$20% | Besar | Sangat Besar | Penggunaan API sangat berbeda; kedua sumber **saling melengkapi**. |

**Temuan 4 (F4):** Meskipun kelas API dan metode yang dipanggil oleh kedua sumber tumpang tindih secara tinggi, urutan panggilan mereka hanya tumpang tindih sekitar $\mathbf{20\%}$. Ini menunjukkan bahwa kedua sumber memberikan informasi penggunaan API yang unik dan **saling melengkapi**.

### RQ5: Tugas Pemrograman (Eksperimen Terkontrol)

Dalam eksperimen dengan $\mathbf{20}$ tugas pustaka $\mathbf{poi}$ yang diselesaikan oleh $\mathbf{4}$ mahasiswa PhD:

*   **Temuan 5 (F5):** Untuk kasus di mana kedua sumber dapat memberikan sampel, **tidak ada perbedaan signifikan** dalam jumlah tugas yang berhasil diselesaikan oleh pengembang.
*   Namun, sampel kode pustaka (CODEEX) **meliput lebih banyak kasus** dan membantu pengembang dalam $\mathbf{4}$ tugas yang tidak teratasi oleh sampel SearchCode (karena SearchCode gagal mengambil sampel yang berguna).

Hasil ini menunjukkan bahwa **kuantitas** penggunaan API yang lebih kaya saja (kode pustaka) **tidak cukup** untuk meningkatkan efektivitas bantuan jika pengembang harus **mengidentifikasi sampel yang berguna secara manual**. Hal ini menyoroti pentingnya teknik **rekomendasi kode** yang canggih.

## 5. Kesimpulan

Studi empiris pertama ini mengkonfirmasi dan mengukur potensi besar **kode pustaka lokal** sebagai sumber pembelajaran penggunaan API. Dengan menghilangkan *internal usages* menggunakan alat **CODEEX**, kami menemukan bahwa kode pustaka memiliki cakupan penggunaan API ($\mathbf{4}$ hingga $\mathbf{4.7}$ kali lebih banyak) dan keunikan urutan panggilan yang jauh lebih unggul dibandingkan dengan sampel kode klien dari mesin pencari kode Internet. Cakupan kode Internet yang rendah (hanya $\mathbf{9.3\%}$ kelas API) menjelaskan keluhan pengembang tentang sampel yang tidak memadai.

Meskipun kekayaan ini, eksperimen terkontrol menunjukkan bahwa menyediakan lebih banyak sampel API saja tidak secara signifikan meningkatkan penyelesaian tugas.

::: info Dampak Praktis
Hasil ini secara kuat memotivasi penelitian di masa depan untuk mengembangkan **teknik rekomendasi kode canggih** yang secara eksplisit dapat memanfaatkan dan **memperingkas** kekayaan penggunaan API dari kode pustaka. Karena kedua sumber (Internet dan Pustaka) saling melengkapi, alat di masa depan harus mengintegrasikan informasi dari keduanya untuk memberikan bantuan pemrograman yang lebih lengkap dan efektif.
:::