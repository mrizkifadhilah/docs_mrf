---
title: Review Paper - Code Search Survei Teknik-teknik Penemuan Kode
description: Rangkuman survei komprehensif 30 tahun penelitian tentang Code Search, tantangan, dan teknik-teknik yang digunakan (ACM Comput. Surv., 2023).
head:
  - - meta
    - name: keywords
      content: code search, code retrieval, survey, API, information retrieval, deep learning
---

# 045 - Code Search: A Survey of Techniques for Finding Code
Tautan (DOI) [https://doi.org/10.1145/3565971]

**Penulis:** **Luca Di Grazia** ᵃ, **Michael Pradel** ᵃ

**Afiliasi:**
* ᵃ Department of Computer Science, University of Stuttgart, Germany

**Kronologi:** Received: 17 Februari 2022 • Revised: 23 September 2022 • Accepted: 29 September 2022 • Available Online: Februari 2023

<a href="https://www.scimagojr.com/journalsearch.php?q=23038&tip=sid" target="_blank"><img src="https://www.scimagojr.com/journal_img.php?id=23038" alt="SCImago Journal & Country Rank" /></a>

| Resume Eksekutif |
| :--- |
| **Publikasi:**<br>• **Jurnal:** ACM Computing Surveys, Vol. 55, No. 11, Article 220 (2023)<br>• **Topik:** Survei komprehensif 30 tahun penelitian *code search*, mencakup jenis kueri, prapemrosesan, teknik pengindeksan/pengambilan (*retrieval*), pemeringkatan, dan studi empiris praktik *code search*.<br><br>**Masalah & Solusi:**<br>• **Masalah:** Jumlah kode sumber yang sangat besar (jutaan proyek di GitHub, dll.) membuat pengembang secara rutin mencari kode (untuk penggunaan ulang, pemahaman API, atau *bug fixing*). Volume pekerjaan yang ada menyulitkan peneliti baru memahami *state-of-the-art* dan tantangan dalam membangun mesin *code search* yang efektif dan efisien.<br>• **Solusi:** Menyediakan tinjauan sistematis dan komprehensif mengenai *code search* (109 makalah) berdasarkan komponen mesin pencari: **Kueri, Prapemrosesan Kueri, Pengindeksan/Pengambilan Kode, Pemeringkatan, dan Studi Empiris.** Tinjauan ini juga mengidentifikasi tantangan dan peluang penelitian di masa depan.<br><br>**Contoh Penerapan:**<br>• Pencarian kueri *free-form* ("read file line by line") atau kueri formal berbasis perilaku (*Input-Output Examples*) untuk mendapatkan *snippet* kode yang relevan dari korpus besar (seperti GitHub).<br><br>**Metodologi:**<br>• **Kerangka Kerja Mesin *Code Search*:** Memisahkan komponen menjadi fase **Offline** (Pengindeksan atau Pelatihan) dan fase **Online** (Kueri, Prapemrosesan & Ekspansi, Pengambilan, Pemeringkatan & Pemangkasan).<br>• **Taksonomi Kueri:** Membagi kueri menjadi **Informal** (*Free-form Queries*—paling umum), **Formal** (*Existing Programming Language, Custom Querying Language, Input-Output Examples*), dan **Hibrida**.<br>• **Teknik Pengambilan:** Mengelompokkan berdasarkan artefak yang diindeks (Kode Sumber/Biner, Bahasa Alami, Perilaku *Runtime*) dan representasi yang diekstrak (Elemen Individual, Urutan, Relasi antar Elemen), serta teknik pembandingan (Vektor Fitur, Pembelajaran Mesin, Pencocokan Graf, Pencocokan *Solver*).<br><br>**Temuan Kunci:**<br>1. **Kueri Dominan:** **Kueri *Free-form*** (*natural language*) adalah jenis kueri yang paling umum didukung karena **kemudahan penggunaan** dan **ekspresivitas tinggi** (38 pendekatan).<br>2. **Artefak Terindeks:** **Kode Sumber/Biner** adalah artefak yang paling sering diindeks.<br>3. **Representasi Kode:** Pendekatan modern cenderung menggunakan **Relasi antara Elemen Kode** (misalnya, Graf AST/DFG) dan **Urutan Elemen Kode** (misalnya, urutan panggilan API) untuk pengindeksan.<br>4. **Teknik Pengambilan:** Pendekatan historis menggunakan **Vektor Fitur** (TF-IDF, Lucene). Pendekatan terkini didominasi oleh **Model Pembelajaran Mesin** (*end-to-end neural learning*) yang memetakan kueri dan kode ke ruang vektor bersama (*joint vector space*).<br>5. **Studi Empiris:** *Code search* adalah salah satu aktivitas paling umum pengembang. Tujuan utamanya adalah **penggunaan ulang kode** (15%-34%) dan **pemahaman program** (14%-29%).<br><br>**Kontribusi Utama:**<br>• Memberikan tinjauan komprehensif pertama yang mencakup 30 tahun penelitian *code search*.<br>• Menyediakan taksonomi terperinci mengenai jenis kueri, teknik prapemrosesan, pengindeksan, dan pemeringkatan.<br>• Merangkum studi empiris tentang bagaimana pengembang berinteraksi dengan *code search* di dunia nyata.<br>• Mengidentifikasi tantangan terbuka (misalnya, *cross-language search*, pengindeksan perubahan kode) dan peluang riset di masa depan.<br><br>**Dampak:**<br>• Menjadi sumber daya penting bagi peneliti baru dan praktisi yang ingin memahami evolusi bidang *code search*, teknik-teknik utama yang digunakan, dan arah yang perlu dieksplorasi untuk kemajuan lebih lanjut. |

## 1. Pendahuluan & Masalah

Seiring dengan meningkatnya pentingnya perangkat lunak, jumlah kode sumber yang tersedia diproduksi dalam jumlah yang luar biasa besar (lebih dari 60 juta proyek baru di GitHub pada tahun 2020). Akibatnya, sebagian besar kode yang akan ditulis oleh pengembang memiliki kemiripan dengan kode yang sudah ada. Untuk memanfaatkan kode yang sudah ada dan menavigasi basis kode yang kompleks, pengembang rutin melakukan **pencarian kode (*code search*)**—suatu aktivitas penting untuk menemukan contoh kode yang dapat digunakan kembali, memahami penggunaan API, atau memperbaiki *bug*.

Mesin *code search* yang sukses harus menawarkan antarmuka kueri yang nyaman, menghasilkan hasil yang cocok dengan kueri, dan beroperasi secara efisien. Namun, *code search* memiliki tantangan unik: kode memiliki sintaks yang ditentukan secara formal dan semantik *runtime*, yang memungkinkan analisis struktural yang lebih dalam, namun juga memerlukan pemetaan antara kueri (seringkali bahasa alami) dan kode (bahasa pemrograman).

::: tip Solusi yang Diusulkan
Artikel ini menyajikan **survei komprehensif selama 30 tahun** penelitian tentang *code search*, menguraikan tantangan dan peluang. Struktur tinjauan ini mengikuti komponen logis mesin *code search*: Kueri, Prapemrosesan Kueri, Pengindeksan & Pengambilan, Pemeringkatan & Pemangkasan, dan Studi Empiris.
:::

## 2. Metodologi

Arsitektur mesin *code search* khas terdiri dari komponen *offline* (Pengindeksan atau Pelatihan) dan komponen *online* (Prapemrosesan Kueri, Pengambilan, dan Pemeringkatan Hasil).

### A. Kueri untuk Pencarian Kode
Kueri adalah ekspresi eksplisit dari niat pengguna. Kueri dikategorikan berdasarkan tiga tujuan: Kemudahan (*Ease*), Ekspresivitas (*Expressiveness*), dan Presisi (*Precision*).

1.  **Kueri *Free-form* (Informal):** Paling umum didukung (38 pendekatan). Kueri ini mudah dibuat dan sangat ekspresif (misalnya, "read file line by line"), tetapi dapat ambigu dan kurang presisi.
2.  **Kueri Berbasis Bahasa Pemrograman yang Ada (Formal):** Berupa *snippet* kode (mungkin dengan *holes* atau simbol pencocokan pola). Mudah dibuat karena pengembang sudah tahu bahasanya.
3.  **Bahasa Kueri Kustom (Formal):** Menawarkan presisi dan ekspresivitas tinggi (misalnya, predikat logika, Datalog, atau *semantic patch language*). Kekurangannya adalah pengguna harus mempelajari bahasa kueri baru.
4.  **Contoh *Input-Output* (Formal):** Mendefinisikan perilaku yang diinginkan melalui spesifikasi yang dapat dieksekusi (misalnya, input "17" menghasilkan "XVII"). Presisi tinggi, tetapi mungkin membutuhkan upaya untuk menyediakan contoh yang memadai.
5.  **Hibrida:** Menggabungkan kueri informal dan formal (misalnya, kata kunci bahasa alami + batasan logika).

### B. Prapemrosesan dan Ekspansi Kueri

Kueri awal mungkin tidak optimal karena ketidaktepatan bahasa alami atau ketidakcocokan kosakata (*vocabulary mismatch*). Teknik modifikasi kueri:

1.  **Antarmuka Pengguna:** Sebagian besar transparan (pengguna tidak sadar), namun ada yang **interaktif** (pengguna mereformulasi kueri berdasarkan rekomendasi atau umpan balik).
2.  **Informasi yang Digunakan:** Hasil pencarian awal, kesamaan istilah/pengenal (*identifier*), *dataset* NL/kode (misalnya, Stack Overflow, dokumentasi API), dan perubahan kode berulang (*recurring code changes*).
3.  **Teknik Modifikasi:**
    *   **Penimbangan Istilah (*Weigh*):** Memberi bobot lebih tinggi pada istilah yang relevan (misalnya, menggunakan algoritma *Page Rank*).
    *   **Penambahan/Penggantian Istilah (*Add or replace*):** Menambahkan sinonim atau istilah terkait API.
    *   **Pengangkatan ke Representasi yang Lebih Kaya (*Lift*):** Mengubah kueri menjadi representasi yang lebih kaya (misalnya, *Code Pattern Automata* atau *Action Relationship Graph*).

### C. Pengindeksan atau Pelatihan, Diikuti Pengambilan Kode

Pengindeksan/Pelatihan dan Pengambilan (*Retrieval*) adalah inti dari mesin *code search*.

1.  **Artefak yang Diindeks:** Paling umum adalah **Kode Sumber dan Kode Biner**. Juga diindeks: **Perilaku *Runtime*** (melalui *symbolic execution* atau *tracelets*) dan **Informasi Bahasa Alami** yang terkait dengan kode (komentar, pesan *commit*, dokumentasi API).
2.  **Representasi Informasi:**
    *   **Elemen Kode Individual:** Merepresentasikan kode sebagai kumpulan token (mengabaikan urutan).
    *   **Urutan Elemen Kode:** Mempertahankan informasi urutan (misalnya, urutan panggilan API yang diekstrak dari AST).
    *   **Relasi Antar Elemen Kode:** Representasi yang lebih kaya dalam bentuk graf (misalnya, AST, DFG, CFG, relasi warisan, atau panggilan metode).
3.  **Teknik Pembandingan Kueri dan Kode:**
    *   **Vektor Fitur (Algoritmik):** Menggunakan vektor Boolean, **TF-IDF**, atau Vektor Ruang Revisi (rVSM) dengan mesin pencari seperti Lucene.
    *   **Pembelajaran Berbasis (*Learning-based*):** Pendekatan *end-to-end* **Neural Learning** (Deep Learning) yang menyematkan kueri dan kode ke dalam **ruang vektor bersama** (*joint vector space*), menjadikan *code search* sebagai masalah *nearest neighbor* (misalnya, *CodeBERT*).
    *   **Pencocokan Berbasis Graf:** Mengubah kueri dan kode menjadi graf, lalu mencari kesamaan graf.
    *   **Pencocokan Berbasis *Solver***: Menggunakan *SMT Solver* untuk mencocokkan batasan perilaku yang diekstrak dari kode dengan kueri *input-output*.

## 3. Detail Pengujian

Studi ini adalah tinjauan literatur (survei) dan tidak menyajikan eksperimen baru; ia merangkum temuan dan metrik dari studi empiris dan teknis sebelumnya.

### Metrik Kinerja yang Digunakan dalam Penelitian
Penelitian yang disurvei menggunakan metrik pengambilan standar, termasuk **Cosine Similarity** (untuk model *learning-based*), **Hamming distance**, dan **Euclidean distance**. Metrik spesifik IR seperti yang digunakan oleh Lucene (kombinasi model Boolean dan *Vector Space*) juga umum.

### Metrik dalam Studi Empiris
Studi empiris yang disurvei mengukur efektivitas kueri (efektif jika pengguna mengunduh kode yang relevan) dan frekuensi reformulasi kueri.

## 4. Hasil Eksperimen

(Bagian ini merangkum temuan dari studi empiris dan teknis yang dibahas dalam survei.)

### A. Studi Empiris (*Code Search* dalam Praktik)

*   **Aktivitas Umum:** *Code search* adalah salah satu aktivitas paling umum pengembang (misalnya, 5 sesi pencarian/hari dengan 12 kueri harian di Google).
*   **Tujuan Pencarian:** Tiga tujuan utama: menemukan **contoh kode untuk digunakan kembali** (15%-34% pencarian), **pemahaman program** (14%-29%), dan **memahami dan memperbaiki *bug*** (10%-20%).
*   **Kueri:** Sebagian besar kueri kode pendek, meskipun ukuran bervariasi (rata-rata 1 istilah hingga 4.7 istilah). Kueri kode sering **direformulasi** dalam satu sesi pencarian.
*   **Efektivitas:** Efektivitas bervariasi (25% hingga 60%) tergantung jenis kueri. Mesin *code search* khusus lebih efektif untuk mencari subsistem, sementara mesin pencari web umum lebih baik untuk blok kode individu.

### B. Granularitas Kode yang Diambil

Sebagian besar pendekatan mengambil kode pada tingkat **Snippet** (fragmen beberapa baris) atau tingkat **Metode** (seluruh fungsi). Tingkat **Kelas** atau **Aplikasi/Pustaka** juga didukung, tetapi lebih jarang.

### C. Pemeringkatan dan Pemangkasan

*   **Pemeringkatan:** Paling umum menggunakan **jarak standar** (misalnya, *Cosine Similarity*) dari komponen pengambilan. Metode khusus mencakup penimbangan skor berdasarkan **konteks pengembang** (variabel, jenis, dan dependensi di sekitar kursor).
*   **Pemangkasan (*Pruning*):** Paling populer adalah pemangkasan berdasarkan **ambang batas kesamaan (*similarity threshold*)** dan **penggabungan hasil yang serupa** untuk menghilangkan redundansi.

## 5. Kesimpulan

Artikel ini menyajikan gambaran komprehensif tentang penelitian *code search* selama tiga dekade, mulai dari kueri *free-form* sederhana hingga model pembelajaran mendalam *end-to-end* yang kompleks. Bidang ini telah berkembang menjadi domain penelitian yang matang, dengan kontribusi signifikan pada praktik pengembangan perangkat lunak (misalnya, alat seperti Copilot). Meskipun ada kemajuan, tantangan besar tetap ada:

1.  **Skenario Penggunaan Tambahan:** Perlunya mendukung skenario baru seperti **pencarian perubahan kode** (DiffSearch) dan **pencarian lintas bahasa (*cross-language search*)**.
2.  **Kolaborasi Lintas Bidang:** Mengintegrasikan teknik yang berhasil dari **penyelesaian kode (*code completion*)** dan **deteksi klon (*clone detection*)** ke dalam mesin *code search*.
3.  **Pembelajaran Mendalam Lanjutan:** Mengadopsi model representasi kode yang semakin efektif (misalnya, model yang menggeneralisasi contoh-contoh yang dilihat selama pelatihan menjadi kode baru).
4.  **Penerapan di Praktik:** Mengatasi tantangan *deployment* (misalnya, pengindeksan ulang inkremental) dan meningkatkan antarmuka pengguna (*query-less search*, otomatisasi pertanyaan klarifikasi).
5.  **Benchmark Bersama:** Membangun *dataset* dan *benchmark* yang lebih realistis, berskala besar, dan terlindungi dari model *pre-trained* publik.

::: info Dampak Praktis
Meskipun *code search* sudah menjadi alat yang sangat penting dalam pekerjaan sehari-hari pengembang, mengatasi tantangan-tantangan yang tersisa (terutama dalam *cross-language search* dan integrasi DL yang lebih canggih) akan membuka era baru efisiensi dan penggunaan kembali kode dalam pengembangan perangkat lunak.
:::