---
title: Review Paper - Mesin Pencari Kode Generasi Berikutnya (LASSO)
description: Rangkuman paper tentang Mesin Pencari Kode Generasi Berikutnya melalui Analisis Dinamis Skala Besar (The Journal of Systems and Software, 2024).
head:
  - - meta
    - name: keywords
      content: Code Search, Software Reuse, Dynamic Analysis, Semantics, LASSO, Test-Driven Search, LSL
---

# 024 - Code search engines for the next generation
Tautan (DOI) [10.1016/j.jss.2024.112065](https://doi.org/10.1016/j.jss.2024.112065)

**Penulis:** **Marcus Kessel** ¹*, **Colin Atkinson** ¹

**Afiliasi:**
* ¹ University of Mannheim, 68159 Mannheim, Germany

**Kronologi:** Received: 6 December 2022 • Revised: 28 February 2024 • Accepted: 12 April 2024 • Available Online: 6 May 2024

<a href="https://www.scimagojr.com/journalsearch.php?q=19309&tip=sid" target="_blank"><img src="https://www.scimagojr.com/journal_img.php?id=19309" alt="SCImago Journal & Country Rank" /></a>

| Resume Eksekutif |
| :--- |
| **Publikasi:**<br>• **Jurnal:** The Journal of Systems and Software 215 (2024) 112065<br>• **Topik:** Mengatasi kelemahan mesin pencari kode (*Code Search Engines - CSE*) generasi saat ini, yang mengandalkan analisis statis, dengan melengkapinya menggunakan teknik analisis dinamis skala besar berbasis eksekusi (*test-driven*).<br><br>**Masalah & Solusi:**<br>• **Masalah:** CSE generasi saat ini, termasuk yang menggunakan teknik *big data* (NLP, ML), pada dasarnya adalah proses analisis **statis**. Analisis statis **tidak dapat menentukan properti dinamis** perangkat lunak (perilaku *run-time* atau semantik) karena *Rice's theorem*, yang secara langsung **menurunkan presisi dan *recall*** pencarian. CSE generasi pertama yang mencoba analisis dinamis (*Test-Driven Search - TDS*) gagal karena korpus kecil, skalabilitas buruk, dan *query language* yang kaku.<br>• **Solusi:** Mengusulkan **LASSO** (*Large-Scale Software Observatorium*), sebuah platform perangkat lunak yang **mengotomatiskan dan menyederhanakan analisis dinamis** (*observasi*) kode dalam skala besar. LASSO menyediakan layanan **LASSO TDS** (*Test-Driven Search*) sebagai layanan CSE generasi berikutnya yang menggabungkan properti dinamis (*behavior*) dan statis kode.<br><br>**Contoh Penerapan:**<br>• **Pencarian Komponen Perangkat Lunak Java:** LASSO TDS diterapkan untuk mencari dan membandingkan implementasi *class* Java dari korpus Maven Central berdasarkan perilaku *run-time* yang spesifik (*functional abstraction*), seperti *Queue* atau *Base64*.<br><br>**Metodologi:**<br>• **Platform LASSO:** Dibangun di atas arsitektur terdistribusi menggunakan **Apache Ignite** dan **DOCKER** (untuk *sandboxing* dan skalabilitas), dengan korpus yang dapat dieksekusi (*executable corpus*) dari Maven Central.<br>• **LSL (*LASSO Scripting Language*):** Bahasa *scripting* imperatif dan abstrak berbasis Groovy/Java yang memungkinkan pengguna mendefinisikan *pipeline* pencarian yang mengombinasikan langkah analisis statis (*LASSO Query Language - LQL*) dan dinamis (*Arena Execution*).<br>• **Sequence Sheet Notation (SSN) & SRM:** SSN adalah bahasa spesifikasi tes yang ringkas untuk menentukan urutan stimulasi. **SRM** (*Stimulus Response Matrix*) adalah struktur data terpusat yang menyimpan semua stimulasi, respons (*actuations*), dan pengukuran dinamis (*observational records*) dari banyak komponen dan tes.<br>• **Adaptasi Otomatis:** Mesin *adapter synthesis* menggunakan heuristik untuk menyesuaikan antarmuka komponen kandidat dengan antarmuka yang diharapkan oleh tes (*stimulus sheet*), meningkatkan *recall*.<br>• **S-TDS vs. R-TDS:** **S-TDS** (*Strict TDS*) menggunakan kriteria pencocokan fungsional yang ketat. **R-TDS** (*Relaxed TDS*) menganalisis *cluster* perilaku dalam SRM secara *offline* untuk melonggarkan kriteria pencocokan (misalnya, menerima *output* yang berbeda tetapi secara semantik setara), yang bertujuan meningkatkan *recall*.<br><br>**Temuan Kunci:**<br>1. **Peningkatan Presisi Relatif (RIP):** S-TDS (analisis dinamis ketat) meningkatkan presisi rata-rata sebesar $\mathbf{99.37}$ kali lipat dibandingkan pencarian tekstual IDS (*Interface-Driven Search*) yang bebas *clone*.<br>2. **Peningkatan Recall Relatif (RIR):** R-TDS (analisis dinamis longgar) meningkatkan *recall* rata-rata sekitar $\mathbf{4}$ kali lipat dibandingkan S-TDS, tanpa mengorbankan presisi.<br>3. **Kecepatan Pencarian:** Waktu pencarian rata-rata untuk 1000 kandidat adalah $\mathbf{3}$ menit $\mathbf{59}$ detik, menyoroti utilitas praktis platform terdistribusi ini.<br>4. **Korpus:** Korpus LASSO adalah repositori perangkat lunak yang dapat dieksekusi terbesar yang tersedia (184,464 *executable artifacts* dari Maven Central).<br><br>**Kontribusi Utama:**<br>• Mengembangkan **platform LASSO** yang menyatukan analisis dinamis dan statis skala besar.<br>• Mengusulkan **LSL** sebagai bahasa *query* dinamis untuk mendefinisikan *pipeline* pencarian yang dapat disesuaikan.<br>• Menunjukkan peningkatan presisi dan *recall* secara kuantitatif melalui implementasi S-TDS dan R-TDS.<br><br>**Dampak:**<br>• Memungkinkan CSE generasi berikutnya untuk membuat keputusan pencarian berdasarkan **perilaku *run-time* yang sebenarnya** dari kode, menghasilkan hasil yang jauh lebih andal dan dapat digunakan (meningkatkan *precision*, *recall*, dan kualitas *ranking*). |

## 1. Pendahuluan & Masalah

Mesin Pencari Kode (*Code Search Engines - CSE*) adalah platform utama untuk mendukung penggunaan kembali perangkat lunak, memungkinkan pengembang menemukan komponen mandiri yang sudah ada. Sejak gerakan *open source* pada pertengahan 2000-an, repositori kode telah mengalami pertumbuhan masif, yang mengubah masalah CSE dari mengisi basis data menjadi mengelola *big data* kode. Oleh karena itu, riset CSE saat ini banyak berfokus pada penerapan teknik ilmu data, seperti Pemrosesan Bahasa Alami (*NLP*) dan *Machine Learning*.

Namun, baik pendekatan *syntax-based* generasi pertama maupun teknik *big data* saat ini pada dasarnya adalah proses **analisis statis**. Analisis statis tidak dapat menangkap properti dinamis perangkat lunak, seperti **perilaku *run-time* (semantik)** dan kinerja, yang terikat pada *Rice's theorem*—sebuah prinsip mendasar yang menyatakan bahwa properti semantik non-trivial dari program tidak dapat diputuskan secara algoritmik umum. Ketergantungan pada analisis statis ini menyebabkan **penurunan presisi dan *recall*** CSE karena meningkatnya *false positives* (kode yang salah menyiratkan semantik yang benar) dan *false negatives* (kode yang tidak disertakan meskipun memiliki semantik yang benar).

CSE generasi awal yang mencoba mengatasi hal ini dengan memasukkan observasi dinamis (*Test-Driven Search - TDS*) menderita kelemahan utama:
*   Korpus yang kecil dan dikurasi secara manual.
*   Skalabilitas dan kinerja yang buruk.
*   Bahasa *query* yang kaku dan spesifik platform.
*   Kemampuan adaptasi antarmuka yang terbatas.

::: tip Solusi yang Diusulkan
Untuk mengatasi kelemahan analisis statis dan mengatasi masalah TDS generasi pertama, diusulkan **LASSO** (*Large-Scale Software Observatorium*) dan layanan **LASSO TDS**. LASSO adalah platform perangkat lunak baru yang dirancang untuk **menskalakan dan mengotomatisasi analisis dinamis** kode, memungkinkan penggabungan properti dinamis (*behavior*) dengan properti statis untuk meningkatkan kualitas dan kegunaan hasil pencarian kode secara signifikan.
:::

## 2. Metodologi

LASSO menyediakan mekanisme dasar untuk TDS klasik dan mendukung serangkaian *use case* pencarian kode yang lebih kaya, berfokus pada penggunaan kembali komponen.

### A. Arsitektur dan Korpus yang Dapat Dieksekusi

Platform LASSO dibangun di atas **arsitektur terdistribusi** menggunakan solusi *clustering* **Apache Ignite** dan diimplementasikan dengan Java.
1.  **Korpus yang Dapat Dieksekusi:** Korpus LASSO dikurasi secara otomatis, terutama dari **Maven Central** (termasuk 184,464 *executable artifacts* Java), dengan menyintesis *build script* menggunakan ekosistem Maven, mengatasi masalah korpus kecil pada TDS generasi pertama.
2.  **Sandboxing:** Eksekusi komponen kode asing diisolasi dalam lingkungan *sandbox* yang aman, diwujudkan menggunakan **DOCKER** *containerization*, memungkinkan kontrol terperinci atas sumber daya dan lingkungan eksekusi (*e.g.*, versi Java).

### B. Sequence Sheet Notation (SSN) dan Stimulus Response Matrices (SRM)

Untuk mengatasi masalah bahasa definisi tes yang verbose, LASSO memperkenalkan:
1.  **SSN:** Notasi lembar urutan baru yang ringkas dan tidak *Turing-complete* (menghilangkan *control flow*) untuk menentukan urutan stimulasi. Ini memastikan urutan pemanggilan metode yang tepat diketahui di awal.
2.  **SRM:** Struktur data multidimensi, esensial untuk analisis skala besar, yang menyimpan berbagai *Actuation Sheets* (hasil eksekusi *stimulus sheet*). Setiap sel SRM merekam *stimuli*, *responses*, dan *observational records* lainnya (termasuk metrik dinamis) untuk setiap komponen yang diuji.

### C. LASSO Scripting Language (LSL)

LSL adalah bahasa *scripting* imperatif, domain-spesifik, dan abstrak yang merupakan ekstensi dari bahasa Groovy. LSL berfungsi sebagai "perekat" yang memungkinkan pengguna mendefinisikan *Component Processing Pipelines* yang menggabungkan berbagai *Action* dalam urutan logis.
1.  **LQL (*LASSO Query Language*):** Bahasa deklaratif berbasis *UML-like syntax* yang digunakan dalam aksi LSL untuk *Interface-Driven Search* (IDS) awal.
2.  **Pipeline Imperatif:** LSL memungkinkan pengguna merangkai aksi seperti `select` (seleksi tekstual/statis), `rejectClones` (penolakan *clone*), `filter` (eksekusi *arena*/dinamis), dan `rank` (pemeringkatan). Ini memungkinkan kustomisasi total, mengatasi batasan *query language* deklaratif yang kaku.

### D. Adaptasi Antarmuka Otomatis dan Arena Execution

1.  **Adapter Synthesis:** Untuk meningkatkan *recall*, mesin *adapter synthesis* (*run-time*) menggunakan heuristik berbasis *type hierarchy*, *casting*, *switching parameter position*, dan *prioritization schema* untuk secara otomatis menyesuaikan antarmuka komponen yang diambil secara tekstual agar dapat dipanggil oleh *stimulus sheet*.
2.  **Arena:** Komponen eksekusi utama yang membagi tugas pengujian ke *worker nodes* dalam *cluster* (**vertikal dan horizontal scaling**). Arena melakukan *adaptation* dan *execution* SM untuk menghasilkan SRM.

### E. TDS Generasi Berikutnya: S-TDS dan R-TDS

LASSO TDS diimplementasikan menggunakan *pipeline* LSL untuk menyediakan dua varian:
1.  **S-TDS (*Strict TDS*):** Menerapkan kriteria pencocokan perilaku yang ketat (semua *output* harus persis sama dengan yang diharapkan) untuk meningkatkan presisi.
2.  **R-TDS (*Relaxed TDS*):** Menganalisis SRM secara *offline* (menggunakan alat analitik data eksternal, *e.g.*, R) untuk mengidentifikasi *cluster* respons yang berbeda tetapi secara fungsional setara (misalnya, *error handling* yang berbeda). Varian ini bertujuan untuk meningkatkan *recall* tanpa mengorbankan presisi S-TDS.

## 3. Detail Pengujian

### Dataset
*   **Korpus:** *Snapshot* **Maven Central** (Januari 2023) yang telah dikurasi dan dapat dieksekusi.
*   **Search Problems:** $\mathbf{20}$ abstraksi fungsional *non-trivial* dan *real-world* (misalnya, *Queue*, *Base64*, *Matrix*, *SHA256*).

### Baseline
Karena TDS generasi pertama sudah tidak tersedia, perbandingan dilakukan secara relatif terhadap:
1.  **IDS (*Interface-Driven Search*):** Langkah seleksi tekstual awal, diasumsikan sebagai *baseline* pencarian statis.
2.  **S-TDS (*Strict TDS*):** Implementasi TDS klasik (menggunakan LASSO TDS).

### Metrik Evaluasi
Metrik diestimasi secara relatif, karena tidak ada *ground truth* eksekusi yang komprehensif.

1.  **Peningkatan Presisi Relatif (RIP)** S-TDS atas IDS:
    $$ \mathbf{RIP}=\frac{C_{IDS}}{C_{S-TDS}} $$
    Di mana $C_{IDS}$ adalah set kandidat bebas *clone* yang dicocokkan oleh IDS, dan $C_{S-TDS}$ adalah set kandidat yang dicocokkan oleh S-TDS (dianggap sebagai *true positives*).

2.  **Peningkatan Recall Relatif (RIR)** R-TDS atas S-TDS:
    $$ \mathbf{RIR}=\frac{C_{R-TDS}}{C_{S-TDS}} $$
    Di mana $C_{R-TDS}$ adalah set kandidat yang dicocokkan oleh R-TDS.

Metrik Tambahan: Waktu pencarian, jumlah *clone* yang ditolak, dan karakterisasi metrik dinamis (*line count* dan *cyclomatic complexity* JaCoCo).

## 4. Hasil Eksperimen

### Waktu Pencarian
Waktu pencarian rata-rata untuk 20 masalah (dengan $N=1000$ kandidat tekstual) adalah $\mathbf{3}$ menit $\mathbf{59}$ detik, yang menunjukkan kepraktisan platform LASSO yang terdistribusi.

### Peningkatan Presisi dan Recall Relatif

| Metrik | Nilai Rata-Rata | Interpretasi |
| :--- | :--- | :--- |
| **RIP (S-TDS vs. IDS)** | $\mathbf{99.37}$ | S-TDS secara rata-rata $\mathbf{99.37}$ kali lebih akurat dalam mengidentifikasi *true positives* daripada IDS bebas *clone* (mengurangi *false positives*). |
| **RIR (R-TDS vs. S-TDS)** | $\mathbf{4.00}$ | R-TDS secara rata-rata meningkatkan *recall* sebesar $\mathbf{4}$ kali lipat dibandingkan S-TDS, dengan menerima *output* yang berbeda tetapi setara secara semantik. |

**Analisis:**
*   **Presisi:** Analisis dinamis S-TDS secara dramatis membersihkan hasil IDS yang didominasi oleh *false positives* (hanya berdasarkan nama), memvalidasi hipotesis utama bahwa perilaku *run-time* sangat penting untuk presisi.
*   **Recall:** R-TDS secara signifikan meningkatkan *recall* dengan fleksibilitasnya dalam menerima variasi perilaku yang setara secara fungsional (misalnya, dalam *error handling* atau *formatting output*), tanpa mengorbankan peningkatan presisi S-TDS.

### Karakterisasi Komponen Perangkat Lunak

*   Rata-rata $\mathbf{430}$ *clone* diidentifikasi dan dihapus dari setiap $N=1000$ kandidat IDS.
*   Rata-rata $\mathbf{89}$ implementasi *class* ditemukan setara secara fungsional oleh **S-TDS**, dan $\mathbf{113}$ oleh **R-TDS** dari rata-rata $\approx \mathbf{570}$ kandidat bebas *clone*.
*   Metrik dinamis (diperoleh melalui JaCoCo saat eksekusi) menunjukkan variabilitas yang besar dalam ukuran dan kompleksitas implementasi yang cocok, menggarisbawahi **keragaman** hasil yang dikembalikan.

## 5. Kesimpulan

Kelemahan utama CSE generasi saat ini adalah ketergantungan eksklusif pada properti statis. Platform **LASSO** dan layanan **LASSO TDS** yang dibangun di atasnya mengatasi kelemahan ini dengan memperkenalkan kemampuan **analisis dinamis skala besar**, memungkinkan penilaian semantik berdasarkan **perilaku *run-time*** yang sebenarnya.

Studi yang disajikan memberikan bukti awal bahwa LASSO TDS secara substansial dapat meningkatkan presisi (melalui **S-TDS** yang ketat) dan *recall* (melalui **R-TDS** yang longgar) dibandingkan dengan strategi pencarian statis klasik. LASSO TDS mencapai hal ini dengan **mengotomatisasi kurasi korpus** yang dapat dieksekusi, menggunakan bahasa *scripting* yang abstrak (**LSL**) untuk *pipeline* pencarian yang dapat disesuaikan, dan teknologi **adaptasi antarmuka** untuk memaksimalkan kandidat yang dapat diuji.

::: info Dampak Praktis
LASSO TDS berpotensi mendefinisikan **CSE generasi berikutnya** dengan menyediakan layanan pencarian yang lebih **andal dan dapat digunakan**. Dengan menggabungkan metrik statis dengan metrik dinamis (*e.g.*, waktu eksekusi, penggunaan sumber daya), dan memungkinkan perbandingan perilaku yang kompleks melalui **SRM**, LASSO memungkinkan pengembang membuat keputusan penggunaan kembali yang lebih terinformasi dan dapat diandalkan, secara efektif meningkatkan kualitas *ranking* dan transparansi hasil pencarian.
:::