---
title: Review Paper - Konstruksi Kode Linear Punctured Biner dan Metode Pendukung Pencarian Kode Terbaik
description: Rangkuman paper tentang algoritma konstruksi kode linear punctured dan metode pendukung untuk mencari kode terbaik dengan jarak minimum terbesar (IEICE TRANS. FUNDAMENTALS, 2022).
head:
  - - meta
    - name: keywords
      content: best code, modified code, linear code, weight distribution, minimum distance, punctured code, k-sparse algorithm
---

# 070 - A Construction of Binary Punctured Linear Codes and A Supporting Method for Best Code Search
Tautan (DOI) [https://doi.org/10.1587/transfun.2021TAP0007]

**Penulis:** **Takuya OHARA** $^{a)}$, **Makoto TAKITA** $^{a,b}$, **Masakatu MORII** $^{a}$

**Afiliasi:**
* $^{a}$ Graduate School of Engineering, Kobe University, Kobe-shi, 657-8501 Japan
* $^{b}$ School of Social Information Science, University of Hyogo, Kobe-shi, 651-2197 Japan

**Kronologi:** Received: 19 Februari 2021 • Revised: 18 Juni 2021 • Accepted: 14 September 2021 • Available Online: Maret 2022

<a href="https://www.scimagojr.com/journalsearch.php?q=26076&tip=sid" target="_blank"><img src="https://www.scimagojr.com/journal_img.php?id=26076" alt="SCImago Journal & Country Rank" /></a>

| Resume Eksekutif |
| :--- |
| **Publikasi:**<br>• **Jurnal:** IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences, Vol. E105-A, No. 3 (2022)<br>• **Topik:** Pembangunan **kode terbaik** (*best codes*)—kode linear $(n, k)$ dengan jarak Hamming minimum ($d$) terbesar yang diketahui—melalui modifikasi *punctured codes* dan metode pendukung pencarian kode.<br><br>**Masalah & Solusi:**<br>• **Masalah 1:** Mencari *best code* dengan jarak minimum d terbesar untuk $(n, k)$ tertentu memerlukan pemilihan bit yang akan dimodifikasi (dihapus) dari jumlah kombinasi yang sangat besar.<br>• **Masalah 2:** Kode siklik yang dimodifikasi (seperti *punctured codes*) kehilangan struktur sikliknya, sehingga algoritma efisien seperti **k-sparse algorithm** tidak dapat digunakan untuk memverifikasi jarak minimumnya.<br>• **Solusi 1 (Konstruksi):** Mendefinisikan **fungsi evaluasi baru ($eval_2$)** berdasarkan *local weight distribution* untuk menentukan bit cek mana yang akan dihapus (*punctured*) menggunakan metode *backtracking* (Algoritma 4) untuk mengurangi ruang pencarian secara signifikan.<br>• **Solusi 2 (Pendukung Pencarian):** Mengusulkan **fungsi evaluasi gabungan $E(n,k)$** berdasarkan perbedaan jarak minimum dengan kode tetangga dan metode *least-squares* untuk memprediksi target $(n, k)$ yang paling mungkin untuk konstruksi kode terbaik.<br>• **Solusi 3 (Verifikasi):** Mengembangkan **Extended k-sparse algorithm** yang dapat digunakan untuk menurunkan bobot minimum (*minimum weight*) kode siklik yang dimodifikasi (*punctured* dan *shortened codes*).<br><br>**Contoh Penerapan:**<br>• Menggunakan kode BCH biner dan kode BCH *shortened* sebagai kode asli.<br>• **167 kode terbaik baru** berhasil dibangun dan diverifikasi (27 kode baru dari algoritma *punctured*, 112 kode baru dari modifikasi selanjutnya, dan 28 kode baru dari metode pendukung pencarian).<br>• Kode-kode yang dibangun mencakup kode dengan parameter $(n, k, d)$ seperti $(112, 27, 33)$, $(213, 30, 73)$, dan berbagai kode modifikasi dari BCH $(255, 45, 87)$ dan $(255, 47, 85)$.<br><br>**Metodologi:**<br>• **Fungsi Evaluasi $eval_2$:** Didefinisikan menggunakan *local weight distribution* (bobot $< d'+m$), yang lebih cepat dihitung daripada fungsi *Zwanzger* yang memerlukan distribusi bobot penuh.<br>$$eval_2(V'_{j-1}) = \sum_{i=1}^{d'+m-(j+1)} A_{d'+m-(j+i)}$$<br>• **Algoritma Konstruksi (Algoritma 4):** Menggunakan $eval_2$ dalam metode *backtracking* untuk memilih $m$ bit *puncturing* yang meminimalkan kemunculan *codeword* berbobot rendah.<br>• **Extended k-sparse algorithm (Algoritma 2 & 3):** Mengadaptasi algoritma *k-sparse* untuk menghitung $A_{w_{min}}$ (*minimum weight codewords*) pada *punctured cyclic codes* dan *shortened cyclic codes*, memungkinkan verifikasi efisien tanpa *exhaustive search*.<br>• **Fungsi Pendukung $E(n,k)$:** Gabungan dari empat metrik evaluasi: $e_1$ dan $e_2$ (perbedaan d dengan kode tetangga) dan $e_3$ dan $e_4$ (perbedaan d dengan kurva perkiraan *least-squares*).<br><br>**Temuan Kunci:**<br>1. **Kode Terbaik Baru:** Berhasil mengkonstruksi total 167 kode terbaik biner baru, membuktikan efektivitas algoritma *puncturing* yang diusulkan dan metode pencarian yang dibantu evaluasi.<br>2. **Verifikasi Cepat:** *Extended k-sparse algorithm* berhasil digunakan untuk memverifikasi bobot minimum kode yang baru dibangun, mengatasi masalah hilangnya struktur siklik.<br>3. **Keunggulan $eval_2$:** Fungsi evaluasi yang baru ($eval_2$) memungkinkan pemilihan bit penghapusan yang efisien, membuat konstruksi *punctured codes* dengan jarak minimum yang besar menjadi mungkin.<br><br>**Kontribusi Utama:**<br>• Mengusulkan algoritma konstruksi kode linear *punctured* berbasis fungsi evaluasi bobot lokal ($eval_2$) dan metode *backtracking*.<br>• Mengusulkan metode pendukung evaluasi $(n,k)$ target yang paling menjanjikan untuk mencari *best code* ($E(n,k)$).<br>• Mengembangkan *Extended k-sparse algorithm* untuk verifikasi cepat bobot minimum kode siklik yang dimodifikasi (*punctured* dan *shortened*).<br><br>**Dampak:**<br>• Kontribusi signifikan pada teori pengkodean dengan menemukan sejumlah besar *best codes* baru, yang meningkatkan rasio pengkodean ($R=k/n$) dan kapabilitas koreksi kesalahan dalam komunikasi dan penyimpanan data. |

## 1. Pendahuluan & Masalah

Teori pengkodean bertujuan untuk membangun kode koreksi kesalahan yang memiliki **rasio pengkodean ($R=k/n$) yang tinggi** (redundansi rendah) dan **kapabilitas koreksi kesalahan yang besar** (jarak Hamming minimum $d$ yang besar). Kode yang memiliki jarak minimum $d$ terbesar yang ditemukan sejauh ini untuk panjang kode $n$ dan panjang informasi $k$ yang sama disebut **kode terbaik** (*best code*). Meskipun *best codes* dicatat dalam basis data Markus Grassl, jarak minimum banyak kode masih belum mencapai batas atas teoretis.

Salah satu cara utama untuk membangun kode terbaik adalah melalui **modifikasi kode**, termasuk *shortened codes* (menghilangkan bit informasi), *extended codes* (menambah bit cek), dan **punctured codes** (menghilangkan bit cek). Fokus paper ini adalah pada *punctured codes*.

Modifikasi *punctured codes* melibatkan penghapusan $m$ bit cek dari total $n-k$ bit. Karena jumlah kombinasinya sangat besar, diperlukan metode efisien untuk memilih bit yang akan dihapus agar pengurangan jarak minimumnya ($d$) sekecil mungkin.

::: tip Solusi yang Diusulkan
Paper ini mengusulkan: (1) **Algoritma konstruksi kode linear *punctured*** yang menggunakan **fungsi evaluasi baru ($eval_2$)** berdasarkan *local weight distribution* dan metode *backtracking* untuk memilih bit yang akan dihapus. (2) **Metode pendukung pencarian** (fungsi $E(n,k)$) untuk memprediksi target $(n, k)$ yang paling mungkin untuk konstruksi kode terbaik. (3) **Extended k-sparse algorithm** untuk verifikasi cepat bobot minimum kode siklik yang dimodifikasi.
:::

## 2. Metodologi

Metodologi ini mencakup tiga pilar: konstruksi kode (memilih bit yang akan dihapus), dukungan pencarian (memilih $(n, k)$ target), dan verifikasi bobot minimum.

### A. Algoritma Konstruksi Kode Punctured

Karena fungsi evaluasi *Zwanzger* ($eval_1$) memerlukan seluruh distribusi bobot, yang sulit didapatkan untuk kode dengan panjang informasi $k$ besar, sebuah fungsi evaluasi baru ($eval_2$) didefinisikan.

1.  **Fungsi Evaluasi $eval_2$:** Fungsi ini hanya mempertimbangkan *codeword* yang bobotnya kurang dari $d' + m$, di mana $d'$ adalah jarak minimum yang ditargetkan dan $m$ adalah jumlah bit yang dihapus.
    $$eval_2(V'_{j-1}) = \sum_{i=1}^{d'+m-(j+1)} A_{d'+m-(j+i)}$$
    $A_w$ adalah jumlah *codeword* berbobot $w$. Nilai $eval_2$ yang lebih kecil menunjukkan peluang yang lebih baik untuk mencapai jarak $d'$ setelah penghapusan $j$ bit. *Codeword* berbobot rendah ini diperoleh melalui *k-sparse algorithm* (atau *Extended k-sparse*).
2.  **Algoritma Konstruksi (Algoritma 4):** Algoritma ini menggunakan metode **backtracking** (dengan $b$ kandidat terbaik di setiap langkah penghapusan) yang dipandu oleh $eval_2$ untuk secara efisien mencari kombinasi $m$ bit yang akan dihapus. Ini secara efektif mengurangi ruang pencarian dari $\binom{n-k}{m}$ menjadi $b^m$.

### B. Metode Pendukung Pencarian Kode Terbaik

Metode ini mengusulkan fungsi gabungan $E(n,k)$ untuk memprioritaskan pasangan $(n, k)$ yang paling mungkin menghasilkan kode terbaik baru.
$$E(n,k)=e_{1}(n,k)+e_{2}(n,k)+e_{3}(n,k)+e_{4}(n,k)$$

1.  **Evaluasi Jarak Tetangga ($e_1, e_2$):** Mengukur perbedaan jarak minimum dengan kode tetangga di basis data.
    $$e_1(n,k) = d(n+1,k) - d(n,k)$$
    $$e_2(n,k) = d(n, k-1) - d(n,k)$$
    Perbedaan yang besar menunjukkan adanya ruang untuk peningkatan $d(n,k)$.
2.  **Evaluasi Metode *Least-Squares* ($e_3, e_4$):** Mengukur perbedaan antara jarak minimum yang ada $d(n,k)$ dengan kurva perkiraan kuadratik yang dibuat menggunakan metode *least-squares*.
    $$e_3(n,k) = f_k(n) - d(n,k)$$
    $$e_4(n,k) = f_n(k) - d(n,k)$$
    Di sini $f_k(n)$ adalah kurva perkiraan $d$ terhadap $n$ (dengan $k$ konstan), dan $f_n(k)$ adalah $d$ terhadap $k$ (dengan $n$ konstan).

### C. Extended k-sparse Algorithm

Untuk mengatasi masalah hilangnya struktur siklik ketika kode dimodifikasi, *k-sparse algorithm* diperluas.

1.  **Kode Punctured (Algoritma 2):** Algoritma ini membatasi pencarian *codeword* asli $(c)$ yang bobotnya berada dalam rentang $d$ hingga $w_{min}+m$, dan menghitung bobot *codeword* setelah penghapusan $m$ bit cek ($c'$). Ini digunakan untuk memverifikasi $d_{min}$ kode yang baru dibangun.
2.  **Kode Shortened (Algoritma 3):** Algoritma ini memverifikasi bahwa bit informasi yang dihapus semuanya "0". Ini digunakan ketika *shortened BCH codes* digunakan sebagai kode asli.

## 3. Detail Pengujian

### Original Codes
*   Kode BCH biner dan *shortened BCH codes* digunakan sebagai kode asli untuk modifikasi.
*   Empat kode BCH utama yang digunakan adalah $(127, 29, 43)$, $(233, 30, 88)$, $(255, 45, 87)$, dan $(255, 47, 85)$.

### Metrik Evaluasi
*   **Jarak Minimum ($d$):** Kapabilitas koreksi kesalahan kode. Targetnya adalah memaksimalkan $d$.
*   **Fungsi Evaluasi $E(n,k)$:** Digunakan untuk menilai potensi pencarian.
*   **Metode Verifikasi:** Jarak minimum kode yang baru ditemukan dijamin dengan menghitung $A_{w_{min}}$ menggunakan **Extended k-sparse algorithm** (Algoritma 2).

### Algoritma Puncturing
*   Algoritma 4 (konstruksi *punctured codes*) digunakan.
*   Metode *backtracking* (Algorithm 4) membatasi jumlah kandidat yang dicoba ($b^m$) untuk mengurangi kompleksitas komputasi yang tinggi.

## 4. Hasil Eksperimen

### A. Kode Terbaik Baru yang Ditemukan
*   Algoritma konstruksi *punctured codes* (Algoritma 4) berhasil mengkonstruksi **27 kode terbaik baru**.
*   Dengan memodifikasi lebih lanjut 27 kode ini (melalui *shortening* dan *extending*), ditemukan **112 kode terbaik baru tambahan**.
*   Menggunakan fungsi pendukung pencarian **$E(n,k)$** untuk menargetkan $(n,k)$ yang paling menjanjikan, ditemukan **28 kode terbaik baru tambahan**.
*   **Total Kode Terbaik Baru yang Ditemukan:** **167** kode terbaik baru.

### B. Analisis Contoh Konstruksi

*   **Punctured Code:** Misalnya, kode $(112, 27, 33)$ dibangun dengan menghapus 13 bit cek dari kode BCH $(125, 27, 43)$. Meskipun pengurangan jarak maksimum yang diharapkan adalah 13, jarak minimumnya berkurang lebih sedikit, yaitu $\mathbf{10}$ (dari $43 \rightarrow 33$).
*   **Extending Code:** Jika kode terbaik baru memiliki jarak $d$ ganjil (misalnya $(213, 30, 73)$), *1-bit extended code* dapat meningkatkan jarak minimumnya sebesar 1, menghasilkan kode $(214, 30, 74)$, yang juga merupakan *best code* baru.

### C. Verifikasi

Bobot minimum dari semua 167 kode terbaik baru yang ditemukan diverifikasi menggunakan **Extended k-sparse algorithm** yang diusulkan, yang menunjukkan bahwa metode ini secara efektif mengatasi tantangan verifikasi bobot kode siklik yang dimodifikasi.

## 5. Kesimpulan

Paper ini memberikan kontribusi yang signifikan pada teori pengkodean dengan mengusulkan algoritma konstruksi kode linear *punctured* dan metode pendukung untuk mencari *best codes* biner. Dengan mendefinisikan fungsi evaluasi yang efisien ($eval_2$) dan mengintegrasikannya dengan metode *backtracking*, serta mengembangkan *Extended k-sparse algorithm* untuk verifikasi cepat, para peneliti berhasil mengkonstruksi total **167 kode terbaik baru** dengan kapabilitas koreksi kesalahan yang lebih besar.

::: info Dampak Praktis
Penemuan 167 kode terbaik baru ini secara langsung meningkatkan batas bawah yang diketahui dari jarak minimum untuk banyak parameter $(n, k)$ dalam basis data kode, yang merupakan kunci untuk meningkatkan **keandalan informasi** dan **efisiensi transmisi** dalam aplikasi praktis seperti komunikasi nirkabel dan penyimpanan data.
:::