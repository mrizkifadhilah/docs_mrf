---
title: Review Paper - Pencarian Kode Cerdas untuk Edge Software
description: Rangkuman paper tentang Pendekatan Hibrida Multi-Representasi untuk Pencarian Kode (Journal of Cloud Computing, 2024).
head:
  - - meta
    - name: keywords
      content: code search, edge computing, program graph, mixed graphs, TAMG, multi-modal, deep learning
---

# 079 - Intelligent code search aids edge software development
Tautan (DOI) [10.1186/s13677-024-00629-5](https://doi.org/10.1186/s13677-024-00629-5)

**Penulis:** **Fanlong Zhang** ¹, **Mengcheng Li** ¹, **Heng Wu** ²* dan **Tao Wu** ³*

**Afiliasi:**
* ¹ School of Computer Science and Technology, Guangdong University of Technology, Guangzhou 510006, China
* ² School of Automation, Guangdong University of Technology, Guangzhou 510006, China
* ³ Guangdong Provincial Corps Hospital of the Chinese People's Armed Police Forces, Guangzhou 510507, China

**Kronologi:** Received: 14 December 2023 • Accepted: 9 March 2024 • Available Online: 01 April 2024

<a href="https://www.scimagojr.com/journalsearch.php?q=21100383744&tip=sid" target="_blank"><img src="https://www.scimagojr.com/journal_img.php?id=21100383744" alt="SCImago Journal & Country Rank" /></a>

| Resume Eksekutif |
| :--- |
| **Publikasi:**<br>• **Jurnal:** Journal of Cloud Computing: Advances, Systems and Applications 13 (2024) 78<br>• **Topik:** Pemanfaatan representasi program ganda, khususnya *Mixed Graphs*, untuk meningkatkan *code search* dalam pengembangan *edge software* berbasis multimedia.<br><br>**Masalah & Solusi:**<br>• **Masalah:** (1) Kurangnya studi empiris yang efektif menggunakan representasi *graph* (seperti CFG dan PDG) untuk *code search* dalam bahasa Java. (2) Kurangnya studi empiris sistematis mengenai kontribusi relatif dari berbagai representasi program (Token, AST, Graph, Method Name, API).<br>• **Solusi:** Mengusulkan pendekatan hibrida **TAMG** (*Token, AST, and Mixed Graphs*) yang menangkap dan menggabungkan fitur dari Token, AST, dan *Mixed Graphs* (CFG + PDG) menggunakan Jaringan Saraf Dalam (*Deep Neural Networks*).<br><br>**Contoh Penerapan:**<br>• **Pengembangan Edge Software:** Menyediakan mekanisme pencarian kode cerdas yang dapat diandalkan untuk mempercepat konstruksi infrastruktur *edge software* yang dibutuhkan oleh aplikasi multimedia yang berkembang pesat (seperti *video streaming* dan *game*).<br><br>**Metodologi:**<br>• **TAMG:** Arsitektur *multi-modal* yang menggunakan *Long Short-Term Memory* (LSTM) untuk Token, *Tree-based* LSTM untuk AST, dan *Gated Graph Neural Networks* (GGNN) untuk *Mixed Graphs*. Semua modalitas menggunakan mekanisme *Attention* dan digabungkan melalui *fusion layer* (*concatenation*) untuk mendapatkan representasi kode akhir.<br>• **Representasi Kunci:** Representasi *Mixed Graph* (Mix) untuk Java, yang menggabungkan *Control Flow Graph* (CFG) dan *Program Dependence Graph* (PDG).<br><br>**Temuan Kunci:**<br>1. **Kinerja Terbaik:** Pendekatan hibrida TAMG+Mix mencapai kinerja terbaik (R@1 dengan **37.0%** dan MRR dengan **47.4%**), melampaui *baseline* seperti DeepCS dan MMAN.<br>2. **Kontribusi Representasi:** Representasi **Token** memiliki kontribusi paling signifikan. *Mixed Graph* (CFG+PDG) menunjukkan efek positif terbaik di antara modalitas *graph* (Mix R@1: 10.6% pada modalitas tunggal). Direkomendasikan untuk mempertahankan Token, AST, dan *Mixed Graph* saat membangun model.<br>3. **Efek Graph:** Representasi *graph* memiliki efek positif yang nyata pada *code search* bahasa Java, sebuah temuan kunci yang ditangani oleh penelitian ini.<br><br>**Kontribusi Utama:**<br>• Melakukan investigasi empiris pertama tentang kontribusi berbagai representasi (Token, AST, Graph) untuk *code search* dalam konteks *edge software development*.<br>• Mengusulkan pendekatan hibrida **TAMG** multi-modal untuk *code search* bahasa Java dengan menggabungkan Token, AST, dan *Mixed Graphs* (CFG+PDG).<br>• Menjawab RQ yang diajukan dan memberikan rekomendasi praktis mengenai pilihan modalitas dan parameter untuk kinerja optimal.<br><br>**Dampak:**<br>• Akselerasi pengembangan dan peningkatan kualitas *edge software* dengan menyediakan alat *code search* yang cerdas dan efektif, mendukung ekspansi aplikasi multimedia modern. |

## 1. Pendahuluan & Masalah

Pertumbuhan pesat aplikasi multimedia, seperti *video streaming* dan *computer games*, menuntut konstruksi infrastruktur perangkat lunak yang efisien dalam *edge computing*. Dalam komunitas *software engineering*, *code search* (pencarian kode) telah menjadi praktik yang lazim untuk meningkatkan efisiensi dan keandalan pengembangan perangkat lunak.

Meskipun peneliti telah memanfaatkan *deep learning* untuk mengekstrak fitur dari berbagai representasi program (Token, AST, Graphs, dll.), dua masalah utama masih mendominasi domain penelitian ini:
1.  **Representasi *Graph* Kurang Dieksplorasi:** Hanya ada sedikit studi yang secara efektif menggunakan representasi *graph* (seperti *Control Flow Graph* dan *Program Dependence Graph*) untuk *code search*, terutama untuk bahasa pemrograman **Java**.
2.  **Kekurangan Studi Empiris Terhadap Kontribusi Modalitas:** Terdapat kekurangan studi empiris sistematis yang mengukur kontribusi spesifik dari berbagai representasi program yang berbeda.

::: tip Solusi yang Diusulkan
Untuk mengatasi masalah ini, penelitian ini melakukan studi empiris untuk mengeksplorasi representasi program, khususnya *program graphs*. Kami menyajikan pendekatan hibrida **TAMG** (*Token, AST, and Mixed Graphs*) pertama untuk bahasa Java, yang menangkap dan menggabungkan fitur dari Token, AST, dan *Mixed Graphs* (menggabungkan *Control Flow Graph* dan *Program Dependence Graph*) untuk meningkatkan efektivitas *code search*.
:::

## 2. Metodologi

Pendekatan hibrida **TAMG** mengadopsi arsitektur *joint embedding* multi-modal dengan Mekanisme *Attention*, yang bertujuan memproyeksikan kode dan deskripsi ke ruang vektor terpadu di mana kesamaan semantik diterjemahkan menjadi kedekatan vektor.

### A. Arsitektur Umum

Model ini beroperasi dalam dua tahap:
1.  **Tahap Pelatihan *Offline***: Membangun dan melatih model untuk mengekstrak dan menggabungkan fitur dari tiga representasi kode: Token, AST, dan *Mixed Graphs*.
2.  **Tahap *Online Retrieval***: Model terlatih menerima kueri bahasa alami dari pengembang dan merekomendasikan *snippet* kode yang paling relevan.

### B. Pembelajaran Representasi Modalitas

Setiap modalitas diproses oleh jaringan saraf yang berbeda, dilengkapi dengan mekanisme *Attention* untuk menyoroti informasi signifikan:

1.  **Token (Urutan Token Kode):**
    *   Digunakan **LSTM** untuk mengekstrak fitur berurutan.
    *   Mekanisme *Attention* diterapkan pada semua *hidden states* ($h_{i}^{tok}$) untuk menghasilkan representasi Token akhir ($\mathbf{Tok}$).
2.  **AST (Pohon Sintaksis Abstrak):**
    *   Digunakan **Tree-based LSTM** (berdasarkan struktur pohon biner AST) untuk menangkap fitur sintaksis dan struktural.
    *   Mekanisme *Attention* diterapkan pada *node* AST untuk mendapatkan representasi AST akhir ($\mathbf{AST}$).
3.  **Graph (Mixed Graphs - CFG + PDG):**
    *   Digunakan **Gated Graph Neural Networks (GGNN)** untuk mempelajari fitur dari struktur *graph* yang terarah.
    *   Representasi *Mixed Graph* ($\mathbf{G}$) dibangun dengan menggabungkan *Control Flow Graph* (CFG) dan *Program Dependence Graph* (PDG). *Attention* diterapkan pada *node* *graph*.

### C. Fusion dan Pelatihan

1.  **Fusion Modalitas:** Representasi modalitas kode digabungkan melalui **concatenation** untuk menghasilkan representasi kode akhir ($\mathbf{C}$):
    $$ \mathbf{C} = \tanh([\mathbf{Tok}; \mathbf{AST}; \mathbf{G}]) $$
2.  **Representasi Deskripsi:** Deskripsi kueri ($\mathbf{d}$) juga di-*embed* menggunakan **LSTM** dengan mekanisme *Attention* untuk menghasilkan vektor $\mathbf{Des}$.
3.  **Fungsi *Loss*:** Model dilatih menggunakan *triplet margin ranking loss* untuk memastikan vektor kode ($\mathbf{C}$) lebih dekat ke deskripsi positif ($\mathbf{D}^{+}$) daripada deskripsi negatif ($\mathbf{D}^{-}$) dengan margin ($\epsilon$):
    $$ \mathcal{L} = \sum_{\langle c,d^{+},d^{-}\rangle} \max(0,\epsilon - \cos(\mathbf{C},\mathbf{D}^{+}) + \cos(\mathbf{C},\mathbf{D}^{-})) $$
    Dalam eksperimen, margin $\epsilon$ diatur ke $0.6$.

## 3. Detail Pengujian

### Dataset
*   **Sumber:** Dataset Java dari **CodeSearchNet**.
*   **Pembuatan Dataset:** Dataset asli disaring dan di-*parsing* ulang menggunakan alat seperti ANTLR4, JAVALANG, Icoffee, dan Soot untuk menghasilkan representasi Token, AST, dan *Graph* yang diperlukan.
*   **Ukuran Dataset Eksperimen:** Total 71,865 pasangan (kode, deskripsi) (Pelatihan: 67,865; Validasi: 2,000; Uji: 2,000).

### Baselines
*   **DeepCS:** Menggunakan Token, API, dan *Method Name* (Model *Siamese* pertama).
*   **MMAN:** Menggunakan Token, AST, dan CFG (untuk bahasa C, diadaptasi untuk Java dalam studi ini).

### Metrik Evaluasi
Dua metrik utama digunakan untuk menilai kemampuan *retrieval*:
1.  **$R@k$ (Recall at k):** Persentase kueri yang memiliki hasil benar di antara $k$ hasil teratas.
    $$ R@k = \frac{1}{|Q|}\sum_{q=1}^{|Q|}f(q,k) $$
    Di mana $f(q,k)$ adalah fungsi indikator ($1$ jika hasil benar ada di *Top k*, $0$ sebaliknya). Nilai $k$ yang digunakan adalah $\{1, 5, 10\}$.
2.  **MRR (Mean Reciprocal Rank):** Rata-rata dari invers peringkat hasil benar pertama.
    $$ MRR = \frac{1}{|Q|}\sum_{q=1}^{|Q|}\frac{1}{rank_{i}} $$

## 4. Hasil Eksperimen

### RQ1: Efek Representasi Graph

| Metode | R@1 | R@5 | R@10 | MRR |
| :--- | :--- | :--- | :--- | :--- |
| DeepCS (Baseline) | 0.294 | 0.495 | 0.589 | 0.393 |
| MMAN (Baseline) | 0.319 | 0.532 | 0.622 | 0.422 |
| **Token+AST+CFG** | 0.369 | 0.583 | 0.657 | 0.469 |
| **Token+AST+PDG** | 0.351 | 0.569 | 0.651 | 0.456 |
| **Token+AST+Mix** | **0.370** | **0.594** | **0.671** | **0.474** |

**Analisis RQ1:**
*   Pendekatan hibrida yang menggunakan representasi *graph* (*Token+AST+Graph*) secara signifikan mengungguli semua *baseline*.
*   Model yang dibangun dengan **Mixed Graph** (CFG + PDG) menunjukkan efektivitas terbaik di antara semua kombinasi (*Token+AST+Mix*), mencapai R@1 $\mathbf{37.0\%}$ dan MRR $\mathbf{47.4\%}$. Hal ini membenarkan bahwa representasi *graph* memiliki efek positif yang nyata pada *code search* bahasa Java, dan penggabungan CFG dan PDG (Mix) adalah pilihan yang direkomendasikan.

### RQ2: Kontribusi Masing-Masing Modalitas

| Metode | R@1 | R@5 | R@10 | MRR |
| :--- | :--- | :--- | :--- | :--- |
| **Modalitas Tunggal** | | | | |
| Method Name (MN) | 0.001 | 0.002 | 0.004 | 0.004 |
| API | 0.003 | 0.004 | 0.007 | 0.006 |
| CFG | 0.052 | 0.118 | 0.177 | 0.095 |
| PDG | 0.061 | 0.154 | 0.201 | 0.112 |
| **Mix** | **0.106** | **0.241** | **0.310** | **0.177** |
| AST | 0.232 | 0.403 | 0.481 | 0.317 |
| **Token** | **0.235** | **0.433** | **0.522** | **0.333** |
| **Modalitas Ganda** | | | | |
| AST+CFG | 0.202 | 0.398 | 0.487 | 0.296 |
| Token+AST | 0.326 | 0.565 | 0.657 | 0.435 |
| **Token+Mix** | 0.321 | 0.549 | 0.639 | 0.427 |
| **Token+AST+Mix (TAMG)** | **0.370** | **0.594** | **0.671** | **0.474** |

**Analisis RQ2:**
*   **Kontribusi Signifikan:** Modalitas **Token** dan **AST** menunjukkan kemampuan umum yang dapat diterima pada modalitas tunggal (MRR sekitar $32\% - 33\%$), sementara MN dan API hampir tidak memiliki kemampuan *retrieval*.
*   **Peran Graph:** Meskipun sebagai modalitas tunggal *Mixed Graph* (Mix) memiliki MRR yang rendah ($0.177$), ia adalah representasi *graph* terbaik dan memberikan dorongan positif yang signifikan ketika dikombinasikan dengan Token dan AST (membentuk TAMG).
*   **Rekomendasi:** Model yang dibangun dengan modalitas ganda, terutama yang menyertakan **Token**, jauh lebih efektif (MRR $43.5\%$ untuk *Token+AST*). Direkomendasikan untuk mempertahankan ketiga modalitas (**Token, AST, dan Graph**) untuk kinerja optimal.

### RQ3: Parameter dan Kinerja Optimal

Eksperimen kinerja menunjukkan bahwa:
*   **Epochs:** Kinerja model mencapai hasil maksimum di sekitar $\mathbf{200}$ *epochs*. Pelatihan lebih dari 200 *epochs* tidak memberikan peningkatan yang signifikan.
*   **Dropout:** Meningkatkan *dropout* dari $0.1$ ke $0.5$ memberikan sedikit peningkatan pada R@1 (mencapai $37.15\%$), tetapi $0.1$ tetap merupakan opsi yang baik.
*   **Learning Rate:** *Learning rate* memiliki peran yang sangat menentukan. *Learning rate* yang terlalu tinggi ($0.01$) menghasilkan kinerja yang sangat buruk (MRR di bawah $16\%$), menegaskan pentingnya pemilihan parameter yang cermat.

## 5. Kesimpulan

Penelitian ini berhasil menunjukkan bahwa representasi program ganda yang komprehensif, terutama yang mencakup *Mixed Graphs* (CFG dan PDG) untuk bahasa Java, secara signifikan meningkatkan kinerja *code search* yang cerdas. Pendekatan hibrida **TAMG** yang diusulkan mencapai kemampuan terbaik (R@1 $\mathbf{37.0\%}$), mengkonfirmasi kontribusi positif dari Token, AST, dan *Mixed Graphs*.

::: info Dampak Praktis
Berdasarkan temuan ini, direkomendasikan bagi pengembang yang membangun infrastruktur *software* *edge computing* untuk menggunakan ketiga representasi (*Token, AST, dan Mixed Graph*) dalam model mereka, atau setidaknya mempertahankan AST atau Graph sambil memastikan modalitas **Token** disertakan, guna mendapatkan model *code search* yang efektif.
:::