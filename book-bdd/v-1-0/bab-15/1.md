# ðŸ“˜ SUB-BAB 15.1: FILOSOFI POLYGLOT PERSISTENCE

## ðŸŽ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Menjelaskan definisi **Polyglot Persistence** dan mengapa pendekatan "Satu Database untuk Semua" sudah usang.
2.  Menganalisis hubungan erat antara **Microservices** dan kebutuhan akan berbagai jenis database.
3.  Mengidentifikasi skenario di mana MongoDB harus "mengalah" dan memberikan tugas kepada database lain (SQL, Graph, Time-Series).

---

## ðŸ”— Context & Hook
Bayangkan kamu adalah seorang tukang bangunan. Apakah kamu bisa membangun seluruh rumah hanya dengan menggunakan **Palu**?
* Bisa saja. Kamu bisa memukul paku dengan palu. Kamu bisa memecahkan batu dengan palu. Tapi bisakah kamu menggergaji kayu dengan palu? Atau mengecat dinding dengan palu? Hasilnya pasti berantakan.

Dalam dunia data, MongoDB adalah "Palu" yang sangat hebat. Tapi tidak semua masalah data adalah paku.
* Data Relasi Teman (Social Network) adalah "Kayu" (Butuh Gergaji/Graph DB).
* Data Saldo Bank adalah "Kaca" (Butuh Pemotong Kaca/SQL ACID).

Filosofi menggunakan alat yang tepat untuk pekerjaan yang tepat inilah yang disebut **Polyglot Persistence**.

---

## ðŸ’¡ Analogi: Tim Olahraga
Bayangkan sebuah tim sepak bola:
* **MongoDB (Striker):** Lincah, fleksibel, cepat mencetak gol (Data Dokumen/JSON).
* **Redis (Sayap):** Sangat cepat, lari jarak pendek (Caching).
* **Neo4j (Gelandang):** Jago mengoper dan menghubungkan pemain (Data Hubungan).
* **PostgreSQL (Kiper):** Kaku, tapi sangat aman menjaga gawang (Data Transaksi Keuangan).

Jika kamu memaksa Kiper (SQL) menjadi Striker, timmu kalah. Jika kamu memaksa Striker (MongoDB) menjadi Gelandang pengatur serangan (Graph), timmu tidak efisien. **Polyglot Persistence** adalah strategi pelatih yang memainkan semua pemain di posisi terbaiknya.

---

## ðŸ“š Inti Materi

### 1. Apa itu Polyglot Persistence?
Polyglot Persistence adalah filosofi arsitektur yang mengakui bahwa tidak ada satu jenis basis data pun yang mampu menangani semua kebutuhan data dengan sempurna. Oleh karena itu, aplikasi modern sebaiknya menggunakan **kombinasi** dari beberapa teknologi database.

### 2. Pendorong Utama: Microservices
Arsitektur Microservices (Bab 10) adalah pendorong utama tren ini.
* Karena setiap layanan (Service) bersifat **Otonom**, tim *Recommendation Service* bebas memilih *Graph Database* tanpa perlu izin dari tim *Order Service* yang memakai *MongoDB*.
* Ini memungkinkan setiap layanan mencapai performa puncak (*Peak Performance*) karena didukung oleh *storage engine* yang spesifik.

### 3. Kapan MongoDB Bukan Solusi Terbaik?
Meskipun MongoDB serba bisa, ada kasus di mana ia kalah efisien:
* **Hubungan Kompleks (Many-to-Many):** Seperti "Siapa teman dari teman saya yang menyukai produk ini?". MongoDB butuh `$lookup` berantai yang mahal. *Graph Database* menyelesaikannya dalam milidetik.
* **Transient Data (Data Sementara):** Seperti Session Login atau Shopping Cart sementara. MongoDB menulis ke disk (lambat). *Redis* (In-Memory) menulis ke RAM (kilat).
* **Time-Series Ekstrem:** Sensor IoT mengirim 1 juta data per detik. MongoDB bisa menangani ini, tapi database khusus seperti *InfluxDB* atau *TimescaleDB* bisa memampatkan datanya 10x lebih efisien.

---

## ðŸ“± Contoh Penerapan: Super App (Gojek/Grab)
Satu aplikasi di HP kamu sebenarnya terhubung ke banyak database di belakang layar:
1.  **GoFood (Katalog Makanan):** Menggunakan **MongoDB** (Dokumen) karena menu makanan strukturnya variatif (ada topping, level pedas).
2.  **GoPay (Saldo):** Menggunakan **PostgreSQL** (SQL) karena butuh ACID ketat agar uang tidak hilang.
3.  **GoRide (Lokasi Driver):** Menggunakan **Redis** (Geospatial) untuk melacak driver di sekitar secara *real-time*.
4.  **GoChat (Riwayat Chat):** Menggunakan **Cassandra** (Wide-Column) untuk menampung miliaran pesan chat lama.

---

## ðŸ“– Mini-Glossary
* **Polyglot Persistence:** Praktik menggunakan berbagai teknologi penyimpanan data dalam satu aplikasi untuk memenuhi kebutuhan yang berbeda-beda.
* **Graph Database:** Basis data yang menggunakan struktur graf (node, edge) untuk menyimpan dan menanyakan hubungan antar data (contoh: Neo4j).
* **Time-Series Database:** Basis data yang dioptimalkan untuk menyimpan data yang diurutkan berdasarkan waktu (contoh: InfluxDB).
* **In-Memory Database:** Basis data yang menyimpan seluruh datanya di RAM untuk kecepatan ekstrem (contoh: Redis).

---

## ðŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Analisis:** Mengapa arsitektur *Monolitik* sulit menerapkan *Polyglot Persistence* dibandingkan *Microservices*?
    * a. Karena Monolitik tidak punya uang.
    * b. Karena dalam Monolitik, semua modul berbagi satu koneksi database besar; menggabungkan banyak database dalam satu codebase raksasa meningkatkan kompleksitas operasional dan kode secara eksponensial.
    * c. Karena database lain tidak support Monolitik.
    * d. Karena Monolitik hanya untuk SQL.
    * e. Karena server Monolitik lambat.

2.  **Skenario:** Anda membangun fitur "Rekomendasi Teman" (Friend Recommendation) yang mencari pola hubungan hingga kedalaman 3 level ("Teman dari teman dari teman"). Database apa yang paling efisien secara komputasi?
    * a. MongoDB (Dokumen).
    * b. Redis (Key-Value).
    * c. Neo4j (Graph Database).
    * d. MySQL (Relasional).
    * e. Cassandra (Wide Column).

3.  **Konsep:** Apa risiko terbesar atau "biaya tersembunyi" dari menerapkan Polyglot Persistence?
    * a. Biaya lisensi murah.
    * b. **Kompleksitas Operasional (Ops Overhead)**; tim harus menguasai, mem-backup, mem-patch, dan memonitor 5 jenis database yang berbeda, bukan cuma satu.
    * c. Aplikasi jadi terlalu cepat.
    * d. Data jadi terlalu aman.
    * e. Developer jadi bosan.

4.  **Keputusan:** Jika data Anda berupa log server yang masuk sangat cepat, tidak pernah di-update (append-only), dan sering di-query berdasarkan rentang waktu ("Log jam 8 sampai jam 9"), database jenis apa yang paling optimal?
    * a. Graph Database.
    * b. Time-Series Database.
    * c. Relational Database.
    * d. Key-Value Store.
    * e. Blockchain.

5.  **Identifikasi:** Manakah pasangan use-case dan database yang **KURANG TEPAT**?
    * a. Katalog Produk -> MongoDB.
    * b. Caching -> Redis.
    * c. Transaksi Bank -> PostgreSQL.
    * d. Hubungan Sosial Rumit -> Neo4j.
    * e. Laporan Keuangan Tahunan -> Redis.

### Kunci Jawaban
1.  **b** (Kesulitan integrasi kode adalah hambatan utama di Monolitik).
2.  **c** (Graph DB didesain khusus untuk *traversal* hubungan yang dalam).
3.  **b** (Jangan remehkan beban *maintenance* dari kebun binatang database).
4.  **b** (Optimasi kompresi dan *timestamp index* adalah kuncinya).
5.  **e** (Redis bersifat *volatile* dan mahal RAM-nya, tidak cocok untuk arsip laporan jangka panjang).

---

## ðŸš€ Mini Challenge
**Arsitek Polyglot:**
Anda diminta merancang backend untuk **LinkedIn**. Pilih database untuk 3 fitur ini:
1.  **Profil User (CV, Pengalaman, Skill):** (Jawab: MongoDB - Dokumen fleksibel).
2.  **Jaringan Koneksi (Siapa kenal Siapa):** (Jawab: Neo4j - Graph).
3.  **Jumlah "View" Profil (Counter Real-time):** (Jawab: Redis - Cepat & Atomic).

---
*Konsepnya bagus, tapi mengelola 5 database berbeda itu pusing! Adakah cara untuk mendapatkan keunggulan Polyglot tanpa kerumitan ops-nya? Ketik **"Lanjut"** untuk masuk ke **Sub-Bab 15.2: Multi-Model Database: Jalan Tengah?**.*