---
title: 'Sesi 9.II: Arsitektur Komunikasi IoT dan Protokol MQTT'
description: 'Memahami model komunikasi Publisher-Subscriber dan mengapa MQTT adalah protokol standar untuk IoT yang hemat sumber daya.'
lang: id-ID
date: 2025-12-05
tag:
  - IoT Communication
  - MQTT
  - Resource-Constrained
level: Menengah
---

# ðŸ“š Sesi 9.II: Arsitektur Komunikasi IoT dan Protokol MQTT

*Target audiens: Developer Embedded System/Arsitek Solusi IoT*

### Tujuan Pembelajaran
Setelah mempelajari materi ini, peserta mampu:

*   Membandingkan efisiensi protokol MQTT dan HTTP dalam konteks IoT.
*   Menjelaskan cara kerja model komunikasi Publisher-Subscriber.
*   Mengidentifikasi peran Broker, Publisher, dan Subscriber dalam arsitektur MQTT.

---

### 1. ðŸ”— Context & Hook (Bridging Awal)

**Recap (Sesi sebelumnya):** Kita telah mengidentifikasi bahwa perangkat IoT adalah sistem **Resource-Constrained** (memori, daya, *bandwidth* terbatas) yang **wajib terhubung** ke jaringan.

**The Hook (Fakta/Masalah Pemantik):** Mengirimkan data sensor suhu 10 *byte* setiap detik menggunakan protokol HTTP membutuhkan *overhead header* hingga 100 *byte* per pesan, menghabiskan baterai dan *bandwidth* yang mahal. Ini adalah pemborosan fatal di lingkungan IoT.

**Pertanyaan Pemantik:** Bagaimana cara kita mengirimkan data *telemetry* yang sangat kecil secara *real-time* dan andal, sambil meminimalkan konsumsi daya dan *bandwidth* di jaringan yang tidak stabil?

**Target Superpower:** Hari ini, kita akan mendapatkan *superpower* untuk **merancang pola komunikasi *message-based* yang paling efisien** menggunakan protokol standar industri IoT.

---

### 2. ðŸ§  Mental Model (Analogi)

Bayangkan **MQTT** sebagai **Jasa Surat Kabar** di lingkungan yang koneksinya buruk.

*   **Broker (Pusat Berita):** Ini adalah kantor berita sentral yang mengelola semua topik berita (*Topic*). Ia tidak peduli siapa yang mengirim, hanya mengelola *Topic* yang ada.
*   **Publisher (Reporter):** Reporter (*device* sensor) hanya menulis artikel singkat (data) dan menempelkannya ke papan pengumuman spesifik (*Topic*), tanpa perlu tahu siapa pembacanya.
*   **Subscriber (Pelanggan):** Pelanggan (*device* kontrol/Cloud) hanya berlangganan ke *Topic* yang mereka minati. Mereka menerima data *real-time* tanpa perlu terus-menerus bertanya (polling) ke kantor berita.

---

### 3. âš™ï¸ Deep Dive (Inti Materi Engineering)

#### Model Publisher-Subscriber (Pub/Sub)
Model komunikasi asinkron di mana pengirim (*Publisher*) dan penerima (*Subscriber*) tidak saling berinteraksi secara langsung. Mereka dimediasi oleh komponen ketiga, yaitu **Broker**.

*   **Decoupling Spasial:** *Publisher* dan *Subscriber* tidak perlu mengetahui keberadaan satu sama lain (hanya berinteraksi dengan **Broker**).
*   **Decoupling Temporal:** *Publisher* dapat mengirim pesan meskipun *Subscriber* sedang *offline*. Pesan dapat dipertahankan oleh Broker (menggunakan *Retained Message* atau mekanisme **QoS**).

#### Protokol MQTT (Message Queuing Telemetry Transport)
Protokol *lightweight* (berat ringan) yang dirancang khusus untuk jaringan *low-bandwidth*, latensi tinggi, dan tidak andal.

*   **Header Minimalis:** Ukuran *header* paket MQTT sangat kecil (mulai dari 2 *byte*), sangat efisien dibandingkan HTTP.
*   **Kualitas Layanan (QoS):** MQTT menawarkan 3 level QoS untuk memastikan keandalan pengiriman:
    *   **QoS 0 (At most once):** Pengiriman *fire and forget*. Cepat, tanpa konfirmasi. (Ideal untuk data *non-critical*).
    *   **QoS 1 (At least once):** Pesan terkirim minimal sekali, ada risiko duplikasi. Membutuhkan *ACK*.
    *   **QoS 2 (Exactly once):** Pesan terkirim tepat satu kali. Protokol 4 langkah yang paling andal, tetapi dengan *overhead* tertinggi.

---

### 4. Contoh Penerapan

*   **Skenario A (Pengiriman Data Sensor):** Sensor kelembaban (**Publisher**) terhubung ke **Broker** Cloud dan mempublikasikan data ke *Topic* `pabrik/lantai1/sensor/kelembaban`. Platform Analitik (**Subscriber**) yang berlangganan *Topic* tersebut akan menerima data secara instan.
*   **Skenario B (Kontrol Aktor):** Aplikasi seluler (**Publisher**) mengirim perintah `TURN_ON` ke *Topic* `pabrik/lantai1/aktor/kipas`. Mikrokontroler Kipas (**Subscriber**) mendengarkan *Topic* tersebut dan mengaktifkan aktuator saat menerima pesan.

---

### 5. Mini-Glossary

*   **Broker:** Server sentral yang bertanggung jawab untuk menerima pesan dari *Publisher* dan meneruskannya ke *Subscriber* yang relevan.
*   **Topic:** *String* terstruktur (misalnya, `home/lampu/dapur`) yang berfungsi sebagai saluran virtual tempat pesan dikirim dan diterima. Mirip jalur file.
*   **QoS (Quality of Service):** Mekanisme yang menentukan seberapa andal dan terjamin pengiriman pesan antara *Publisher* dan *Broker*, dan antara *Broker* dan *Subscriber*.

---

### 6. Visual yang Disarankan

*   : Diagram 3-kolom yang menunjukkan **Publisher**, di tengah **Broker**, dan di kanan **Subscriber** yang saling terpisah, dihubungkan oleh garis panah melalui Broker.
*   : Visual perbandingan grafis yang menunjukkan ukuran *header* paket MQTT (sangat kecil) dibandingkan *header* paket HTTP (jauh lebih besar).

---

### 7. Evaluasi Singkat

1.  MQTT menggunakan model Pub/Sub yang memisahkan pengirim dan penerima data.
2.  Penggunaan QoS 2 menjamin pesan terkirim tepat satu kali, tetapi memerlukan *overhead* transaksi 4 langkah.

**5 Soal Pilihan Ganda (HOTS)**

1.  Mengapa protokol MQTT secara signifikan lebih disukai daripada HTTP untuk pengiriman *telemetry* di sebagian besar perangkat IoT *resource-constrained*?
    *   a. MQTT menyediakan enkripsi *end-to-end* yang lebih kuat secara default.
    *   b. MQTT memiliki *overhead header* minimal, mengurangi konsumsi *bandwidth* dan daya baterai.
    *   c. HTTP tidak mendukung model komunikasi asinkron (Pub/Sub).
    *   d. MQTT memungkinkan *payload* data yang jauh lebih besar daripada HTTP.
    *   e. HTTP membutuhkan alamat IP statis untuk setiap *device*.
2.  Dalam arsitektur MQTT, peran apa yang diemban oleh komponen yang bertanggung jawab untuk mengelola daftar *Topic* dan mengarahkan pesan dari *Publisher* ke *Subscriber*?
    *   a. *Client*
    *   b. *Gateway*
    *   c. Broker
    *   d. *Load Balancer*
    *   e. *Producer*
3.  Seorang *engineer* IoT memutuskan untuk menggunakan QoS 0 pada data sensor suhu yang dikirim setiap 10 detik. Apa implikasi paling kritis dari keputusan ini?
    *   a. Data akan mengalami duplikasi tinggi.
    *   b. Ada kemungkinan pesan hilang tanpa notifikasi jika koneksi Broker terputus.
    *   c. Kinerja akan lebih lambat daripada menggunakan QoS 1 atau QoS 2.
    *   d. Diperlukan lebih banyak *header* tambahan untuk kompresi data.
    *   e. *Device* harus menggunakan protokol TCP, bukan UDP.
4.  Apa keuntungan arsitektural utama dari *Decoupling Spasial* dalam model Publisher-Subscriber?
    *   a. Publisher dan Subscriber tidak perlu mengetahui lokasi, alamat IP, atau detail koneksi satu sama lain.
    *   b. Pesan dapat disimpan oleh Broker tanpa batas waktu.
    *   c. Hanya *device* yang *online* yang dapat mengirim dan menerima pesan.
    *   d. Protokol komunikasi yang digunakan adalah *Connectionless* (UDP).
    *   e. Model ini hanya cocok untuk komunikasi *Device-to-Cloud*.
5.  *Topic* pada MQTT berfungsi mirip dengan:
    *   a. Alamat IP unik setiap *device*.
    *   b. Lapisan enkripsi TLS/SSL.
    *   c. ID unik *firmware* perangkat.
    *   d. Saluran atau jalur virtual yang mengkategorikan dan mengarahkan pesan yang dikirim.
    *   e. Format *payload* data (misalnya, JSON atau XML).

*Jawaban HOTS Quiz:* 1. b, 2. c, 3. b, 4. a, 5. d

---

### 8. Mini-Challenge

**Tantangan:** Jika Anda merancang sistem alarm kebakaran berbasis MQTT, tentukan level **QoS** yang paling tepat untuk pesan "Kebakaran Terdeteksi" dan jelaskan mengapa.
> (Jawaban: **QoS 2 (Exactly once)**. Alasannya adalah pesan ini *sangat kritis* dan harus dijamin sampai tepat satu kali, menghindari risiko kehilangan pesan (QoS 0) atau duplikasi yang dapat memicu alarm palsu berulang (QoS 1)).