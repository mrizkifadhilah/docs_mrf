---
title: 'Sesi 8.1: Fondasi Sharding'
description: 'Menganalisis keterbatasan Skalabilitas Vertikal dan anatomi MongoDB Sharded Cluster (Mongos, Config Servers, Shards).'
lang: id-ID
date: 2025-12-05 # Tanggal berdasarkan instruksi
tag:
  - MongoDB
  - Sharding
  - Database Architecture
level: Menengah
---

# ðŸ“š Sesi 8.1: Fondasi Sharding: Kebutuhan & Anatomi Cluster

*Target audiens: Menengah. Mahasiswa/Developer dengan latar belakang database relasional (RDBMS) yang ingin memahami transisi ke arsitektur terdistribusi NoSQL.*

### Tujuan Pembelajaran
Setelah mempelajari materi ini, peserta mampu:

*   Menganalisis keterbatasan **Skalabilitas Vertikal** dan membenarkan kebutuhan **Sharding**.
*   Mengidentifikasi dan menjelaskan peran arsitektural dari tiga komponen kunci MongoDB Sharded Cluster (**Mongos, Config Servers, Shards**).
*   Menjelaskan alur komunikasi *query* dari aplikasi hingga penyimpanan data di *sharded cluster*.

---

### 1. ðŸ”— Context & Hook (Bridging Awal)

**Recap (Bab 7):** Di bab sebelumnya, kita telah menguasai **Replica Set**. Tujuan utamanya adalah **Ketersediaan Tinggi (High Availability)** dan mendistribusikan *read load* (Skalabilitas Baca) dengan membuat salinan data yang identik.

**The Hook (Fakta/Masalah Pemantik):** Amazonâ€”platform *e-commerce* raksasaâ€”menggunakan lebih dari 750 petabyte data. Tidak ada satu pun server, bahkan yang tercanggih sekalipun, yang mampu menampung data sebesar ini sekaligus.

**Pertanyaan Pemantik:** Jika Replica Set hanya membuat salinan data yang sama, bagaimana kita menyimpan *dataset* yang ukurannya **melebihi kapasitas disk** satu server terkuat?

**Target Superpower:** Hari ini, kita akan mendapatkan *superpower* **Skalabilitas Horizontal (Scale Out)** tak terbatas melalui arsitektur terdistribusi.

---

### 2. ðŸ§  Mental Model (Analogi)

Bayangkan sebuah **Perpustakaan Utama (Koleksi Logis)** yang koleksi bukunya sudah terlalu banyak dan tidak muat di satu gedung.

*   **Perpustakaan Cabang (Shards):** Menyimpan sebagian kecil dan spesifik dari koleksi buku. Setiap cabang adalah unit penyimpanan data yang sebenarnya.
*   **Katalog Induk (Config Servers):** Basis data yang mencatat secara detail, buku A ada di Cabang mana, dan buku B ada di Cabang mana.
*   **Petugas Informasi Pusat (Mongos):** Petugas yang menjadi satu-satunya gerbang masuk. Dia merutekan permintaan buku Anda ke Cabang yang benar setelah memeriksa Katalog Induk.

---

### 3. âš™ï¸ Deep Dive (Inti Materi Engineering)

#### Definisi Sharding
**Sharding** adalah metode arsitektural untuk mencapai **Skalabilitas Horizontal (Scale Out)** tak terbatas dengan memecah *dataset* logis yang sangat besar menjadi bagian-bagian yang lebih kecil (**Shards**). Sharding mengatasi batas **kapasitas data tunggal (Skalabilitas Vertikal)**.

#### Anatomi MongoDB Sharded Cluster

MongoDB Sharded Cluster adalah sistem terdistribusi yang terdiri dari tiga komponen inti yang memiliki peran spesifik:

| Komponen | Peran Arsitektural |
| :--- | :--- |
| **Shards** | Unit penyimpanan data yang sebenarnya. Menyimpan **subset data**. Menyediakan ketersediaan dan ketahanan data melalui mekanisme **Replica Set**. |
| **Config Servers** (CSRS) | Menyimpan *config database* (**metadata**). Wajib berupa Replica Set sendiri (**CSRS**) untuk menjamin durabilitas dan ketersediaan metadata *cluster*. |
| **Query Routers** (Mongos) | **Gerbang masuk** untuk semua *query* dari aplikasi. Bertindak sebagai *proxy* perutean. Merutekan *query* berdasarkan informasi dari Config Servers. |

#### Kesalahan Umum:

*   **Mengirim Query Langsung ke Shard:** Selalu kirim *query* melalui **Mongos**; jika tidak, aplikasi hanya mendapatkan **subset data**.
*   **Mengabaikan Ketahanan Config Servers:** Config Servers sangat kritis dan harus berupa Replica Set.

---

### 4. Contoh Penerapan di Dunia Nyata

*   **E-commerce (Inventori Global):** *Sharding* berdasarkan `Region`.
*   **Media Sosial (Post/Timeline):** *Sharding* berdasarkan `user_id` untuk **lokalitas data**.
*   **Log Data (Time Series):** Data *log* di-shard berdasarkan rentang waktu.

---

### 5. Mini-Glossary

*   **Sharding:** Teknik partisi data horizontal.
*   **Skalabilitas Horizontal (Scale Out):** Meningkatkan kapasitas dengan menambah server.
*   **Shards:** Unit penyimpanan data terfragmentasi.
*   **Config Servers (CSRS):** Menyimpan metadata lokasi data.
*   **Query Routers (Mongos):** Layer perutean untuk aplikasi.
*   **Chunk:** Unit terkecil dari data yang dialokasikan dan dipindahkan.

---

### 6. Visual yang Disarankan

*   Diagram Arsitektur Sharded Cluster (Tiga lapis).
*   Diagram Alur Query: Aplikasi $\rightarrow$ Mongos $\rightarrow$ Config Servers $\rightarrow$ Shard.
*   Ilustrasi Keterbatasan Vertikal vs. Horizontal.

---

### 7. Evaluasi Singkat

1.  Tujuan utama Sharding adalah mengatasi keterbatasan **Kapasitas Data Tunggal (Skalabilitas Vertikal)**.
2.  Komponen yang menyimpan metadata lokasi Chunk data adalah **Config Servers**.
3.  Risiko kirim *query* langsung ke Shard: Aplikasi hanya akan mendapatkan **subset data, bukan keseluruhan koleksi logis**.
4.  Setiap Shard harus berupa Replica Set untuk menjamin **Ketersediaan Tinggi (HA)**.
5.  Query Router (Mongos) bertindak sebagai **Gerbang proxy perutean untuk aplikasi**.

**5 Soal Pilihan Ganda (HOTS)**

1.  Sebuah aplikasi menghadapi masalah di mana *write* per detik telah mencapai batas I/O disk server Master-Secondary. Tindakan terbaik yang harus diambil untuk mengatasi masalah **Skalabilitas Tulis (*Write Scaling*)** ini adalah:
    *   a. Menambah lebih banyak Secondary ke Replica Set yang ada.
    *   b. Melakukan *Scale Up* (meningkatkan RAM dan CPU) pada server Primary.
    *   c. Mengimplementasikan **Sharding** pada koleksi tersebut.
    *   d. Mengalihkan semua *query* baca ke Secondary.
    *   e. Mengubah *storage engine* menjadi WiredTiger.
2.  Apa yang akan terjadi pada *cluster* jika Config Servers mengalami *downtime* total?
    *   a. Operasi *read* dan *write* akan berhenti total karena Mongos tidak bisa beroperasi.
    *   b. Hanya operasi *write* yang akan terhenti, sementara operasi *read* (membaca data yang sudah ada) tetap dapat dilakukan.
    *   c. Tidak ada dampak karena Shards masih memiliki data mereka.
    *   d. Config Servers akan digantikan secara otomatis oleh Secondary dari Shard.
    *   e. Balancer akan secara otomatis memindahkan *chunk* data ke Shard lain.
3.  Dalam arsitektur *sharded cluster*, komponen mana yang bertanggung jawab untuk mengetahui secara pasti **di Shard mana** dokumen yang diminta (berdasarkan Shard Key) berada?
    *   a. Shard Primary itu sendiri.
    *   b. Aplikasi klien.
    *   c. Balancer.
    *   d. **Config Servers**.
    *   e. Salah satu Secondary dari Shard manapun.
4.  Mengapa setiap Shard dalam *cluster* harus berupa **Replica Set** dan bukan hanya *single instance* (satuan tunggal)?
    *   a. Untuk mendukung *query* yang menggunakan *join* antar Shard.
    *   b. Untuk memastikan bahwa data yang disimpan di Shard tersebut memiliki **Ketersediaan Tinggi (HA)** dan redundansi.
    *   c. Untuk memfasilitasi operasi *balancer* yang lebih cepat.
    *   d. Karena Mongos tidak dapat merutekan *query* ke *single instance*.
    *   e. Untuk menyimpan salinan *metadata* dari Config Servers.
5.  Apa itu operasi **Scatter-Gather** dalam konteks Sharding?
    *   a. Operasi di mana *write* didistribusikan secara acak ke semua Shard.
    *   b. Operasi yang terjadi ketika Mongos harus mengirimkan *query* ke **semua Shards** untuk mencari data (karena *query* tidak menggunakan Shard Key).
    *   c. Proses Balancer memindahkan *chunk* dari Shard yang penuh ke Shard yang kosong.
    *   d. Operasi pembaruan data yang terjadi serentak di semua node Replica Set.
    *   e. Proses inisialisasi awal Sharding.

*Jawaban HOTS Quiz:* 1. c, 2. b, 3. d, 4. b, 5. b

---

### 8. Mini-Challenge

**Tantangan:** *Query* riwayat pesanan (`find({customer_id: 12345})`) harus dikirim ke komponen arsitektural mana? Jelaskan.
> (Jawaban: Harus dikirim ke **Mongos**. Karena Mongos akan berkonsultasi dengan Config Servers untuk menemukan Shard tunggal yang menyimpan data `customer_id` tersebut, menghindari operasi *scatter-gather* yang mahal).