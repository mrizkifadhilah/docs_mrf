# ğŸ“˜ SUB-BAB 11.1: PRINSIP EVENT-DRIVEN & PERAN APACHE KAFKA

## ğŸ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Menjelaskan prinsip dasar **Arsitektur Event-Driven (EDA)** dan bagaimana ia memecahkan masalah *tight coupling* pada komunikasi sinkron (REST API).
2.  Menganalisis peran **Apache Kafka** sebagai *Message Broker* (Log Terdistribusi) yang menjamin durabilitas dan urutan pesan.
3.  Membedakan konsep inti Kafka: **Topic**, **Partition**, dan **Offset** dalam konteks skalabilitas horizontal.

---

## ğŸ”— Context & Hook
Bayangkan kamu memesan makanan di restoran cepat saji.
* **Cara Sinkron (REST API):** Kamu berdiri di depan kasir, memesan, lalu **diam menunggu** di depan kasir sampai makanan selesai dimasak. Kasir tidak bisa melayani orang lain. Jika koki lambat, antrian macet total.
* **Cara Asinkron (Event-Driven):** Kamu memesan, kasir memberimu **nomor antrian (Event)**, lalu kamu minggir. Kasir lanjut melayani orang lain. Di dapur, koki melihat layar pesanan dan memasak. Saat makanan siap, nomormu dipanggil.

Dalam Microservices, cara sinkron sering menyebabkan sistem "macet" (cascading failure). Jika satu service lambat, service pemanggil ikut lambat. **Event-Driven Architecture (EDA)** adalah solusi "nomor antrian" tersebut, dan **Apache Kafka** adalah layar pengumuman canggihnya.

---

## ğŸ’¡ Analogi: Log Harian Kapal
Apache Kafka sering disalahartikan sebagai "Kotak Surat". Padahal, Kafka lebih mirip **Log Harian Kapal (Distributed Log)**.
* **Log:** Catatan kejadian ("Jam 08.00: Mesin Nyala", "Jam 08.05: Kecepatan 20 Knot"). Catatan ini ditulis berurutan, tidak bisa dihapus, dan tidak bisa diubah (*Immutable*).
* **Consumer (Pembaca):** Kapten membaca log untuk navigasi. Mekanik membaca log untuk cek mesin. Masing-masing membaca log yang sama, tapi dengan kecepatan dan tujuan berbeda. Kapten tidak perlu menunggu Mekanik selesai membaca.

---

## ğŸ“š Inti Materi

### 1. Prinsip Event-Driven Architecture (EDA)
EDA adalah paradigma di mana layanan berkomunikasi dengan memproduksi dan mengonsumsi **Event** (fakta kejadian, misal: "UserCreated", "PaymentSuccess").
* **Decoupling (Pemisahan):** Service Pengirim (Publisher) tidak perlu tahu siapa penerimanya, apakah penerima sedang hidup atau mati, atau di mana lokasinya. Pengirim hanya "melempar" pesan ke Broker.
* **Asinkron:** Pengirim tidak menunggu balasan. Ini meningkatkan *throughput* dan responsivitas sistem.

### 2. Apa itu Apache Kafka?
Kafka adalah platform *streaming* data terdistribusi yang berfungsi sebagai **Message Broker**. Berbeda dengan broker tradisional (seperti RabbitMQ) yang menghapus pesan setelah dibaca, Kafka **menyimpan pesan** (Durable) dalam jangka waktu tertentu (misal: 7 hari).
* **Fungsi:** Sebagai "Penyangga" (*Buffer*) raksasa yang menampung jutaan pesan per detik, memastikan tidak ada data yang hilang meskipun sistem penerima sedang *down*.

### 3. Anatomi Kafka: Topic, Partition, Offset
* **Topic:** Kategori pesan (mirip nama tabel di database). Contoh: Topic `orders` untuk semua pesan pesanan.
* **Partition:** Unit skalabilitas. Sebuah Topic dipecah menjadi beberapa Partition agar bisa disimpan di banyak server berbeda. Ini memungkinkan Kafka menangani beban masif (*Horizontal Scaling*).
* **Offset:** Penanda posisi baca. Setiap pesan di Partition diberi nomor urut (Offset). Consumer mengingat Offset terakhir yang mereka baca (misal: "Saya baru baca sampai pesan ke-100"). Jika Consumer mati dan hidup lagi, ia lanjut baca dari Offset 101.

---

## ğŸ“± Contoh Penerapan: Sistem Notifikasi
1.  **Publisher (Order Service):** User checkout. Order Service mengirim event `{order_id: 101, status: "created"}` ke Kafka Topic `orders`. Order Service selesai tugasnya.
2.  **Broker (Kafka):** Menyimpan event tersebut di Log dan memberinya Offset.
3.  **Subscriber A (Email Service):** Membaca Topic `orders`, melihat ada order baru, lalu kirim email konfirmasi ke user.
4.  **Subscriber B (Inventory Service):** Membaca Topic `orders` yang sama, lalu mengurangi stok barang di gudang.
5.  **Hasil:** Email Service dan Inventory Service bekerja paralel tanpa saling mengganggu.

---

## ğŸ“– Mini-Glossary
* **Publisher/Producer:** Aplikasi yang mengirimkan event ke Kafka.
* **Subscriber/Consumer:** Aplikasi yang membaca dan memproses event dari Kafka.
* **Topic:** Saluran logis tempat event dikategorikan.
* **Partition:** Bagian fisik dari Topic yang memungkinkan data disebar (sharding) ke banyak server.
* **Offset:** Nomor urut unik untuk setiap pesan dalam Partition, digunakan untuk melacak kemajuan pembacaan.

---

## ğŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Analisis:** Mengapa komunikasi sinkron (REST API) antar-service dianggap memiliki risiko *Tight Coupling* yang berbahaya bagi ketersediaan sistem?
    * a. Karena REST API menggunakan HTTP yang lambat.
    * b. Karena Service A harus menunggu respon Service B; jika Service B mati atau lambat, Service A ikut gagal (*cascading failure*), melumpuhkan sistem.
    * c. Karena REST API tidak aman.
    * d. Karena data REST API tidak terenkripsi.
    * e. Karena REST API hanya bisa kirim teks.

2.  **Konsep:** Apa peran utama **Partition** dalam arsitektur Apache Kafka?
    * a. Untuk mengamankan data dengan enkripsi.
    * b. Untuk memungkinkan Skalabilitas Horizontal; memecah satu Topic besar menjadi bagian-bagian kecil yang bisa diproses secara paralel oleh banyak Consumer di server berbeda.
    * c. Untuk menghapus pesan lama otomatis.
    * d. Untuk mengurutkan pesan berdasarkan abjad.
    * e. Untuk backup data ke cloud.

3.  **Fitur:** Kafka memiliki sifat *Durable* (Tahan Lama). Apa artinya ini bagi *Consumer Service* yang tiba-tiba mengalami *crash* (mati) selama 1 jam?
    * a. Pesan yang dikirim selama 1 jam tersebut akan hilang permanen.
    * b. Kafka akan mengirim pesan error ke Publisher.
    * c. Pesan tetap aman tersimpan di Kafka; saat Consumer hidup kembali, ia bisa melanjutkan membaca dari **Offset** terakhir (tidak ada data hilang).
    * d. Consumer harus restart dari pesan pertama lagi.
    * e. Kafka akan menghapus Topic tersebut.

4.  **Perbandingan:** Apa perbedaan mendasar antara "Event" di EDA dengan "Request" di REST API?
    * a. Event adalah perintah ("Lakukan ini!"), Request adalah fakta ("Ini terjadi").
    * b. Event adalah fakta sejarah yang sudah terjadi dan *immutable* (tidak bisa diubah), sedangkan Request adalah permintaan aktif yang mengharapkan balasan segera.
    * c. Event lebih lambat.
    * d. Request tidak butuh jaringan.
    * e. Tidak ada beda.

5.  **Skenario:** Anda ingin membuat fitur "Replay History" untuk memperbaiki data bug minggu lalu. Fitur Kafka mana yang memungkinkan hal ini?
    * a. Partitioning.
    * b. Idempotency.
    * c. Offset Management (Consumer bisa mereset Offset ke posisi lama untuk membaca ulang pesan yang sudah lewat).
    * d. Compression.
    * e. Encryption.

### Kunci Jawaban
1.  **b** (Ketergantungan waktu nyata adalah kelemahan utama sinkron).
2.  **b** (Partition adalah unit paralelisasi di Kafka).
3.  **c** (Durabilitas log Kafka memungkinkan pemulihan bencana/downtime consumer).
4.  **b** (Perbedaan filosofis: *Notification* vs *Command*).
5.  **c** (Kemampuan *Time Travel* atau *Replayability* adalah keunggulan unik sistem berbasis Log).

---

## ğŸš€ Mini Challenge
**Desain Topik:**
Bayangkan aplikasi **Ojek Online**.
1.  Tentukan 1 Topic utama. (Misal: `ride-updates`).
2.  Sebutkan 3 Service yang akan menjadi **Consumer** (Pendengar) topic tersebut.
    * *Contoh Jawaban:* * **Driver Service:** Untuk update lokasi driver.
        * **User App:** Untuk notifikasi "Driver Menuju Lokasi".
        * **Audit Service:** Untuk merekam jejak perjalanan.
3.  Jika Audit Service mati, apakah User App terganggu? (Jawab: Tidak, itulah keindahan EDA).

---
*Siap menghubungkan MongoDB ke Kafka? Ketik **"Lanjut"** untuk masuk ke **Sub-Bab 11.2: Integrasi MongoDB: CDC & Transactional Outbox**.*