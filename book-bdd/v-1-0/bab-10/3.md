# ðŸ“˜ SUB-BAB 10.3: TRANSAKSI TERDISTRIBUSI (SAGA) & POLA CQRS

## ðŸŽ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Menjelaskan mengapa transaksi **ACID** tradisional tidak bisa digunakan lintas-layanan (*Cross-Service*).
2.  Menerapkan **Saga Pattern** untuk menangani transaksi bisnis panjang yang melibatkan banyak microservices.
3.  Membedakan strategi kueri data terdistribusi: **API Composition** (sederhana) vs **CQRS** (kompleks tapi performa tinggi).

---

## ðŸ”— Context & Hook
Kamu menekan tombol "Beli" di aplikasi E-Commerce. Di balik layar, tiga hal harus terjadi:
1.  **Order Service:** Mencatat pesanan.
2.  **Payment Service:** Memotong saldo e-wallet.
3.  **Inventory Service:** Mengurangi stok barang.

Apa yang terjadi jika Saldo berhasil dipotong, tapi ternyata Stok Barang habis (gagal kurangi stok)?
Di sistem Monolitik, database akan melakukan **Rollback** otomatis, saldo kembali utuh.
Di Microservices, database Payment dan Inventory itu **TERPISAH**. Database Payment tidak tahu kalau Inventory gagal. Hasilnya? Uang hilang, barang tidak dapat. Ini adalah mimpi buruk konsistensi.

Bagaimana cara melakukan "Rollback" di dunia yang terpisah-pisah ini? Jawabannya adalah **Saga Pattern**.

---

## ðŸ’¡ Analogi: Agen Travel dan Restoran
1.  **Saga Pattern (Agen Travel):**
    Kamu memesan paket liburan: (1) Tiket Pesawat, (2) Hotel, (3) Sewa Mobil.
    * Kamu berhasil pesan Pesawat âœ….
    * Kamu berhasil pesan Hotel âœ….
    * Ternyata Sewa Mobil habis âŒ.
    * Agen tidak bisa "memutar waktu". Agen harus melakukan **Kompensasi**: Menelepon Hotel untuk *cancel* dan Maskapai untuk *refund*. Liburan batal, uang kembali.
2.  **CQRS (Dapur Restoran):**
    * **Command (Dapur):** Tempat koki bekerja. Sibuk, berantakan, panas, fokus pada *pembuatan* (Write). Strukturnya rumit.
    * **Query (Buku Menu):** Tempat pelanggan melihat. Rapi, ada foto cantik, harga jelas, fokus pada *pembacaan* (Read).
    * Dapur dan Menu adalah dua model yang berbeda. Kamu tidak menyuruh pelanggan masuk ke dapur untuk melihat stok daging mentah.

---

## ðŸ“š Inti Materi

### 1. Masalah Transaksi Terdistribusi
Dalam Microservices, kita kehilangan fitur transaksi global (ACID lintas database). Menggunakan *Two-Phase Commit* (2PC) dianggap buruk karena lambat dan memblokir resource (*locking*).

### 2. Solusi: Saga Pattern
Saga adalah sekumpulan **Transaksi Lokal**. Setiap langkah memperbarui database layanan itu sendiri dan memicu langkah berikutnya.
* **Maju (Success Path):** Order Berhasil -> Event "OrderCreated" -> Payment Berhasil -> Event "Paid" -> Stok Berhasil -> Selesai.
* **Mundur (Failure Path):** Jika Stok Gagal -> Trigger **Kompensasi Transaksi**.
    * *Kompensasi:* Transaksi baru yang tujuannya "membatalkan" efek transaksi sebelumnya.
    * Contoh: Jika `Payment` = "Potong Saldo", maka `Kompensasi Payment` = "Refund Saldo".

### 3. Masalah Kueri: API Composition vs CQRS
Bagaimana cara menampilkan halaman "Riwayat Belanja" yang berisi: Nama Barang (dari Catalog Service) + Status Pengiriman (dari Shipping Service)?

* **Cara 1: API Composition (Sederhana)**
    * Ada satu layanan "API Gateway" yang bertugas menelepon Catalog Service, lalu menelepon Shipping Service, menggabungkan datanya di memori, lalu mengirim ke user.
    * *Kelemahan:* Lambat jika datanya banyak. Jika satu service mati, halaman error.

* **Cara 2: CQRS (Command Query Responsibility Segregation)**
    * Memisahkan jalur Tulis (Command) dan Baca (Query).
    * **Write Model:** Service asli (Catalog/Shipping) fokus melayani transaksi.
    * **Read Model:** Ada database khusus (biasanya MongoDB/Elasticsearch) yang menampung data gabungan dari semua service. Data ini diisi secara asinkron lewat **Event Sourcing/CDC**.
    * *Kelebihan:* Kueri super cepat karena tidak perlu *join* lintas service saat user bertanya. Data sudah siap saji.

---

## ðŸ“± Contoh Penerapan: E-Commerce Dashboard
Bayangkan Dashboard Admin yang butuh menampilkan "Total Penjualan per Kategori".
1.  **Tanpa CQRS:** Admin membuka dashboard -> Sistem melakukan query berat ke Order Service, User Service, dan Catalog Service secara *real-time*. Sistem lambat, user lain yang mau belanja ikut terganggu.
2.  **Dengan CQRS:**
    * Setiap kali ada penjualan, Order Service kirim event ke Kafka.
    * Ada **Analytics Service** yang membaca Kafka dan mengupdate "Tabel Laporan" di MongoDB miliknya sendiri.
    * Admin membuka dashboard -> Mengambil data dari Analytics Service. Cepat, instan, dan tidak mengganggu operasional belanja.

---

## ðŸ“– Mini-Glossary
* **Saga Pattern:** Pola manajemen transaksi terdistribusi yang memecah proses bisnis menjadi rangkaian transaksi lokal.
* **Compensating Transaction:** Transaksi "pembalik" yang dieksekusi untuk membatalkan efek dari transaksi yang sudah terlanjur *commit* jika langkah selanjutnya gagal.
* **CQRS (Command Query Responsibility Segregation):** Pola desain yang memisahkan model untuk memperbarui data (Command) dan model untuk membaca data (Query).
* **API Composition:** Pola penggabungan data di mana satu layanan memanggil beberapa layanan lain dan menggabungkan responsnya.

---

## ðŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Analisis:** Dalam Saga Pattern, jika transaksi "Inventory" gagal, sistem harus menjalankan "Kompensasi Payment". Apa arti "Kompensasi" dalam konteks database?
    * a. Menghapus database.
    * b. Melakukan *Rollback* database secara otomatis menggunakan fitur ACID.
    * c. Menjalankan transaksi *baru* (Insert/Update) yang secara logika membalikkan efek transaksi sebelumnya (misal: Kredit saldo kembali), karena transaksi sebelumnya sudah *committed* dan tidak bisa di-rollback.
    * d. Meminta admin memperbaiki data manual.
    * e. Mengunci saldo user.

2.  **Desain:** Anda membangun fitur "Halaman Profil User" yang menampilkan data diri (User Service), riwayat pesanan (Order Service), dan poin loyalitas (Loyalty Service). Trafik sangat tinggi. Pola mana yang memberikan performa *read* terbaik?
    * a. API Composition (Memanggil 3 API setiap kali halaman dibuka).
    * b. CQRS (Membuat satu 'User View Database' yang menampung gabungan ketiga data tersebut, di-update via event).
    * c. Monolitik Database.
    * d. Client-side Join.
    * e. Direct Database Access.

3.  **Trade-off:** Apa kelemahan utama dari pola CQRS dibandingkan API Composition?
    * a. Performa baca lambat.
    * b. Kompleksitas tinggi (harus mengelola dua model data dan sinkronisasi asinkron), serta adanya *Eventual Consistency* (data di Read model mungkin telat update beberapa detik).
    * c. Tidak bisa di-scale.
    * d. Hanya bisa pakai SQL.
    * e. Tidak aman.

4.  **Skenario:** Transaksi Saga terhenti di tengah jalan (misal: Server mati saat sedang proses Kompensasi). Apa yang harus dilakukan sistem saat menyala kembali?
    * a. Melupakan transaksi tersebut.
    * b. Memulai ulang Saga dari langkah pertama (Idempotent) atau melanjutkan langkah Kompensasi yang tertunda sampai sukses.
    * c. Menghapus data user.
    * d. Mengirim email error.
    * e. Mematikan Kafka.

5.  **Konsep:** Mengapa MongoDB sering menjadi pilihan favorit untuk "Read Database" dalam implementasi CQRS?
    * a. Karena MongoDB mendukung ACID.
    * b. Karena MongoDB lambat.
    * c. Karena fitur fleksibilitas skema dan denormalisasi memudahkan penyimpanan "View" data gabungan yang kompleks (Pre-joined data) siap saji.
    * d. Karena MongoDB gratis.
    * e. Karena MongoDB tidak butuh server.

### Kunci Jawaban
1.  **c** (Di Microservices, transaksi sudah *committed* di DB lokal, jadi harus dibalas dengan transaksi lawan).
2.  **b** (CQRS memindahkan beban "penggabungan data" ke belakang layar, sehingga saat *read* tinggal ambil).
3.  **b** (CQRS adalah *overkill* untuk sistem sederhana karena kerumitan sinkronisasinya).
4.  **b** (Sistem Saga harus *resilient* dan mampu memulihkan state/retry).
5.  **c** (Kemampuan menyimpan dokumen hierarkis sangat cocok untuk *Read Model* yang biasanya berupa tampilan UI lengkap).

---

## ðŸš€ Mini Challenge
**Desain Alur Kompensasi:**
Ambil secarik kertas.
1.  Tulis urutan: **Order Berhasil** -> **Potong Saldo Berhasil** -> **Kurangi Stok GAGAL**.
2.  Tugasmu: Rancang jalur mundurnya.
3.  Apa yang harus dilakukan pada "Potong Saldo"? (Jawab: Refund/Tambah Saldo).
4.  Apa yang harus dilakukan pada "Order"? (Jawab: Update status jadi 'Cancelled' atau 'Failed').
5.  Inilah logika Saga yang harus kamu tulis di kodemu nanti.

---
*Bab 10 selesai! Kamu kini memahami cara mendistribusikan data tanpa kehilangan kendali. Ketik **"Lanjut"** untuk masuk ke **Bagian Penutup (Outro)**.*