# ğŸ“˜ SUB-BAB 10.1: FILOSOFI MICROSERVICES & POLA DATABASE PER SERVICE

## ğŸ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Menjelaskan filosofi dan tantangan **Arsitektur Microservices** dibandingkan arsitektur tradisional **Monolitik**.
2.  Menguasai pola **Database per Service (DPS)** sebagai fondasi otonomi layanan.
3.  Menganalisis mengapa **Basis Data Dokumen (MongoDB)** sangat ideal untuk mendukung isolasi dan kecepatan deployment di lingkungan Microservices.

---

## ğŸ”— Context & Hook
Bayangkan sebuah **Supermarket Raksasa** (Monolitik). Semua barang ada di satu gedung besar dengan satu pintu masuk dan satu sistem kasir sentral. Jika sistem kasir rusak, seluruh supermarket lumpuh. Jika ingin merenovasi bagian pakaian, seluruh gedung mungkin perlu ditutup sementara.

Sekarang bayangkan sebuah **Pasar Modern** (Microservices). Ada toko Roti, toko Buah, dan toko Elektronik yang terpisah-pisah.
* Jika toko Roti tutup, toko Buah tetap buka.
* Jika toko Elektronik ingin merenovasi gedung, toko Roti tidak terganggu.
* Setiap toko punya kasir dan pembukuannya sendiri-sendiri (**Database per Service**).

Inilah inti dari Microservices: memecah sistem besar menjadi unit-unit kecil yang **Otonom** dan **Tahan Banting**.

---

## ğŸ’¡ Analogi: Gedung vs. Kompleks Ruko
* **Monolitik = Gedung Pencakar Langit:**
    Satu struktur besar yang saling terhubung. Pipa air bocor di lantai 10 bisa membanjiri lantai 5. Mengubah struktur fondasi sangat berisiko.
* **Microservices = Kompleks Ruko:**
    Terdiri dari banyak bangunan kecil yang berdiri sendiri. Setiap ruko bebas mengatur interiornya. Jika satu ruko kebakaran, api lebih mudah diisolasi agar tidak merambat ke ruko lain (**Fault Isolation**).

---

## ğŸ“š Inti Materi

### 1. Pergeseran Paradigma: Monolitik ke Microservices
Arsitektur Monolitik menyimpan semua logika bisnis (User, Inventory, Order, Payment) dalam satu basis kode (*codebase*) yang berbagi satu database raksasa.
* **Masalah:** Awalnya mudah, tapi lama-kelamaan menjadi mimpi buruk. Jika satu modul *bug*, seluruh sistem bisa *down*. Developer takut mengubah kode karena efek sampingnya tidak terprediksi.
* **Solusi Microservices:** Memecah aplikasi menjadi layanan-layanan kecil spesifik fungsi. Setiap layanan bisa dikembangkan, di-*deploy*, dan di-*scale* secara independen.

### 2. Pola Database per Service (DPS)
Hukum emas dalam Microservices adalah **Loose Coupling** (Ketergantungan Longgar). Untuk mencapainya, kita menerapkan pola **Database per Service**.
* **Aturan:** Setiap Microservice harus memiliki databasenya sendiri (atau setidaknya skema privat).
* **Larangan:** Service A **DILARANG KERAS** mengakses database Service B secara langsung. Service A hanya boleh meminta data melalui API yang disediakan Service B.
* **Tujuan:** Menjamin otonomi. Tim A bisa mengubah struktur database mereka kapan saja tanpa takut merusak kode Tim B.

### 3. Mengapa MongoDB Ideal untuk Microservices?
Basis Data Dokumen (MongoDB) adalah pasangan alami untuk Microservices karena dua alasan utama:
* **Fleksibilitas Skema:** Setiap layanan berevolusi dengan kecepatan berbeda. MongoDB memungkinkan tim untuk menambah field baru di satu layanan tanpa migrasi skema yang rumit dan tanpa mengganggu layanan lain. Ini mendukung *Developer Velocity*.
* **Denormalisasi (Embedding):** Karena data terpecah-pecah, *join* antar-database itu mustahil atau mahal. Model dokumen memungkinkan kita menyimpan data terkait (misal: Alamat di dalam User) dalam satu dokumen, sehingga mengurangi kebutuhan akan dependensi data eksternal.

### 4. Trade-off (Harga yang Harus Dibayar)
Pemisahan data ini membawa tantangan baru:
* **Isolasi Kegagalan (Pro):** Jika database *Order Service* mati karena *Hot Shard*, database *User Service* tetap aman.
* **Kompleksitas Data (Con):** Transaksi yang dulunya mudah (kurangi stok & buat pesanan) kini menjadi **Transaksi Terdistribusi** lintas database yang rumit. Kita tidak bisa lagi menggunakan transaksi ACID lokal sederhana.

---

## ğŸ“± Contoh Penerapan: Aplikasi E-Commerce
1.  **User Service:** Mengelola data profil pengguna. Menggunakan MongoDB karena skema profil user sering berubah (tambah sosmed, preferensi).
2.  **Order Service:** Mengelola pesanan. Menggunakan MongoDB untuk menyimpan dokumen Pesanan yang kompleks (berisi list barang snapshot).
3.  **Inventory Service:** Mengelola stok. Mungkin menggunakan Redis (Key-Value) karena butuh kecepatan tinggi, atau SQL jika butuh relasi gudang yang ketat (**Polyglot Persistence**).
* Ketiga layanan ini punya database terpisah. *Order Service* tidak bisa langsung *query* tabel stok di *Inventory Service*.

---

## ğŸ“– Mini-Glossary
* **Microservices:** Gaya arsitektur di mana aplikasi disusun sebagai sekumpulan layanan kecil yang dapat di-deploy secara independen.
* **Database per Service:** Pola desain di mana setiap microservice memiliki penyimpanan data persisten privatnya sendiri.
* **Polyglot Persistence:** Praktik menggunakan teknologi database yang berbeda-beda dalam satu sistem untuk menangani kebutuhan spesifik setiap layanan.
* **Fault Isolation:** Kemampuan sistem untuk membatasi dampak kegagalan komponen agar tidak menyebar ke seluruh sistem.

---

## ğŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Analisis:** Mengapa pola *Shared Database* (Satu database besar dipakai ramai-ramai oleh banyak service) dianggap sebagai "Anti-Pattern" dalam Microservices?
    * a. Karena database akan cepat penuh.
    * b. Karena menciptakan *Tight Coupling*; jika satu tim mengubah skema tabel, kode tim lain yang mengakses tabel yang sama akan *error* (rusak).
    * c. Karena lisensi database mahal.
    * d. Karena MongoDB tidak bisa di-share.
    * e. Karena jaringan akan lambat.

2.  **Strategi:** Anda sedang membangun *Catalog Service* yang butuh sering update struktur produk (tambah spek baru). Database apa yang paling mendukung kelincahan ini dalam pola Database per Service?
    * a. RDBMS (SQL) dengan skema kaku.
    * b. Basis Data Dokumen (MongoDB) dengan *Flexible Schema*.
    * c. Flat File CSV.
    * d. Blockchain.
    * e. Graph Database.

3.  **Konsep:** Apa keuntungan utama dari *Fault Isolation* yang ditawarkan oleh pola Database per Service menggunakan MongoDB?
    * a. Data menjadi lebih konsisten.
    * b. Tidak ada data yang duplikat.
    * c. Kegagalan pada database satu layanan (misal: *crash* akibat beban tinggi) tidak akan melumpuhkan layanan lain, menjaga ketersediaan sistem parsial.
    * d. Backup data jadi tidak perlu.
    * e. Transaksi jadi lebih cepat.

4.  **Tantangan:** Apa konsekuensi terberat dari memecah data user dan data pesanan ke dalam dua database terpisah?
    * a. Harddisk cepat penuh.
    * b. Tidak bisa lagi melakukan operasi `JOIN` database secara langsung; harus melakukan *API Composition* atau *Data Replication*.
    * c. MongoDB tidak mendukungnya.
    * d. User harus login dua kali.
    * e. Data pesanan akan hilang.

5.  **Definisi:** Istilah untuk strategi menggunakan MongoDB untuk *Product Service*, Redis untuk *Cart Service*, dan Neo4j untuk *Recommendation Service* dalam satu aplikasi adalah...
    * a. Monolitik.
    * b. Sharding.
    * c. Polyglot Persistence.
    * d. Replication.
    * e. Big Data.

### Kunci Jawaban
1.  **b** (Ketergantungan skema menghambat otonomi tim).
2.  **b** (Adaptasi cepat tanpa *downtime* migrasi adalah kunci).
3.  **c** (Sistem tetap hidup sebagian/"Graceful Degradation").
4.  **b** (Hilangnya kemampuan JOIN lokal adalah *trade-off* utama).
5.  **c** (Memilih alat yang tepat untuk pekerjaan yang tepat).

---

## ğŸš€ Mini Challenge
**Desain Arsitek:**
Ambil secarik kertas. Gambar kotak besar "E-Commerce".
1.  Pecah menjadi 3 kotak kecil: *User*, *Product*, *Order*.
2.  Berikan masing-masing "Tabung" (Database) sendiri.
3.  Tarik garis: Bagaimana *Order* tahu nama *User*? (Ingat, tidak boleh tarik garis antar-Tabung database!).
4.  Jawabannya: Tarik garis antar-Kotak Layanan (API Call).

---
*Siap menangani masalah data yang terpisah-pisah ini? Ketik **"Lanjut"** untuk masuk ke **Sub-Bab 10.2: Menjaga Konsistensi: Event Sourcing & CDC**.*