# ğŸ“˜ SUB-BAB 10.2: MENJAGA KONSISTENSI: EVENT SOURCING & CDC

## ğŸ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Menjelaskan tantangan **Konsistensi Data** di lingkungan terdistribusi di mana data tersebar di banyak database.
2.  Membedakan pola **Event Sourcing** (Aplikasi aktif melapor) dan **Change Data Capture / CDC** (Database pasif dipantau).
3.  Menganalisis bagaimana **Oplog MongoDB** menjadi jantung dari mekanisme sinkronisasi data real-time antar-layanan.

---

## ğŸ”— Context & Hook
Di sub-bab sebelumnya, kita sepakat bahwa *Service A* tidak boleh mengintip database *Service B*. Tapi, bagaimana jika *Service B* **butuh** data dari *Service A*?

Contoh: Saat *User Service* memperbarui alamat pengguna, *Shipping Service* harus tahu alamat baru itu untuk pengiriman barang.
* **Cara Lama (Request):** *Shipping Service* menelepon (API Call) ke *User Service* setiap kali mau kirim barang. Lambat dan *Shipping Service* mati jika *User Service* down.
* **Cara Modern (Replikasi Data):** *Shipping Service* menyimpan salinan alamat user di databasenya sendiri. Masalahnya: Bagaimana cara *Shipping Service* tahu kalau alamat di *User Service* berubah? Kita butuh "Mata-Mata" yang memantau perubahan data.

---

## ğŸ’¡ Analogi: Papan Pengumuman vs. Detektif
1.  **Event Sourcing (Papan Pengumuman):**
    Setiap kali User Service mengubah alamat, ia secara sadar menulis di papan pengumuman (Message Broker): "Halo semua, Budi pindah rumah!". Service lain membaca pengumuman itu.
    * *Kelemahan:* Developer harus menulis kode "Lapor ke Papan" di setiap fungsi update. Jika lupa, data tidak sinkron.
2.  **Change Data Capture / CDC (Detektif):**
    User Service tidak perlu melapor. Ada **Detektif (Tool CDC)** yang diam-diam membaca buku catatan harian database (**Oplog**). Begitu ada tulisan baru di buku harian, Detektif langsung memberitahu service lain.
    * *Kelebihan:* Otomatis, tidak mengganggu kode aplikasi utama, dan sangat akurat.

---

## ğŸ“š Inti Materi

### 1. Masalah Data Silo
Dalam Microservices, data terkotak-kotak (Silo). Namun, bisnis butuh pandangan utuh. Kita sering perlu menduplikasi data dari satu service ke service lain (Data Replication) untuk kinerja *read* yang cepat dan kemandirian (*autonomy*). Tantangannya adalah menjaga duplikat data ini tetap **Sinkron**.

### 2. Event Sourcing (Pola Aplikasi)
Dalam pola ini, perubahan state aplikasi disimpan sebagai urutan *event* (kejadian).
* Bukan menyimpan "Stok Akhir = 5", tapi menyimpan urutan: "Stok Masuk 10", "Stok Keluar 2", "Stok Keluar 3".
* Service lain bisa "memutar ulang" event ini untuk mengetahui state terakhir.
* Ini membutuhkan perubahan cara coding yang drastis.

### 3. Change Data Capture (CDC) - Solusi Infrastruktur
CDC adalah teknik modern yang lebih populer karena sifatnya *non-intrusif*.
* **Cara Kerja:** Tool CDC (seperti Debezium atau Kafka Connect) terhubung ke **MongoDB Oplog** (Log Operasi yang kita bahas di Bab 7).
* **Mekanisme:** Setiap kali ada operasi *Insert/Update/Delete* di MongoDB, Oplog mencatatnya. CDC membaca entri baru di Oplog dan mengirimkannya sebagai *Event Stream* ke Message Broker (seperti Kafka).
* **Hasil:** Service lain (Subscriber) menerima update data secara *Real-Time* tanpa membebani kinerja database utama.

### 4. Konsistensi Akhir (Eventual Consistency)
Dengan pola ini, kita menerima fakta bahwa data tidak akan konsisten secara instan di detik yang sama.
* User update alamat di detik 00:01.
* CDC menangkap perubahan di detik 00:02.
* Shipping Service update databasenya di detik 00:03.
* Ada jeda 2 detik (**Replication Lag**), tapi sistem menjamin data **Pasti Konsisten** pada akhirnya.

---

## ğŸ“± Contoh Penerapan: Aplikasi Ojek Online
1.  **Driver Service (MongoDB):** Driver mengubah status dari "Off" menjadi "Active".
2.  **Oplog:** MongoDB mencatat update `{driver_id: 1, status: "Active"}` di Oplog.
3.  **CDC Connector:** Membaca Oplog, lalu mengirim event ke Kafka topik `driver-updates`.
4.  **Map Service (Subscriber):** Menerima event dari Kafka, lalu memunculkan ikon motor driver tersebut di Peta Penumpang.
5.  **Hasil:** Peta penumpang selalu update tanpa perlu *Map Service* melakukan query terus-menerus ke database driver.

---

## ğŸ“– Mini-Glossary
* **Event Sourcing:** Pola arsitektur di mana state aplikasi ditentukan oleh urutan event yang terjadi, bukan hanya data snapshot terakhir.
* **Change Data Capture (CDC):** Proses mengidentifikasi dan menangkap perubahan data di database sumber untuk dikirimkan ke sistem lain.
* **Oplog (Operation Log):** Log internal MongoDB yang mencatat semua operasi modifikasi data; sumber kebenaran utama untuk CDC.
* **Eventual Consistency:** Model konsistensi yang menjamin bahwa jika tidak ada update baru, semua salinan data pada akhirnya akan menjadi sama (sinkron).

---

## ğŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Analisis:** Mengapa menggunakan teknik CDC (Change Data Capture) dianggap lebih aman dan reliabel dibandingkan meminta developer menyisipkan kode "Kirim Event" secara manual di setiap fungsi aplikasi?
    * a. Karena CDC lebih cepat.
    * b. Karena CDC memisahkan proses penangkapan data dari logika aplikasi (decoupling); ini menghilangkan risiko *human error* (developer lupa kirim event) dan menjamin setiap perubahan di database pasti tertangkap.
    * c. Karena CDC tidak butuh server.
    * d. Karena aplikasi jadi lebih kecil.
    * e. Karena database tidak suka diganggu.

2.  **Teknis:** Komponen internal MongoDB apa yang menjadi "bahan bakar" utama bagi tool CDC untuk bekerja memantau perubahan data?
    * a. WiredTiger Cache.
    * b. Journaling.
    * c. Oplog (Operation Log).
    * d. Shard Key.
    * e. Config Server.

3.  **Skenario:** *Order Service* menggunakan CDC untuk mengirim data pesanan ke *Analytics Service*. Apa yang terjadi pada *Order Service* jika *Analytics Service* tiba-tiba mati total?
    * a. *Order Service* ikut mati (Crash).
    * b. Transaksi pesanan gagal.
    * c. Tidak ada dampak pada operasional *Order Service* (Decoupled); event perubahan data akan antre di Message Broker sampai *Analytics Service* nyala kembali.
    * d. Data pesanan hilang.
    * e. Database MongoDB terkunci.

4.  **Konsep:** Apa trade-off utama yang harus diterima developer ketika beralih dari konsistensi ACID (Monolitik) ke Eventual Consistency (Microservices dengan CDC)?
    * a. Data menjadi tidak aman.
    * b. Adanya jeda waktu (latency) singkat antara perubahan data di service sumber dengan terupdatenya data di service tujuan.
    * c. Biaya server lebih mahal.
    * d. Data tidak bisa di-query.
    * e. User harus login ulang.

5.  **Desain:** Anda ingin membuat fitur "Log Audit" yang mencatat *siapa* mengubah data *apa* di seluruh 50 microservices perusahaan Anda. Cara paling efisien dan minim dampak terhadap kinerja aplikasi adalah...
    * a. Menambahkan kode logging di setiap fungsi API di 50 service.
    * b. Membaca file log server satu per satu.
    * c. Mengimplementasikan pipeline CDC terpusat yang menyedot data perubahan dari semua database service dan menyimpannya ke Data Lake audit.
    * d. Meminta user melapor jika mengubah data.
    * e. Melakukan query `SELECT *` setiap 5 menit.

### Kunci Jawaban
1.  **b** (CDC menjamin *reliability* penangkapan data pada level infrastruktur, bukan kode).
2.  **c** (Oplog adalah sumber log kronologis perubahan data di MongoDB).
3.  **c** (Sifat *asinkron* CDC melindungi service utama dari kegagalan service hilir).
4.  **b** (Jeda waktu sinkronisasi adalah harga mati sistem terdistribusi).
5.  **c** (Pola arsitektur terpusat non-intrusif terbaik untuk audit trail global).

---

## ğŸš€ Mini Challenge
**Simulasi Detektif Oplog:**
1.  Bayangkan sebuah dokumen User: `{id: 1, nama: "Budi", saldo: 5000}`.
2.  Terjadi transaksi: Budi beli pulsa 1000.
3.  Tuliskan di kertas apa yang kira-kira dicatat oleh **Oplog**?
    * *Jawaban:* Oplog tidak mencatat `{nama: "Budi", saldo: 4000}`, tapi mencatat **Operasi**: `UPDATE users SET saldo = saldo - 1000 WHERE id = 1`.
4.  Mengapa mencatat "Operasi" lebih baik daripada mencatat "Data Akhir"? (Petunjuk: Agar service lain tahu *apa yang terjadi*, bukan cuma hasil akhirnya).

---
*Data sudah mengalir, tapi bagaimana dengan transaksi yang harus "Sukses Semua atau Gagal Semua" di banyak service? Ketik **"Lanjut"** untuk masuk ke **Sub-Bab 10.3: Transaksi Terdistribusi (Saga) & Pola CQRS**.*