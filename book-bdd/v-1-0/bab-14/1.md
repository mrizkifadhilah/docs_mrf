# ðŸ“˜ SUB-BAB 14.1: PERFORMANCE PROFILING: MENCARI BOTTLENECK

## ðŸŽ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Menggunakan alat **Profiler** untuk mengukur penggunaan CPU dan Memori aplikasi secara *real-time*.
2.  Mendeteksi dan menganalisis **Bottleneck** (sumbatan kinerja) menggunakan visualisasi *Flame Graph*.
3.  Mengidentifikasi tanda-tanda **Memory Leak** (kebocoran memori) yang menyebabkan aplikasi melambat seiring waktu.

---

## ðŸ”— Context & Hook
Bayangkan kamu adalah seorang pembalap F1. Mobilmu terasa lambat di tikungan. Kamu tidak bisa sembarangan menebak, "Ah, mungkin bannya kempes," atau "Mungkin mesinnya rusak." Kamu butuh data. Tim mekanik akan menyolokkan komputer ke mobil untuk melihat grafik telemetri: suhu mesin, tekanan oli, dan RPM.

Dalam pemrograman, menebak-nebak penyebab aplikasi lambat ("Sepertinya *looping* ini berat deh...") adalah tindakan amatir. Profesional menggunakan data. Alat telemetri untuk *software* itu # ðŸ“˜ SUB-BAB 14.1: EVOLUSI INFRASTRUKTUR: IAAS VS DBAAS

## ðŸŽ¯ Tujuan Pembelajaran
Setelah mempelajari sub-bab ini, kamu akan mampu:
1.  Membedakan antara model **IaaS (Self-Hosting)** dan **DBaaS (Managed Service)** dalam konteks penyediaan database.
2.  Menganalisis **Trade-off** antara kontrol penuh yang ditawarkan IaaS dengan kemudahan operasional yang ditawarkan DBaaS.
3.  Menentukan strategi infrastruktur yang tepat berdasarkan kebutuhan tim (Control vs Velocity).

---

## ðŸ”— Context & Hook
Dulu, jika ingin menjalankan MongoDB di cloud, kamu harus menyewa "Komputer Kosong" (Virtual Machine) di AWS atau Google Cloud. Kamu harus install Linux, download MongoDB, setting config, atur firewall, dan update antivirus sendiri. Ini disebut **Self-Hosting** di atas **IaaS**.

Cara ini memberi kontrol penuh, tapi sangat merepotkan. Bayangkan jika kamu bisa memesan database seperti memesan pizza? "Saya mau MongoDB, ukuran Large, topping Sharding". Dalam 5 menit, database siap pakai tanpa kamu perlu menyentuh terminal Linux. Inilah revolusi **DBaaS (Database as a Service)**.

---

## ðŸ’¡ Analogi: Mobil Balap vs. Taksi Online
1.  **IaaS / Self-Hosting = Memiliki Mobil Balap:**
    Kamu punya kontrol absolut. Kamu bisa mengganti jenis oli, menyetel suspensi, dan memodifikasi mesin sesuka hati.
    * *Konsekuensi:* Kamu harus menjadi mekanik. Jika ban bocor atau mesin mogok di tengah jalan, itu urusanmu. Kamu harus rutin servis (patching) sendiri.
2.  **DBaaS = Taksi Online:**
    Kamu hanya peduli pada **Tujuan** (Data). Kamu tinggal duduk, dan sopir (Cloud Provider) yang mengurus bensin, ganti oli, bayar pajak, dan menyetir di kemacetan.
    * *Konsekuensi:* Kamu tidak bisa menyuruh sopir mengganti mesin mobilnya. Kamu kehilangan kontrol low-level, tapi kamu sampai tujuan dengan santai.

---

## ðŸ“š Inti Materi

### 1. IaaS (Infrastructure as a Service) - The Self-Hosted Way
Dalam model ini, kamu menyewa infrastruktur dasar (Server/VM, Network, Storage) dari penyedia cloud (seperti AWS EC2).
* **Tanggung Jawabmu:** Menginstal OS, menginstal MongoDB, konfigurasi Replica Set, setup Backup script, Patching keamanan OS, dan Monitoring.
* **Keunggulan:** Kontrol penuh. Kamu bisa mengutak-atik kernel OS atau file sistem untuk performa ekstrem.
* **Kelemahan:** **Ops Overhead** yang sangat tinggi. Timmu habis waktu untuk *maintenance* server, bukan bikin fitur aplikasi.

### 2. DBaaS (Database as a Service) - The Managed Way
DBaaS adalah bentuk PaaS (Platform as a Service) khusus database (seperti MongoDB Atlas, AWS DocumentDB).
* **Tanggung Jawab Provider:** Cloud provider mengelola seluruh "Tumpukan Bawah": Hardware, OS, Instalasi DB, Patching, Backup Otomatis, dan Failover.
* **Tanggung Jawabmu:** Hanya mengelola Skema Data, User (Auth), dan Indeks.
* **Keunggulan:** **Developer Velocity**. Tim bisa fokus coding. Fitur canggih seperti *Point-in-Time Recovery* (PITR) dan *Auto-Scaling* seringkali tinggal "klik tombol".

### 3. Analisis Trade-off
Beralih ke DBaaS berarti menukar **Kontrol** dengan **Kemudahan**.
* Di IaaS, jika server lambat, kamu bisa masuk (SSH) dan cek proses apa yang memakan CPU.
* Di DBaaS, kamu seringkali tidak punya akses SSH ke server fisik. Kamu bergantung pada dashboard yang disediakan provider. Namun, bagi 99% perusahaan, kemudahan operasional DBaaS jauh lebih bernilai daripada kontrol mikro tersebut.

---

## ðŸ“± Contoh Penerapan: Startup vs Enterprise
1.  **Startup Cepat:** Menggunakan **MongoDB Atlas (DBaaS)**. Timnya hanya 3 orang. Mereka tidak punya waktu untuk mengurus server Linux yang *crash*. Mereka ingin fitur "Auto-Scaling" nyala otomatis saat masuk berita.
2.  **Perusahaan Keamanan Tinggi:** Mungkin memilih **IaaS**. Mereka punya aturan regulasi ketat bahwa database harus berjalan di OS versi tertentu yang sudah dikeraskan (*hardened*) secara khusus oleh tim internal mereka, yang tidak didukung oleh provider DBaaS umum.

---

## ðŸ“– Mini-Glossary
* **IaaS (Infrastructure as a Service):** Layanan cloud yang menyediakan sumber daya komputasi dasar (VM, Storage) yang harus dikelola sendiri.
* **DBaaS (Database as a Service):** Layanan cloud yang menyediakan database siap pakai di mana penyedia mengelola aspek operasional dan pemeliharaan.
* **Self-Hosting:** Praktik mengelola dan memelihara server database sendiri di atas infrastruktur IaaS atau on-premise.
* **Ops Overhead:** Beban kerja operasional (waktu dan tenaga) yang dibutuhkan untuk menjaga sistem tetap berjalan.

---

## ðŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Analisis:** Apa keuntungan utama beralih dari *Self-Hosting* MongoDB di AWS EC2 (IaaS) ke MongoDB Atlas (DBaaS) bagi tim developer yang kecil?
    * a. Biaya server pasti lebih murah.
    * b. Mendapatkan akses root ke OS.
    * c. Mengurangi *Ops Overhead* secara drastis (tidak perlu pusing backup/patching manual), sehingga tim bisa fokus pada pengembangan fitur aplikasi.
    * d. Database menjadi open source.
    * e. Tidak butuh koneksi internet.

2.  **Konsep:** Dalam model DBaaS, manakah di bawah ini yang BUKAN menjadi tanggung jawab penyedia cloud (Cloud Provider)?
    * a. Mengganti harddisk yang rusak.
    * b. Melakukan update patch keamanan OS.
    * c. Melakukan backup snapshot otomatis.
    * d. Merancang skema database (Schema Design) dan membuat Indeks yang efisien.
    * e. Menjamin server menyala (Uptime).

3.  **Analogi:** Jika IaaS diibaratkan "Menyewa tanah kosong dan membangun rumah sendiri", maka DBaaS diibaratkan seperti...
    * a. Membeli tanah.
    * b. Menyewa kamar hotel (Fasilitas lengkap, ada layanan kebersihan, tinggal masuk).
    * c. Menjadi arsitek.
    * d. Tidur di tenda.
    * e. Membeli batu bata.

4.  **Trade-off:** Apa kerugian atau keterbatasan utama yang mungkin dirasakan oleh *System Engineer* senior saat menggunakan DBaaS dibandingkan IaaS?
    * a. Database terlalu cepat.
    * b. Kehilangan kontrol low-level (misalnya tidak bisa tuning parameter kernel Linux atau install agen monitoring kustom di level OS).
    * c. Tidak ada backup.
    * d. Harus coding lebih banyak.
    * e. Susah login.

5.  **Skenario:** Perusahaanmu membutuhkan database yang *High Availability* (HA) dengan *Auto-Failover*. Jika menggunakan IaaS, kamu harus setting manual Replica Set dan Config file. Jika menggunakan DBaaS, bagaimana caranya?
    * a. Harus bayar konsultan mahal.
    * b. Fitur tersebut biasanya sudah *Built-in* dan aktif secara default atau cukup dengan konfigurasi minimal di dashboard (misal: pilih jumlah node).
    * c. Tidak mungkin dilakukan di DBaaS.
    * d. Harus install software tambahan.
    * e. Harus punya 10 server.

### Kunci Jawaban
1.  **c** (Fokus pada efisiensi SDM dan waktu).
2.  **d** (Logika aplikasi dan struktur data tetap tanggung jawab pengguna/Arsitek Data).
3.  **b** (Menekankan aspek layanan penuh/managed).
4.  **b** (Sifat "Black Box" dari layanan managed).
5.  **b** (Kemudahan konfigurasi infrastruktur kompleks).

---

## ðŸš€ Mini Challenge
**Hitung Biaya Tersembunyi:**
Bandingkan biaya:
1.  **Opsi A (IaaS):** Sewa Server Rp 1 Juta/bulan. Tapi butuh 1 Engineer (Gaji Rp 10 Juta) yang menghabiskan 50% waktunya untuk maintenance server.
2.  **Opsi B (DBaaS):** Biaya langganan Rp 3 Juta/bulan. Engineer tidak perlu maintenance, bisa full coding fitur baru.
3.  Mana yang lebih untung secara TCO (*Total Cost of Ownership*)? (Jawab: Opsi B, karena hemat gaji Engineer senilai Rp 5 Juta).

---
*Sudah yakin pindah ke Cloud? Mari kita lihat fitur "sakti" apa yang ditawarkan Cloud untuk masalah terberat kita: Sharding. Ketik **"Lanjut"** untuk masuk ke **Sub-Bab 14.2: Keunggulan MongoDB Atlas: Otomatisasi Skala**.*disebut **Profiler**. Tanpa Profiler, optimasi hanyalah tebak-tebakan buta.

---

## ðŸ’¡ Analogi: Dokter dan Mesin Rontgen
* **Aplikasi Lambat = Pasien Sakit:**
    Pasien datang mengeluh "Saya lemas". Dokter tidak langsung membedah perutnya.
* **Profiler = Mesin Rontgen/MRI:**
    Dokter menggunakan alat *scan* untuk melihat ke dalam tubuh tanpa membedahnya.
    * Jika terlihat ada sumbatan di pembuluh darah, itu adalah **CPU Bottleneck** (prosesor macet).
    * Jika terlihat ada cairan menumpuk yang tidak terbuang, itu adalah **Memory Leak** (sampah memori menumpuk).

---

## ðŸ“š Inti Materi

### 1. Apa itu Performance Profiling?
*Profiling* adalah proses memantau perilaku aplikasi saat sedang berjalan (*runtime*) untuk mengukur konsumsi sumber daya. Alatnya disebut **Profiler** (misalnya: Chrome DevTools Performance Tab, Android Studio Profiler, Xcode Instruments).

### 2. Dua Metrik Utama
Profiler biasanya memantau dua hal vital:
* **CPU Usage (Waktu Proses):** Seberapa keras otak komputer bekerja. Jika CPU terus-menerus 100%, HP akan panas dan baterai boros. Alat visualisasinya sering disebut **Flame Graph** atau **Call Tree**, yang menunjukkan fungsi mana yang paling lama memakan waktu CPU.
* **Memory Consumption (RAM):** Seberapa banyak ruang memori yang dipakai.

### 3. Masalah Klasik: Memory Leak
Bahasa modern (Java, JS, Python) memiliki **Garbage Collection (GC)**, yaitu petugas kebersihan otomatis yang membuang data tak terpakai dari RAM.
* **Memory Leak** terjadi ketika kodemu secara tidak sengaja "memegang" referensi ke objek yang sudah tidak dipakai, sehingga GC tidak berani membuangnya.
* **Dampak:** RAM perlahan penuh. Aplikasi awalnya cepat, tapi setelah 1 jam menjadi sangat lambat, dan akhirnya *crash* (Force Close) karena kehabisan memori (*Out of Memory*).
* **Solusi:** Gunakan fitur **Heap Snapshot** di Profiler untuk memotret isi memori dan mencari objek yang jumlahnya terus bertambah secara tidak wajar.

---

## ðŸ“± Contoh Penerapan: Aplikasi Galeri Foto
Kamu membuat aplikasi galeri. Pengguna melapor: "Makin lama dipakai *scrolling*, makin nge-lag."
1.  **Analisis:** Kamu menyalakan Profiler Memori.
2.  **Temuan:** Kamu melihat grafik RAM berbentuk "Tangga" (naik terus, tidak pernah turun).
3.  **Investigasi:** Kamu ambil *Heap Snapshot*. Ternyata, setiap kali foto digeser keluar layar, objek foto itu tidak dihapus dari memori karena masih ada variabel global yang menyimpannya.
4.  **Perbaikan:** Hapus referensi variabel tersebut. Grafik RAM kembali "Gergaji" (naik saat *load*, turun saat GC bekerja). Masalah selesai.

---

## ðŸ“– Mini-Glossary
* **Profiler:** Alat analisis kinerja untuk memantau penggunaan CPU, Memori, dan Jaringan secara *real-time*.
* **Bottleneck:** Titik kemacetan dalam sistem yang membatasi kinerja keseluruhan (bagian paling lambat).
* **Garbage Collection (GC):** Mekanisme otomatis membebaskan memori yang tidak lagi digunakan oleh program.
* **Memory Leak:** Kondisi di mana memori gagal dibebaskan, menyebabkan penggunaan RAM terus meningkat hingga aplikasi *crash*.
* **Heap Snapshot:** Potret instan isi memori pada satu titik waktu tertentu untuk analisis objek.
* **Flame Graph:** Visualisasi grafik batang bertumpuk untuk melihat seberapa dalam dan lama sebuah fungsi kode dijalankan.

---

## ðŸ“ Evaluasi Singkat

### 5 Soal Pilihan Ganda (HOTS)

1.  **Diagnosis:** Jika sebuah aplikasi berjalan sangat lancar di 5 menit pertama, tetapi menjadi sangat lambat dan patah-patah setelah digunakan selama 30 menit tanpa henti, apa diagnosis yang paling mungkin?
    * a. CPU Bottleneck (Algoritma sorting terlalu berat).
    * b. Jaringan internet terputus.
    * c. Memory Leak (Kebocoran memori yang menumpuk).
    * d. Server down.
    * e. Resolusi layar terlalu tinggi.

2.  **Analisis Tool:** Kamu melihat **Flame Graph** di Profiler. Ada satu batang yang sangat lebar (panjang secara horizontal). Apa artinya?
    * a. Fungsi tersebut memakan banyak memori.
    * b. Fungsi tersebut memakan waktu eksekusi CPU yang lama (lambat).
    * c. Fungsi tersebut dipanggil berkali-kali.
    * d. Fungsi tersebut error.
    * e. Fungsi tersebut sudah dihapus.

3.  **Konsep:** Mengapa kita tidak boleh hanya mengandalkan *Garbage Collector (GC)* untuk mencegah kehabisan memori?
    * a. Karena GC kadang-kadang mogok kerja.
    * b. Karena GC hanya bisa menghapus objek yang tidak memiliki referensi (yang benar-benar dilepas oleh developer); jika developer lupa melepas referensi, GC tidak bisa menyentuhnya.
    * c. Karena GC memakan biaya lisensi mahal.
    * d. Karena GC hanya ada di bahasa C++.
    * e. Karena GC menghapus kode program.

4.  **Strategi:** Kapan waktu yang paling tepat untuk menggunakan Profiler?
    * a. Setiap kali menulis satu baris kode.
    * b. Hanya saat user sudah komplain aplikasi crash.
    * c. Secara berkala saat fase testing (QA) dan saat ada indikasi masalah kinerja, untuk memvalidasi asumsi.
    * d. Saat aplikasi sedang di-install.
    * e. Tidak perlu pakai Profiler, cukup tebak saja.

5.  **Identifikasi:** Manakah di bawah ini yang merupakan tanda visual dari penggunaan memori yang SEHAT pada grafik Profiler?
    * a. Garis lurus yang terus menanjak naik tanpa henti.
    * b. Garis rata di angka 0.
    * c. Pola "Gergaji" (Sawtooth): Naik saat alokasi objek, lalu turun drastis saat Garbage Collector (GC) membersihkannya, dan berulang stabil.
    * d. Pola acak yang tidak beraturan.
    * e. Grafik yang hilang timbul.

### Kunci Jawaban
1.  **c** (Gejala khas Memory Leak adalah degradasi performa seiring durasi pemakaian).
2.  **b** (Lebar pada Flame Graph merepresentasikan durasi waktu CPU).
3.  **b** (GC bukan sihir; developer tetap harus memutus referensi objek yang tidak dipakai).
4.  **c** (*Profiling* adalah alat diagnostik dan validasi, bukan alat penulisan kode).
5.  **c** (Pola gergaji menandakan GC bekerja efektif membersihkan sampah memori secara berkala).

---

## ðŸš€ Mini Challenge
**Detektif Chrome:**
1.  Buka browser Google Chrome di PC/Laptop.
2.  Buka website berita yang berat (banyak iklan).
3.  Klik kanan -> **Inspect** -> Pilih tab **Performance**.
4.  Klik tombol rekam (lingkaran), lalu *scroll* halaman web tersebut naik-turun selama 5 detik. Stop rekaman.
5.  Lihat grafiknya: Apakah ada warna kuning/merah yang mendominasi?
6.  Pindah ke tab **Memory**, pilih "Heap Snapshot", dan klik "Take Snapshot". Lihat berapa MB memori yang dimakan satu halaman web itu. (Kadang bisa kaget melihat angka 100MB+ untuk satu tab!).

---
*Siap mendinginkan CPU yang kepanasan? Ketik **"Lanjut"** untuk masuk ke **Sub-Bab 14.2: Optimasi CPU: Throttling & Debouncing**.*